{"ast":null,"code":"/**\n * Swiper 8.4.3\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2022 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: October 6, 2022\n */\n\n!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define(t) : (e = \"undefined\" != typeof globalThis ? globalThis : e || self).Swiper = t();\n}(this, function () {\n  \"use strict\";\n\n  function e(e) {\n    return null !== e && \"object\" == typeof e && \"constructor\" in e && e.constructor === Object;\n  }\n  function t(s, a) {\n    void 0 === s && (s = {}), void 0 === a && (a = {}), Object.keys(a).forEach(i => {\n      void 0 === s[i] ? s[i] = a[i] : e(a[i]) && e(s[i]) && Object.keys(a[i]).length > 0 && t(s[i], a[i]);\n    });\n  }\n  const s = {\n    body: {},\n    addEventListener() {},\n    removeEventListener() {},\n    activeElement: {\n      blur() {},\n      nodeName: \"\"\n    },\n    querySelector: () => null,\n    querySelectorAll: () => [],\n    getElementById: () => null,\n    createEvent: () => ({\n      initEvent() {}\n    }),\n    createElement: () => ({\n      children: [],\n      childNodes: [],\n      style: {},\n      setAttribute() {},\n      getElementsByTagName: () => []\n    }),\n    createElementNS: () => ({}),\n    importNode: () => null,\n    location: {\n      hash: \"\",\n      host: \"\",\n      hostname: \"\",\n      href: \"\",\n      origin: \"\",\n      pathname: \"\",\n      protocol: \"\",\n      search: \"\"\n    }\n  };\n  function a() {\n    const e = \"undefined\" != typeof document ? document : {};\n    return t(e, s), e;\n  }\n  const i = {\n    document: s,\n    navigator: {\n      userAgent: \"\"\n    },\n    location: {\n      hash: \"\",\n      host: \"\",\n      hostname: \"\",\n      href: \"\",\n      origin: \"\",\n      pathname: \"\",\n      protocol: \"\",\n      search: \"\"\n    },\n    history: {\n      replaceState() {},\n      pushState() {},\n      go() {},\n      back() {}\n    },\n    CustomEvent: function () {\n      return this;\n    },\n    addEventListener() {},\n    removeEventListener() {},\n    getComputedStyle: () => ({\n      getPropertyValue: () => \"\"\n    }),\n    Image() {},\n    Date() {},\n    screen: {},\n    setTimeout() {},\n    clearTimeout() {},\n    matchMedia: () => ({}),\n    requestAnimationFrame: e => \"undefined\" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),\n    cancelAnimationFrame(e) {\n      \"undefined\" != typeof setTimeout && clearTimeout(e);\n    }\n  };\n  function r() {\n    const e = \"undefined\" != typeof window ? window : {};\n    return t(e, i), e;\n  }\n  class n extends Array {\n    constructor(e) {\n      \"number\" == typeof e ? super(e) : (super(...(e || [])), function (e) {\n        const t = e.__proto__;\n        Object.defineProperty(e, \"__proto__\", {\n          get: () => t,\n          set(e) {\n            t.__proto__ = e;\n          }\n        });\n      }(this));\n    }\n  }\n  function l(e) {\n    void 0 === e && (e = []);\n    const t = [];\n    return e.forEach(e => {\n      Array.isArray(e) ? t.push(...l(e)) : t.push(e);\n    }), t;\n  }\n  function o(e, t) {\n    return Array.prototype.filter.call(e, t);\n  }\n  function d(e, t) {\n    const s = r(),\n      i = a();\n    let l = [];\n    if (!t && e instanceof n) return e;\n    if (!e) return new n(l);\n    if (\"string\" == typeof e) {\n      const s = e.trim();\n      if (s.indexOf(\"<\") >= 0 && s.indexOf(\">\") >= 0) {\n        let e = \"div\";\n        0 === s.indexOf(\"<li\") && (e = \"ul\"), 0 === s.indexOf(\"<tr\") && (e = \"tbody\"), 0 !== s.indexOf(\"<td\") && 0 !== s.indexOf(\"<th\") || (e = \"tr\"), 0 === s.indexOf(\"<tbody\") && (e = \"table\"), 0 === s.indexOf(\"<option\") && (e = \"select\");\n        const t = i.createElement(e);\n        t.innerHTML = s;\n        for (let e = 0; e < t.childNodes.length; e += 1) l.push(t.childNodes[e]);\n      } else l = function (e, t) {\n        if (\"string\" != typeof e) return [e];\n        const s = [],\n          a = t.querySelectorAll(e);\n        for (let e = 0; e < a.length; e += 1) s.push(a[e]);\n        return s;\n      }(e.trim(), t || i);\n    } else if (e.nodeType || e === s || e === i) l.push(e);else if (Array.isArray(e)) {\n      if (e instanceof n) return e;\n      l = e;\n    }\n    return new n(function (e) {\n      const t = [];\n      for (let s = 0; s < e.length; s += 1) -1 === t.indexOf(e[s]) && t.push(e[s]);\n      return t;\n    }(l));\n  }\n  d.fn = n.prototype;\n  const c = {\n    addClass: function () {\n      for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];\n      const a = l(t.map(e => e.split(\" \")));\n      return this.forEach(e => {\n        e.classList.add(...a);\n      }), this;\n    },\n    removeClass: function () {\n      for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];\n      const a = l(t.map(e => e.split(\" \")));\n      return this.forEach(e => {\n        e.classList.remove(...a);\n      }), this;\n    },\n    hasClass: function () {\n      for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];\n      const a = l(t.map(e => e.split(\" \")));\n      return o(this, e => a.filter(t => e.classList.contains(t)).length > 0).length > 0;\n    },\n    toggleClass: function () {\n      for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];\n      const a = l(t.map(e => e.split(\" \")));\n      this.forEach(e => {\n        a.forEach(t => {\n          e.classList.toggle(t);\n        });\n      });\n    },\n    attr: function (e, t) {\n      if (1 === arguments.length && \"string\" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0;\n      for (let s = 0; s < this.length; s += 1) if (2 === arguments.length) this[s].setAttribute(e, t);else for (const t in e) this[s][t] = e[t], this[s].setAttribute(t, e[t]);\n      return this;\n    },\n    removeAttr: function (e) {\n      for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e);\n      return this;\n    },\n    transform: function (e) {\n      for (let t = 0; t < this.length; t += 1) this[t].style.transform = e;\n      return this;\n    },\n    transition: function (e) {\n      for (let t = 0; t < this.length; t += 1) this[t].style.transitionDuration = \"string\" != typeof e ? `${e}ms` : e;\n      return this;\n    },\n    on: function () {\n      for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];\n      let [a, i, r, n] = t;\n      function l(e) {\n        const t = e.target;\n        if (!t) return;\n        const s = e.target.dom7EventData || [];\n        if (s.indexOf(e) < 0 && s.unshift(e), d(t).is(i)) r.apply(t, s);else {\n          const e = d(t).parents();\n          for (let t = 0; t < e.length; t += 1) d(e[t]).is(i) && r.apply(e[t], s);\n        }\n      }\n      function o(e) {\n        const t = e && e.target && e.target.dom7EventData || [];\n        t.indexOf(e) < 0 && t.unshift(e), r.apply(this, t);\n      }\n      \"function\" == typeof t[1] && ([a, r, n] = t, i = void 0), n || (n = !1);\n      const c = a.split(\" \");\n      let p;\n      for (let e = 0; e < this.length; e += 1) {\n        const t = this[e];\n        if (i) for (p = 0; p < c.length; p += 1) {\n          const e = c[p];\n          t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({\n            listener: r,\n            proxyListener: l\n          }), t.addEventListener(e, l, n);\n        } else for (p = 0; p < c.length; p += 1) {\n          const e = c[p];\n          t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({\n            listener: r,\n            proxyListener: o\n          }), t.addEventListener(e, o, n);\n        }\n      }\n      return this;\n    },\n    off: function () {\n      for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];\n      let [a, i, r, n] = t;\n      \"function\" == typeof t[1] && ([a, r, n] = t, i = void 0), n || (n = !1);\n      const l = a.split(\" \");\n      for (let e = 0; e < l.length; e += 1) {\n        const t = l[e];\n        for (let e = 0; e < this.length; e += 1) {\n          const s = this[e];\n          let a;\n          if (!i && s.dom7Listeners ? a = s.dom7Listeners[t] : i && s.dom7LiveListeners && (a = s.dom7LiveListeners[t]), a && a.length) for (let e = a.length - 1; e >= 0; e -= 1) {\n            const i = a[e];\n            r && i.listener === r || r && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === r ? (s.removeEventListener(t, i.proxyListener, n), a.splice(e, 1)) : r || (s.removeEventListener(t, i.proxyListener, n), a.splice(e, 1));\n          }\n        }\n      }\n      return this;\n    },\n    trigger: function () {\n      const e = r();\n      for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++) s[a] = arguments[a];\n      const i = s[0].split(\" \"),\n        n = s[1];\n      for (let t = 0; t < i.length; t += 1) {\n        const a = i[t];\n        for (let t = 0; t < this.length; t += 1) {\n          const i = this[t];\n          if (e.CustomEvent) {\n            const t = new e.CustomEvent(a, {\n              detail: n,\n              bubbles: !0,\n              cancelable: !0\n            });\n            i.dom7EventData = s.filter((e, t) => t > 0), i.dispatchEvent(t), i.dom7EventData = [], delete i.dom7EventData;\n          }\n        }\n      }\n      return this;\n    },\n    transitionEnd: function (e) {\n      const t = this;\n      return e && t.on(\"transitionend\", function s(a) {\n        a.target === this && (e.call(this, a), t.off(\"transitionend\", s));\n      }), this;\n    },\n    outerWidth: function (e) {\n      if (this.length > 0) {\n        if (e) {\n          const e = this.styles();\n          return this[0].offsetWidth + parseFloat(e.getPropertyValue(\"margin-right\")) + parseFloat(e.getPropertyValue(\"margin-left\"));\n        }\n        return this[0].offsetWidth;\n      }\n      return null;\n    },\n    outerHeight: function (e) {\n      if (this.length > 0) {\n        if (e) {\n          const e = this.styles();\n          return this[0].offsetHeight + parseFloat(e.getPropertyValue(\"margin-top\")) + parseFloat(e.getPropertyValue(\"margin-bottom\"));\n        }\n        return this[0].offsetHeight;\n      }\n      return null;\n    },\n    styles: function () {\n      const e = r();\n      return this[0] ? e.getComputedStyle(this[0], null) : {};\n    },\n    offset: function () {\n      if (this.length > 0) {\n        const e = r(),\n          t = a(),\n          s = this[0],\n          i = s.getBoundingClientRect(),\n          n = t.body,\n          l = s.clientTop || n.clientTop || 0,\n          o = s.clientLeft || n.clientLeft || 0,\n          d = s === e ? e.scrollY : s.scrollTop,\n          c = s === e ? e.scrollX : s.scrollLeft;\n        return {\n          top: i.top + d - l,\n          left: i.left + c - o\n        };\n      }\n      return null;\n    },\n    css: function (e, t) {\n      const s = r();\n      let a;\n      if (1 === arguments.length) {\n        if (\"string\" != typeof e) {\n          for (a = 0; a < this.length; a += 1) for (const t in e) this[a].style[t] = e[t];\n          return this;\n        }\n        if (this[0]) return s.getComputedStyle(this[0], null).getPropertyValue(e);\n      }\n      if (2 === arguments.length && \"string\" == typeof e) {\n        for (a = 0; a < this.length; a += 1) this[a].style[e] = t;\n        return this;\n      }\n      return this;\n    },\n    each: function (e) {\n      return e ? (this.forEach((t, s) => {\n        e.apply(t, [t, s]);\n      }), this) : this;\n    },\n    html: function (e) {\n      if (void 0 === e) return this[0] ? this[0].innerHTML : null;\n      for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e;\n      return this;\n    },\n    text: function (e) {\n      if (void 0 === e) return this[0] ? this[0].textContent.trim() : null;\n      for (let t = 0; t < this.length; t += 1) this[t].textContent = e;\n      return this;\n    },\n    is: function (e) {\n      const t = r(),\n        s = a(),\n        i = this[0];\n      let l, o;\n      if (!i || void 0 === e) return !1;\n      if (\"string\" == typeof e) {\n        if (i.matches) return i.matches(e);\n        if (i.webkitMatchesSelector) return i.webkitMatchesSelector(e);\n        if (i.msMatchesSelector) return i.msMatchesSelector(e);\n        for (l = d(e), o = 0; o < l.length; o += 1) if (l[o] === i) return !0;\n        return !1;\n      }\n      if (e === s) return i === s;\n      if (e === t) return i === t;\n      if (e.nodeType || e instanceof n) {\n        for (l = e.nodeType ? [e] : e, o = 0; o < l.length; o += 1) if (l[o] === i) return !0;\n        return !1;\n      }\n      return !1;\n    },\n    index: function () {\n      let e,\n        t = this[0];\n      if (t) {\n        for (e = 0; null !== (t = t.previousSibling);) 1 === t.nodeType && (e += 1);\n        return e;\n      }\n    },\n    eq: function (e) {\n      if (void 0 === e) return this;\n      const t = this.length;\n      if (e > t - 1) return d([]);\n      if (e < 0) {\n        const s = t + e;\n        return d(s < 0 ? [] : [this[s]]);\n      }\n      return d([this[e]]);\n    },\n    append: function () {\n      let e;\n      const t = a();\n      for (let s = 0; s < arguments.length; s += 1) {\n        e = s < 0 || arguments.length <= s ? void 0 : arguments[s];\n        for (let s = 0; s < this.length; s += 1) if (\"string\" == typeof e) {\n          const a = t.createElement(\"div\");\n          for (a.innerHTML = e; a.firstChild;) this[s].appendChild(a.firstChild);\n        } else if (e instanceof n) for (let t = 0; t < e.length; t += 1) this[s].appendChild(e[t]);else this[s].appendChild(e);\n      }\n      return this;\n    },\n    prepend: function (e) {\n      const t = a();\n      let s, i;\n      for (s = 0; s < this.length; s += 1) if (\"string\" == typeof e) {\n        const a = t.createElement(\"div\");\n        for (a.innerHTML = e, i = a.childNodes.length - 1; i >= 0; i -= 1) this[s].insertBefore(a.childNodes[i], this[s].childNodes[0]);\n      } else if (e instanceof n) for (i = 0; i < e.length; i += 1) this[s].insertBefore(e[i], this[s].childNodes[0]);else this[s].insertBefore(e, this[s].childNodes[0]);\n      return this;\n    },\n    next: function (e) {\n      return this.length > 0 ? e ? this[0].nextElementSibling && d(this[0].nextElementSibling).is(e) ? d([this[0].nextElementSibling]) : d([]) : this[0].nextElementSibling ? d([this[0].nextElementSibling]) : d([]) : d([]);\n    },\n    nextAll: function (e) {\n      const t = [];\n      let s = this[0];\n      if (!s) return d([]);\n      for (; s.nextElementSibling;) {\n        const a = s.nextElementSibling;\n        e ? d(a).is(e) && t.push(a) : t.push(a), s = a;\n      }\n      return d(t);\n    },\n    prev: function (e) {\n      if (this.length > 0) {\n        const t = this[0];\n        return e ? t.previousElementSibling && d(t.previousElementSibling).is(e) ? d([t.previousElementSibling]) : d([]) : t.previousElementSibling ? d([t.previousElementSibling]) : d([]);\n      }\n      return d([]);\n    },\n    prevAll: function (e) {\n      const t = [];\n      let s = this[0];\n      if (!s) return d([]);\n      for (; s.previousElementSibling;) {\n        const a = s.previousElementSibling;\n        e ? d(a).is(e) && t.push(a) : t.push(a), s = a;\n      }\n      return d(t);\n    },\n    parent: function (e) {\n      const t = [];\n      for (let s = 0; s < this.length; s += 1) null !== this[s].parentNode && (e ? d(this[s].parentNode).is(e) && t.push(this[s].parentNode) : t.push(this[s].parentNode));\n      return d(t);\n    },\n    parents: function (e) {\n      const t = [];\n      for (let s = 0; s < this.length; s += 1) {\n        let a = this[s].parentNode;\n        for (; a;) e ? d(a).is(e) && t.push(a) : t.push(a), a = a.parentNode;\n      }\n      return d(t);\n    },\n    closest: function (e) {\n      let t = this;\n      return void 0 === e ? d([]) : (t.is(e) || (t = t.parents(e).eq(0)), t);\n    },\n    find: function (e) {\n      const t = [];\n      for (let s = 0; s < this.length; s += 1) {\n        const a = this[s].querySelectorAll(e);\n        for (let e = 0; e < a.length; e += 1) t.push(a[e]);\n      }\n      return d(t);\n    },\n    children: function (e) {\n      const t = [];\n      for (let s = 0; s < this.length; s += 1) {\n        const a = this[s].children;\n        for (let s = 0; s < a.length; s += 1) e && !d(a[s]).is(e) || t.push(a[s]);\n      }\n      return d(t);\n    },\n    filter: function (e) {\n      return d(o(this, e));\n    },\n    remove: function () {\n      for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]);\n      return this;\n    }\n  };\n  function p(e, t) {\n    return void 0 === t && (t = 0), setTimeout(e, t);\n  }\n  function u() {\n    return Date.now();\n  }\n  function h(e, t) {\n    void 0 === t && (t = \"x\");\n    const s = r();\n    let a, i, n;\n    const l = function (e) {\n      const t = r();\n      let s;\n      return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s;\n    }(e);\n    return s.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform, i.split(\",\").length > 6 && (i = i.split(\", \").map(e => e.replace(\",\", \".\")).join(\", \")), n = new s.WebKitCSSMatrix(\"none\" === i ? \"\" : i)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\"), a = n.toString().split(\",\")), \"x\" === t && (i = s.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), \"y\" === t && (i = s.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0;\n  }\n  function m(e) {\n    return \"object\" == typeof e && null !== e && e.constructor && \"Object\" === Object.prototype.toString.call(e).slice(8, -1);\n  }\n  function f(e) {\n    return \"undefined\" != typeof window && void 0 !== window.HTMLElement ? e instanceof HTMLElement : e && (1 === e.nodeType || 11 === e.nodeType);\n  }\n  function g() {\n    const e = Object(arguments.length <= 0 ? void 0 : arguments[0]),\n      t = [\"__proto__\", \"constructor\", \"prototype\"];\n    for (let s = 1; s < arguments.length; s += 1) {\n      const a = s < 0 || arguments.length <= s ? void 0 : arguments[s];\n      if (null != a && !f(a)) {\n        const s = Object.keys(Object(a)).filter(e => t.indexOf(e) < 0);\n        for (let t = 0, i = s.length; t < i; t += 1) {\n          const i = s[t],\n            r = Object.getOwnPropertyDescriptor(a, i);\n          void 0 !== r && r.enumerable && (m(e[i]) && m(a[i]) ? a[i].__swiper__ ? e[i] = a[i] : g(e[i], a[i]) : !m(e[i]) && m(a[i]) ? (e[i] = {}, a[i].__swiper__ ? e[i] = a[i] : g(e[i], a[i])) : e[i] = a[i]);\n        }\n      }\n    }\n    return e;\n  }\n  function v(e, t, s) {\n    e.style.setProperty(t, s);\n  }\n  function w(e) {\n    let {\n      swiper: t,\n      targetPosition: s,\n      side: a\n    } = e;\n    const i = r(),\n      n = -t.translate;\n    let l,\n      o = null;\n    const d = t.params.speed;\n    t.wrapperEl.style.scrollSnapType = \"none\", i.cancelAnimationFrame(t.cssModeFrameID);\n    const c = s > n ? \"next\" : \"prev\",\n      p = (e, t) => \"next\" === c && e >= t || \"prev\" === c && e <= t,\n      u = () => {\n        l = new Date().getTime(), null === o && (o = l);\n        const e = Math.max(Math.min((l - o) / d, 1), 0),\n          r = .5 - Math.cos(e * Math.PI) / 2;\n        let c = n + r * (s - n);\n        if (p(c, s) && (c = s), t.wrapperEl.scrollTo({\n          [a]: c\n        }), p(c, s)) return t.wrapperEl.style.overflow = \"hidden\", t.wrapperEl.style.scrollSnapType = \"\", setTimeout(() => {\n          t.wrapperEl.style.overflow = \"\", t.wrapperEl.scrollTo({\n            [a]: c\n          });\n        }), void i.cancelAnimationFrame(t.cssModeFrameID);\n        t.cssModeFrameID = i.requestAnimationFrame(u);\n      };\n    u();\n  }\n  let b, x, y;\n  function E() {\n    return b || (b = function () {\n      const e = r(),\n        t = a();\n      return {\n        smoothScroll: t.documentElement && \"scrollBehavior\" in t.documentElement.style,\n        touch: !!(\"ontouchstart\" in e || e.DocumentTouch && t instanceof e.DocumentTouch),\n        passiveListener: function () {\n          let t = !1;\n          try {\n            const s = Object.defineProperty({}, \"passive\", {\n              get() {\n                t = !0;\n              }\n            });\n            e.addEventListener(\"testPassiveListener\", null, s);\n          } catch (e) {}\n          return t;\n        }(),\n        gestures: \"ongesturestart\" in e\n      };\n    }()), b;\n  }\n  function C(e) {\n    return void 0 === e && (e = {}), x || (x = function (e) {\n      let {\n        userAgent: t\n      } = void 0 === e ? {} : e;\n      const s = E(),\n        a = r(),\n        i = a.navigator.platform,\n        n = t || a.navigator.userAgent,\n        l = {\n          ios: !1,\n          android: !1\n        },\n        o = a.screen.width,\n        d = a.screen.height,\n        c = n.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n      let p = n.match(/(iPad).*OS\\s([\\d_]+)/);\n      const u = n.match(/(iPod)(.*OS\\s([\\d_]+))?/),\n        h = !p && n.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/),\n        m = \"Win32\" === i;\n      let f = \"MacIntel\" === i;\n      return !p && f && s.touch && [\"1024x1366\", \"1366x1024\", \"834x1194\", \"1194x834\", \"834x1112\", \"1112x834\", \"768x1024\", \"1024x768\", \"820x1180\", \"1180x820\", \"810x1080\", \"1080x810\"].indexOf(`${o}x${d}`) >= 0 && (p = n.match(/(Version)\\/([\\d.]+)/), p || (p = [0, 1, \"13_0_0\"]), f = !1), c && !m && (l.os = \"android\", l.android = !0), (p || h || u) && (l.os = \"ios\", l.ios = !0), l;\n    }(e)), x;\n  }\n  function T() {\n    return y || (y = function () {\n      const e = r();\n      return {\n        isSafari: function () {\n          const t = e.navigator.userAgent.toLowerCase();\n          return t.indexOf(\"safari\") >= 0 && t.indexOf(\"chrome\") < 0 && t.indexOf(\"android\") < 0;\n        }(),\n        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)\n      };\n    }()), y;\n  }\n  Object.keys(c).forEach(e => {\n    Object.defineProperty(d.fn, e, {\n      value: c[e],\n      writable: !0\n    });\n  });\n  var $ = {\n    on(e, t, s) {\n      const a = this;\n      if (!a.eventsListeners || a.destroyed) return a;\n      if (\"function\" != typeof t) return a;\n      const i = s ? \"unshift\" : \"push\";\n      return e.split(\" \").forEach(e => {\n        a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t);\n      }), a;\n    },\n    once(e, t, s) {\n      const a = this;\n      if (!a.eventsListeners || a.destroyed) return a;\n      if (\"function\" != typeof t) return a;\n      function i() {\n        a.off(e, i), i.__emitterProxy && delete i.__emitterProxy;\n        for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) r[n] = arguments[n];\n        t.apply(a, r);\n      }\n      return i.__emitterProxy = t, a.on(e, i, s);\n    },\n    onAny(e, t) {\n      const s = this;\n      if (!s.eventsListeners || s.destroyed) return s;\n      if (\"function\" != typeof e) return s;\n      const a = t ? \"unshift\" : \"push\";\n      return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e), s;\n    },\n    offAny(e) {\n      const t = this;\n      if (!t.eventsListeners || t.destroyed) return t;\n      if (!t.eventsAnyListeners) return t;\n      const s = t.eventsAnyListeners.indexOf(e);\n      return s >= 0 && t.eventsAnyListeners.splice(s, 1), t;\n    },\n    off(e, t) {\n      const s = this;\n      return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(\" \").forEach(e => {\n        void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach((a, i) => {\n          (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1);\n        });\n      }), s) : s;\n    },\n    emit() {\n      const e = this;\n      if (!e.eventsListeners || e.destroyed) return e;\n      if (!e.eventsListeners) return e;\n      let t, s, a;\n      for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++) r[n] = arguments[n];\n      \"string\" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], s = r.slice(1, r.length), a = e) : (t = r[0].events, s = r[0].data, a = r[0].context || e), s.unshift(a);\n      return (Array.isArray(t) ? t : t.split(\" \")).forEach(t => {\n        e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(e => {\n          e.apply(a, [t, ...s]);\n        }), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach(e => {\n          e.apply(a, s);\n        });\n      }), e;\n    }\n  };\n  var S = {\n    updateSize: function () {\n      const e = this;\n      let t, s;\n      const a = e.$el;\n      t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a[0].clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a[0].clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(a.css(\"padding-left\") || 0, 10) - parseInt(a.css(\"padding-right\") || 0, 10), s = s - parseInt(a.css(\"padding-top\") || 0, 10) - parseInt(a.css(\"padding-bottom\") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, {\n        width: t,\n        height: s,\n        size: e.isHorizontal() ? t : s\n      }));\n    },\n    updateSlides: function () {\n      const e = this;\n      function t(t) {\n        return e.isHorizontal() ? t : {\n          width: \"height\",\n          \"margin-top\": \"margin-left\",\n          \"margin-bottom \": \"margin-right\",\n          \"margin-left\": \"margin-top\",\n          \"margin-right\": \"margin-bottom\",\n          \"padding-left\": \"padding-top\",\n          \"padding-right\": \"padding-bottom\",\n          marginRight: \"marginBottom\"\n        }[t];\n      }\n      function s(e, s) {\n        return parseFloat(e.getPropertyValue(t(s)) || 0);\n      }\n      const a = e.params,\n        {\n          $wrapperEl: i,\n          size: r,\n          rtlTranslate: n,\n          wrongRTL: l\n        } = e,\n        o = e.virtual && a.virtual.enabled,\n        d = o ? e.virtual.slides.length : e.slides.length,\n        c = i.children(`.${e.params.slideClass}`),\n        p = o ? e.virtual.slides.length : c.length;\n      let u = [];\n      const h = [],\n        m = [];\n      let f = a.slidesOffsetBefore;\n      \"function\" == typeof f && (f = a.slidesOffsetBefore.call(e));\n      let g = a.slidesOffsetAfter;\n      \"function\" == typeof g && (g = a.slidesOffsetAfter.call(e));\n      const w = e.snapGrid.length,\n        b = e.slidesGrid.length;\n      let x = a.spaceBetween,\n        y = -f,\n        E = 0,\n        C = 0;\n      if (void 0 === r) return;\n      \"string\" == typeof x && x.indexOf(\"%\") >= 0 && (x = parseFloat(x.replace(\"%\", \"\")) / 100 * r), e.virtualSize = -x, n ? c.css({\n        marginLeft: \"\",\n        marginBottom: \"\",\n        marginTop: \"\"\n      }) : c.css({\n        marginRight: \"\",\n        marginBottom: \"\",\n        marginTop: \"\"\n      }), a.centeredSlides && a.cssMode && (v(e.wrapperEl, \"--swiper-centered-offset-before\", \"\"), v(e.wrapperEl, \"--swiper-centered-offset-after\", \"\"));\n      const T = a.grid && a.grid.rows > 1 && e.grid;\n      let $;\n      T && e.grid.initSlides(p);\n      const S = \"auto\" === a.slidesPerView && a.breakpoints && Object.keys(a.breakpoints).filter(e => void 0 !== a.breakpoints[e].slidesPerView).length > 0;\n      for (let i = 0; i < p; i += 1) {\n        $ = 0;\n        const n = c.eq(i);\n        if (T && e.grid.updateSlide(i, n, p, t), \"none\" !== n.css(\"display\")) {\n          if (\"auto\" === a.slidesPerView) {\n            S && (c[i].style[t(\"width\")] = \"\");\n            const r = getComputedStyle(n[0]),\n              l = n[0].style.transform,\n              o = n[0].style.webkitTransform;\n            if (l && (n[0].style.transform = \"none\"), o && (n[0].style.webkitTransform = \"none\"), a.roundLengths) $ = e.isHorizontal() ? n.outerWidth(!0) : n.outerHeight(!0);else {\n              const e = s(r, \"width\"),\n                t = s(r, \"padding-left\"),\n                a = s(r, \"padding-right\"),\n                i = s(r, \"margin-left\"),\n                l = s(r, \"margin-right\"),\n                o = r.getPropertyValue(\"box-sizing\");\n              if (o && \"border-box\" === o) $ = e + i + l;else {\n                const {\n                  clientWidth: s,\n                  offsetWidth: r\n                } = n[0];\n                $ = e + t + a + i + l + (r - s);\n              }\n            }\n            l && (n[0].style.transform = l), o && (n[0].style.webkitTransform = o), a.roundLengths && ($ = Math.floor($));\n          } else $ = (r - (a.slidesPerView - 1) * x) / a.slidesPerView, a.roundLengths && ($ = Math.floor($)), c[i] && (c[i].style[t(\"width\")] = `${$}px`);\n          c[i] && (c[i].swiperSlideSize = $), m.push($), a.centeredSlides ? (y = y + $ / 2 + E / 2 + x, 0 === E && 0 !== i && (y = y - r / 2 - x), 0 === i && (y = y - r / 2 - x), Math.abs(y) < .001 && (y = 0), a.roundLengths && (y = Math.floor(y)), C % a.slidesPerGroup == 0 && u.push(y), h.push(y)) : (a.roundLengths && (y = Math.floor(y)), (C - Math.min(e.params.slidesPerGroupSkip, C)) % e.params.slidesPerGroup == 0 && u.push(y), h.push(y), y = y + $ + x), e.virtualSize += $ + x, E = $, C += 1;\n        }\n      }\n      if (e.virtualSize = Math.max(e.virtualSize, r) + g, n && l && (\"slide\" === a.effect || \"coverflow\" === a.effect) && i.css({\n        width: `${e.virtualSize + a.spaceBetween}px`\n      }), a.setWrapperSize && i.css({\n        [t(\"width\")]: `${e.virtualSize + a.spaceBetween}px`\n      }), T && e.grid.updateWrapperSize($, u, t), !a.centeredSlides) {\n        const t = [];\n        for (let s = 0; s < u.length; s += 1) {\n          let i = u[s];\n          a.roundLengths && (i = Math.floor(i)), u[s] <= e.virtualSize - r && t.push(i);\n        }\n        u = t, Math.floor(e.virtualSize - r) - Math.floor(u[u.length - 1]) > 1 && u.push(e.virtualSize - r);\n      }\n      if (0 === u.length && (u = [0]), 0 !== a.spaceBetween) {\n        const s = e.isHorizontal() && n ? \"marginLeft\" : t(\"marginRight\");\n        c.filter((e, t) => !a.cssMode || t !== c.length - 1).css({\n          [s]: `${x}px`\n        });\n      }\n      if (a.centeredSlides && a.centeredSlidesBounds) {\n        let e = 0;\n        m.forEach(t => {\n          e += t + (a.spaceBetween ? a.spaceBetween : 0);\n        }), e -= a.spaceBetween;\n        const t = e - r;\n        u = u.map(e => e < 0 ? -f : e > t ? t + g : e);\n      }\n      if (a.centerInsufficientSlides) {\n        let e = 0;\n        if (m.forEach(t => {\n          e += t + (a.spaceBetween ? a.spaceBetween : 0);\n        }), e -= a.spaceBetween, e < r) {\n          const t = (r - e) / 2;\n          u.forEach((e, s) => {\n            u[s] = e - t;\n          }), h.forEach((e, s) => {\n            h[s] = e + t;\n          });\n        }\n      }\n      if (Object.assign(e, {\n        slides: c,\n        snapGrid: u,\n        slidesGrid: h,\n        slidesSizesGrid: m\n      }), a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) {\n        v(e.wrapperEl, \"--swiper-centered-offset-before\", -u[0] + \"px\"), v(e.wrapperEl, \"--swiper-centered-offset-after\", e.size / 2 - m[m.length - 1] / 2 + \"px\");\n        const t = -e.snapGrid[0],\n          s = -e.slidesGrid[0];\n        e.snapGrid = e.snapGrid.map(e => e + t), e.slidesGrid = e.slidesGrid.map(e => e + s);\n      }\n      if (p !== d && e.emit(\"slidesLengthChange\"), u.length !== w && (e.params.watchOverflow && e.checkOverflow(), e.emit(\"snapGridLengthChange\")), h.length !== b && e.emit(\"slidesGridLengthChange\"), a.watchSlidesProgress && e.updateSlidesOffset(), !(o || a.cssMode || \"slide\" !== a.effect && \"fade\" !== a.effect)) {\n        const t = `${a.containerModifierClass}backface-hidden`,\n          s = e.$el.hasClass(t);\n        p <= a.maxBackfaceHiddenSlides ? s || e.$el.addClass(t) : s && e.$el.removeClass(t);\n      }\n    },\n    updateAutoHeight: function (e) {\n      const t = this,\n        s = [],\n        a = t.virtual && t.params.virtual.enabled;\n      let i,\n        r = 0;\n      \"number\" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);\n      const n = e => a ? t.slides.filter(t => parseInt(t.getAttribute(\"data-swiper-slide-index\"), 10) === e)[0] : t.slides.eq(e)[0];\n      if (\"auto\" !== t.params.slidesPerView && t.params.slidesPerView > 1) {\n        if (t.params.centeredSlides) (t.visibleSlides || d([])).each(e => {\n          s.push(e);\n        });else for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) {\n          const e = t.activeIndex + i;\n          if (e > t.slides.length && !a) break;\n          s.push(n(e));\n        }\n      } else s.push(n(t.activeIndex));\n      for (i = 0; i < s.length; i += 1) if (void 0 !== s[i]) {\n        const e = s[i].offsetHeight;\n        r = e > r ? e : r;\n      }\n      (r || 0 === r) && t.$wrapperEl.css(\"height\", `${r}px`);\n    },\n    updateSlidesOffset: function () {\n      const e = this,\n        t = e.slides;\n      for (let s = 0; s < t.length; s += 1) t[s].swiperSlideOffset = e.isHorizontal() ? t[s].offsetLeft : t[s].offsetTop;\n    },\n    updateSlidesProgress: function (e) {\n      void 0 === e && (e = this && this.translate || 0);\n      const t = this,\n        s = t.params,\n        {\n          slides: a,\n          rtlTranslate: i,\n          snapGrid: r\n        } = t;\n      if (0 === a.length) return;\n      void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset();\n      let n = -e;\n      i && (n = e), a.removeClass(s.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = [];\n      for (let e = 0; e < a.length; e += 1) {\n        const l = a[e];\n        let o = l.swiperSlideOffset;\n        s.cssMode && s.centeredSlides && (o -= a[0].swiperSlideOffset);\n        const d = (n + (s.centeredSlides ? t.minTranslate() : 0) - o) / (l.swiperSlideSize + s.spaceBetween),\n          c = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - o) / (l.swiperSlideSize + s.spaceBetween),\n          p = -(n - o),\n          u = p + t.slidesSizesGrid[e];\n        (p >= 0 && p < t.size - 1 || u > 1 && u <= t.size || p <= 0 && u >= t.size) && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e), a.eq(e).addClass(s.slideVisibleClass)), l.progress = i ? -d : d, l.originalProgress = i ? -c : c;\n      }\n      t.visibleSlides = d(t.visibleSlides);\n    },\n    updateProgress: function (e) {\n      const t = this;\n      if (void 0 === e) {\n        const s = t.rtlTranslate ? -1 : 1;\n        e = t && t.translate && t.translate * s || 0;\n      }\n      const s = t.params,\n        a = t.maxTranslate() - t.minTranslate();\n      let {\n        progress: i,\n        isBeginning: r,\n        isEnd: n\n      } = t;\n      const l = r,\n        o = n;\n      0 === a ? (i = 0, r = !0, n = !0) : (i = (e - t.minTranslate()) / a, r = i <= 0, n = i >= 1), Object.assign(t, {\n        progress: i,\n        isBeginning: r,\n        isEnd: n\n      }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !l && t.emit(\"reachBeginning toEdge\"), n && !o && t.emit(\"reachEnd toEdge\"), (l && !r || o && !n) && t.emit(\"fromEdge\"), t.emit(\"progress\", i);\n    },\n    updateSlidesClasses: function () {\n      const e = this,\n        {\n          slides: t,\n          params: s,\n          $wrapperEl: a,\n          activeIndex: i,\n          realIndex: r\n        } = e,\n        n = e.virtual && s.virtual.enabled;\n      let l;\n      t.removeClass(`${s.slideActiveClass} ${s.slideNextClass} ${s.slidePrevClass} ${s.slideDuplicateActiveClass} ${s.slideDuplicateNextClass} ${s.slideDuplicatePrevClass}`), l = n ? e.$wrapperEl.find(`.${s.slideClass}[data-swiper-slide-index=\"${i}\"]`) : t.eq(i), l.addClass(s.slideActiveClass), s.loop && (l.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index=\"${r}\"]`).addClass(s.slideDuplicateActiveClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index=\"${r}\"]`).addClass(s.slideDuplicateActiveClass));\n      let o = l.nextAll(`.${s.slideClass}`).eq(0).addClass(s.slideNextClass);\n      s.loop && 0 === o.length && (o = t.eq(0), o.addClass(s.slideNextClass));\n      let d = l.prevAll(`.${s.slideClass}`).eq(0).addClass(s.slidePrevClass);\n      s.loop && 0 === d.length && (d = t.eq(-1), d.addClass(s.slidePrevClass)), s.loop && (o.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index=\"${o.attr(\"data-swiper-slide-index\")}\"]`).addClass(s.slideDuplicateNextClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index=\"${o.attr(\"data-swiper-slide-index\")}\"]`).addClass(s.slideDuplicateNextClass), d.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index=\"${d.attr(\"data-swiper-slide-index\")}\"]`).addClass(s.slideDuplicatePrevClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index=\"${d.attr(\"data-swiper-slide-index\")}\"]`).addClass(s.slideDuplicatePrevClass)), e.emitSlidesClasses();\n    },\n    updateActiveIndex: function (e) {\n      const t = this,\n        s = t.rtlTranslate ? t.translate : -t.translate,\n        {\n          slidesGrid: a,\n          snapGrid: i,\n          params: r,\n          activeIndex: n,\n          realIndex: l,\n          snapIndex: o\n        } = t;\n      let d,\n        c = e;\n      if (void 0 === c) {\n        for (let e = 0; e < a.length; e += 1) void 0 !== a[e + 1] ? s >= a[e] && s < a[e + 1] - (a[e + 1] - a[e]) / 2 ? c = e : s >= a[e] && s < a[e + 1] && (c = e + 1) : s >= a[e] && (c = e);\n        r.normalizeSlideIndex && (c < 0 || void 0 === c) && (c = 0);\n      }\n      if (i.indexOf(s) >= 0) d = i.indexOf(s);else {\n        const e = Math.min(r.slidesPerGroupSkip, c);\n        d = e + Math.floor((c - e) / r.slidesPerGroup);\n      }\n      if (d >= i.length && (d = i.length - 1), c === n) return void (d !== o && (t.snapIndex = d, t.emit(\"snapIndexChange\")));\n      const p = parseInt(t.slides.eq(c).attr(\"data-swiper-slide-index\") || c, 10);\n      Object.assign(t, {\n        snapIndex: d,\n        realIndex: p,\n        previousIndex: n,\n        activeIndex: c\n      }), t.emit(\"activeIndexChange\"), t.emit(\"snapIndexChange\"), l !== p && t.emit(\"realIndexChange\"), (t.initialized || t.params.runCallbacksOnInit) && t.emit(\"slideChange\");\n    },\n    updateClickedSlide: function (e) {\n      const t = this,\n        s = t.params,\n        a = d(e).closest(`.${s.slideClass}`)[0];\n      let i,\n        r = !1;\n      if (a) for (let e = 0; e < t.slides.length; e += 1) if (t.slides[e] === a) {\n        r = !0, i = e;\n        break;\n      }\n      if (!a || !r) return t.clickedSlide = void 0, void (t.clickedIndex = void 0);\n      t.clickedSlide = a, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(d(a).attr(\"data-swiper-slide-index\"), 10) : t.clickedIndex = i, s.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide();\n    }\n  };\n  var M = {\n    getTranslate: function (e) {\n      void 0 === e && (e = this.isHorizontal() ? \"x\" : \"y\");\n      const {\n        params: t,\n        rtlTranslate: s,\n        translate: a,\n        $wrapperEl: i\n      } = this;\n      if (t.virtualTranslate) return s ? -a : a;\n      if (t.cssMode) return a;\n      let r = h(i[0], e);\n      return s && (r = -r), r || 0;\n    },\n    setTranslate: function (e, t) {\n      const s = this,\n        {\n          rtlTranslate: a,\n          params: i,\n          $wrapperEl: r,\n          wrapperEl: n,\n          progress: l\n        } = s;\n      let o,\n        d = 0,\n        c = 0;\n      s.isHorizontal() ? d = a ? -e : e : c = e, i.roundLengths && (d = Math.floor(d), c = Math.floor(c)), i.cssMode ? n[s.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = s.isHorizontal() ? -d : -c : i.virtualTranslate || r.transform(`translate3d(${d}px, ${c}px, 0px)`), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? d : c;\n      const p = s.maxTranslate() - s.minTranslate();\n      o = 0 === p ? 0 : (e - s.minTranslate()) / p, o !== l && s.updateProgress(e), s.emit(\"setTranslate\", s.translate, t);\n    },\n    minTranslate: function () {\n      return -this.snapGrid[0];\n    },\n    maxTranslate: function () {\n      return -this.snapGrid[this.snapGrid.length - 1];\n    },\n    translateTo: function (e, t, s, a, i) {\n      void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), void 0 === a && (a = !0);\n      const r = this,\n        {\n          params: n,\n          wrapperEl: l\n        } = r;\n      if (r.animating && n.preventInteractionOnTransition) return !1;\n      const o = r.minTranslate(),\n        d = r.maxTranslate();\n      let c;\n      if (c = a && e > o ? o : a && e < d ? d : e, r.updateProgress(c), n.cssMode) {\n        const e = r.isHorizontal();\n        if (0 === t) l[e ? \"scrollLeft\" : \"scrollTop\"] = -c;else {\n          if (!r.support.smoothScroll) return w({\n            swiper: r,\n            targetPosition: -c,\n            side: e ? \"left\" : \"top\"\n          }), !0;\n          l.scrollTo({\n            [e ? \"left\" : \"top\"]: -c,\n            behavior: \"smooth\"\n          });\n        }\n        return !0;\n      }\n      return 0 === t ? (r.setTransition(0), r.setTranslate(c), s && (r.emit(\"beforeTransitionStart\", t, i), r.emit(\"transitionEnd\"))) : (r.setTransition(t), r.setTranslate(c), s && (r.emit(\"beforeTransitionStart\", t, i), r.emit(\"transitionStart\")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) {\n        r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener(\"transitionend\", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener(\"webkitTransitionEnd\", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, s && r.emit(\"transitionEnd\"));\n      }), r.$wrapperEl[0].addEventListener(\"transitionend\", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener(\"webkitTransitionEnd\", r.onTranslateToWrapperTransitionEnd))), !0;\n    }\n  };\n  function P(e) {\n    let {\n      swiper: t,\n      runCallbacks: s,\n      direction: a,\n      step: i\n    } = e;\n    const {\n      activeIndex: r,\n      previousIndex: n\n    } = t;\n    let l = a;\n    if (l || (l = r > n ? \"next\" : r < n ? \"prev\" : \"reset\"), t.emit(`transition${i}`), s && r !== n) {\n      if (\"reset\" === l) return void t.emit(`slideResetTransition${i}`);\n      t.emit(`slideChangeTransition${i}`), \"next\" === l ? t.emit(`slideNextTransition${i}`) : t.emit(`slidePrevTransition${i}`);\n    }\n  }\n  var k = {\n    slideTo: function (e, t, s, a, i) {\n      if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), \"number\" != typeof e && \"string\" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`);\n      if (\"string\" == typeof e) {\n        const t = parseInt(e, 10);\n        if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);\n        e = t;\n      }\n      const r = this;\n      let n = e;\n      n < 0 && (n = 0);\n      const {\n        params: l,\n        snapGrid: o,\n        slidesGrid: d,\n        previousIndex: c,\n        activeIndex: p,\n        rtlTranslate: u,\n        wrapperEl: h,\n        enabled: m\n      } = r;\n      if (r.animating && l.preventInteractionOnTransition || !m && !a && !i) return !1;\n      const f = Math.min(r.params.slidesPerGroupSkip, n);\n      let g = f + Math.floor((n - f) / r.params.slidesPerGroup);\n      g >= o.length && (g = o.length - 1);\n      const v = -o[g];\n      if (l.normalizeSlideIndex) for (let e = 0; e < d.length; e += 1) {\n        const t = -Math.floor(100 * v),\n          s = Math.floor(100 * d[e]),\n          a = Math.floor(100 * d[e + 1]);\n        void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e);\n      }\n      if (r.initialized && n !== p) {\n        if (!r.allowSlideNext && v < r.translate && v < r.minTranslate()) return !1;\n        if (!r.allowSlidePrev && v > r.translate && v > r.maxTranslate() && (p || 0) !== n) return !1;\n      }\n      let b;\n      if (n !== (c || 0) && s && r.emit(\"beforeSlideChangeStart\"), r.updateProgress(v), b = n > p ? \"next\" : n < p ? \"prev\" : \"reset\", u && -v === r.translate || !u && v === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), \"slide\" !== l.effect && r.setTranslate(v), \"reset\" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1;\n      if (l.cssMode) {\n        const e = r.isHorizontal(),\n          s = u ? v : -v;\n        if (0 === t) {\n          const t = r.virtual && r.params.virtual.enabled;\n          t && (r.wrapperEl.style.scrollSnapType = \"none\", r._immediateVirtual = !0), h[e ? \"scrollLeft\" : \"scrollTop\"] = s, t && requestAnimationFrame(() => {\n            r.wrapperEl.style.scrollSnapType = \"\", r._swiperImmediateVirtual = !1;\n          });\n        } else {\n          if (!r.support.smoothScroll) return w({\n            swiper: r,\n            targetPosition: s,\n            side: e ? \"left\" : \"top\"\n          }), !0;\n          h.scrollTo({\n            [e ? \"left\" : \"top\"]: s,\n            behavior: \"smooth\"\n          });\n        }\n        return !0;\n      }\n      return r.setTransition(t), r.setTranslate(v), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit(\"beforeTransitionStart\", t, a), r.transitionStart(s, b), 0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) {\n        r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener(\"transitionend\", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener(\"webkitTransitionEnd\", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b));\n      }), r.$wrapperEl[0].addEventListener(\"transitionend\", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener(\"webkitTransitionEnd\", r.onSlideToWrapperTransitionEnd)), !0;\n    },\n    slideToLoop: function (e, t, s, a) {\n      if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), \"string\" == typeof e) {\n        const t = parseInt(e, 10);\n        if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);\n        e = t;\n      }\n      const i = this;\n      let r = e;\n      return i.params.loop && (r += i.loopedSlides), i.slideTo(r, t, s, a);\n    },\n    slideNext: function (e, t, s) {\n      void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);\n      const a = this,\n        {\n          animating: i,\n          enabled: r,\n          params: n\n        } = a;\n      if (!r) return a;\n      let l = n.slidesPerGroup;\n      \"auto\" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (l = Math.max(a.slidesPerViewDynamic(\"current\", !0), 1));\n      const o = a.activeIndex < n.slidesPerGroupSkip ? 1 : l;\n      if (n.loop) {\n        if (i && n.loopPreventsSlide) return !1;\n        a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft;\n      }\n      return n.rewind && a.isEnd ? a.slideTo(0, e, t, s) : a.slideTo(a.activeIndex + o, e, t, s);\n    },\n    slidePrev: function (e, t, s) {\n      void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);\n      const a = this,\n        {\n          params: i,\n          animating: r,\n          snapGrid: n,\n          slidesGrid: l,\n          rtlTranslate: o,\n          enabled: d\n        } = a;\n      if (!d) return a;\n      if (i.loop) {\n        if (r && i.loopPreventsSlide) return !1;\n        a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft;\n      }\n      function c(e) {\n        return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e);\n      }\n      const p = c(o ? a.translate : -a.translate),\n        u = n.map(e => c(e));\n      let h = n[u.indexOf(p) - 1];\n      if (void 0 === h && i.cssMode) {\n        let e;\n        n.forEach((t, s) => {\n          p >= t && (e = s);\n        }), void 0 !== e && (h = n[e > 0 ? e - 1 : e]);\n      }\n      let m = 0;\n      if (void 0 !== h && (m = l.indexOf(h), m < 0 && (m = a.activeIndex - 1), \"auto\" === i.slidesPerView && 1 === i.slidesPerGroup && i.slidesPerGroupAuto && (m = m - a.slidesPerViewDynamic(\"previous\", !0) + 1, m = Math.max(m, 0))), i.rewind && a.isBeginning) {\n        const i = a.params.virtual && a.params.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1;\n        return a.slideTo(i, e, t, s);\n      }\n      return a.slideTo(m, e, t, s);\n    },\n    slideReset: function (e, t, s) {\n      return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, s);\n    },\n    slideToClosest: function (e, t, s, a) {\n      void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === a && (a = .5);\n      const i = this;\n      let r = i.activeIndex;\n      const n = Math.min(i.params.slidesPerGroupSkip, r),\n        l = n + Math.floor((r - n) / i.params.slidesPerGroup),\n        o = i.rtlTranslate ? i.translate : -i.translate;\n      if (o >= i.snapGrid[l]) {\n        const e = i.snapGrid[l];\n        o - e > (i.snapGrid[l + 1] - e) * a && (r += i.params.slidesPerGroup);\n      } else {\n        const e = i.snapGrid[l - 1];\n        o - e <= (i.snapGrid[l] - e) * a && (r -= i.params.slidesPerGroup);\n      }\n      return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, t, s);\n    },\n    slideToClickedSlide: function () {\n      const e = this,\n        {\n          params: t,\n          $wrapperEl: s\n        } = e,\n        a = \"auto\" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;\n      let i,\n        r = e.clickedIndex;\n      if (t.loop) {\n        if (e.animating) return;\n        i = parseInt(d(e.clickedSlide).attr(\"data-swiper-slide-index\"), 10), t.centeredSlides ? r < e.loopedSlides - a / 2 || r > e.slides.length - e.loopedSlides + a / 2 ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index=\"${i}\"]:not(.${t.slideDuplicateClass})`).eq(0).index(), p(() => {\n          e.slideTo(r);\n        })) : e.slideTo(r) : r > e.slides.length - a ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index=\"${i}\"]:not(.${t.slideDuplicateClass})`).eq(0).index(), p(() => {\n          e.slideTo(r);\n        })) : e.slideTo(r);\n      } else e.slideTo(r);\n    }\n  };\n  var z = {\n    loopCreate: function () {\n      const e = this,\n        t = a(),\n        {\n          params: s,\n          $wrapperEl: i\n        } = e,\n        r = i.children().length > 0 ? d(i.children()[0].parentNode) : i;\n      r.children(`.${s.slideClass}.${s.slideDuplicateClass}`).remove();\n      let n = r.children(`.${s.slideClass}`);\n      if (s.loopFillGroupWithBlank) {\n        const e = s.slidesPerGroup - n.length % s.slidesPerGroup;\n        if (e !== s.slidesPerGroup) {\n          for (let a = 0; a < e; a += 1) {\n            const e = d(t.createElement(\"div\")).addClass(`${s.slideClass} ${s.slideBlankClass}`);\n            r.append(e);\n          }\n          n = r.children(`.${s.slideClass}`);\n        }\n      }\n      \"auto\" !== s.slidesPerView || s.loopedSlides || (s.loopedSlides = n.length), e.loopedSlides = Math.ceil(parseFloat(s.loopedSlides || s.slidesPerView, 10)), e.loopedSlides += s.loopAdditionalSlides, e.loopedSlides > n.length && e.params.loopedSlidesLimit && (e.loopedSlides = n.length);\n      const l = [],\n        o = [];\n      n.each((e, t) => {\n        d(e).attr(\"data-swiper-slide-index\", t);\n      });\n      for (let t = 0; t < e.loopedSlides; t += 1) {\n        const e = t - Math.floor(t / n.length) * n.length;\n        o.push(n.eq(e)[0]), l.unshift(n.eq(n.length - e - 1)[0]);\n      }\n      for (let e = 0; e < o.length; e += 1) r.append(d(o[e].cloneNode(!0)).addClass(s.slideDuplicateClass));\n      for (let e = l.length - 1; e >= 0; e -= 1) r.prepend(d(l[e].cloneNode(!0)).addClass(s.slideDuplicateClass));\n    },\n    loopFix: function () {\n      const e = this;\n      e.emit(\"beforeLoopFix\");\n      const {\n        activeIndex: t,\n        slides: s,\n        loopedSlides: a,\n        allowSlidePrev: i,\n        allowSlideNext: r,\n        snapGrid: n,\n        rtlTranslate: l\n      } = e;\n      let o;\n      e.allowSlidePrev = !0, e.allowSlideNext = !0;\n      const d = -n[t] - e.getTranslate();\n      if (t < a) {\n        o = s.length - 3 * a + t, o += a;\n        e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d);\n      } else if (t >= s.length - a) {\n        o = -s.length + t + a, o += a;\n        e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d);\n      }\n      e.allowSlidePrev = i, e.allowSlideNext = r, e.emit(\"loopFix\");\n    },\n    loopDestroy: function () {\n      const {\n        $wrapperEl: e,\n        params: t,\n        slides: s\n      } = this;\n      e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), s.removeAttr(\"data-swiper-slide-index\");\n    }\n  };\n  function L(e) {\n    const t = this,\n      s = a(),\n      i = r(),\n      n = t.touchEventsData,\n      {\n        params: l,\n        touches: o,\n        enabled: c\n      } = t;\n    if (!c) return;\n    if (t.animating && l.preventInteractionOnTransition) return;\n    !t.animating && l.cssMode && l.loop && t.loopFix();\n    let p = e;\n    p.originalEvent && (p = p.originalEvent);\n    let h = d(p.target);\n    if (\"wrapper\" === l.touchEventsTarget && !h.closest(t.wrapperEl).length) return;\n    if (n.isTouchEvent = \"touchstart\" === p.type, !n.isTouchEvent && \"which\" in p && 3 === p.which) return;\n    if (!n.isTouchEvent && \"button\" in p && p.button > 0) return;\n    if (n.isTouched && n.isMoved) return;\n    const m = !!l.noSwipingClass && \"\" !== l.noSwipingClass,\n      f = e.composedPath ? e.composedPath() : e.path;\n    m && p.target && p.target.shadowRoot && f && (h = d(f[0]));\n    const g = l.noSwipingSelector ? l.noSwipingSelector : `.${l.noSwipingClass}`,\n      v = !(!p.target || !p.target.shadowRoot);\n    if (l.noSwiping && (v ? function (e, t) {\n      return void 0 === t && (t = this), function t(s) {\n        if (!s || s === a() || s === r()) return null;\n        s.assignedSlot && (s = s.assignedSlot);\n        const i = s.closest(e);\n        return i || s.getRootNode ? i || t(s.getRootNode().host) : null;\n      }(t);\n    }(g, h[0]) : h.closest(g)[0])) return void (t.allowClick = !0);\n    if (l.swipeHandler && !h.closest(l.swipeHandler)[0]) return;\n    o.currentX = \"touchstart\" === p.type ? p.targetTouches[0].pageX : p.pageX, o.currentY = \"touchstart\" === p.type ? p.targetTouches[0].pageY : p.pageY;\n    const w = o.currentX,\n      b = o.currentY,\n      x = l.edgeSwipeDetection || l.iOSEdgeSwipeDetection,\n      y = l.edgeSwipeThreshold || l.iOSEdgeSwipeThreshold;\n    if (x && (w <= y || w >= i.innerWidth - y)) {\n      if (\"prevent\" !== x) return;\n      e.preventDefault();\n    }\n    if (Object.assign(n, {\n      isTouched: !0,\n      isMoved: !1,\n      allowTouchCallbacks: !0,\n      isScrolling: void 0,\n      startMoving: void 0\n    }), o.startX = w, o.startY = b, n.touchStartTime = u(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, l.threshold > 0 && (n.allowThresholdMove = !1), \"touchstart\" !== p.type) {\n      let e = !0;\n      h.is(n.focusableElements) && (e = !1, \"SELECT\" === h[0].nodeName && (n.isTouched = !1)), s.activeElement && d(s.activeElement).is(n.focusableElements) && s.activeElement !== h[0] && s.activeElement.blur();\n      const a = e && t.allowTouchMove && l.touchStartPreventDefault;\n      !l.touchStartForcePreventDefault && !a || h[0].isContentEditable || p.preventDefault();\n    }\n    t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !l.cssMode && t.freeMode.onTouchStart(), t.emit(\"touchStart\", p);\n  }\n  function O(e) {\n    const t = a(),\n      s = this,\n      i = s.touchEventsData,\n      {\n        params: r,\n        touches: n,\n        rtlTranslate: l,\n        enabled: o\n      } = s;\n    if (!o) return;\n    let c = e;\n    if (c.originalEvent && (c = c.originalEvent), !i.isTouched) return void (i.startMoving && i.isScrolling && s.emit(\"touchMoveOpposite\", c));\n    if (i.isTouchEvent && \"touchmove\" !== c.type) return;\n    const p = \"touchmove\" === c.type && c.targetTouches && (c.targetTouches[0] || c.changedTouches[0]),\n      h = \"touchmove\" === c.type ? p.pageX : c.pageX,\n      m = \"touchmove\" === c.type ? p.pageY : c.pageY;\n    if (c.preventedByNestedSwiper) return n.startX = h, void (n.startY = m);\n    if (!s.allowTouchMove) return d(c.target).is(i.focusableElements) || (s.allowClick = !1), void (i.isTouched && (Object.assign(n, {\n      startX: h,\n      startY: m,\n      currentX: h,\n      currentY: m\n    }), i.touchStartTime = u()));\n    if (i.isTouchEvent && r.touchReleaseOnEdges && !r.loop) if (s.isVertical()) {\n      if (m < n.startY && s.translate <= s.maxTranslate() || m > n.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1);\n    } else if (h < n.startX && s.translate <= s.maxTranslate() || h > n.startX && s.translate >= s.minTranslate()) return;\n    if (i.isTouchEvent && t.activeElement && c.target === t.activeElement && d(c.target).is(i.focusableElements)) return i.isMoved = !0, void (s.allowClick = !1);\n    if (i.allowTouchCallbacks && s.emit(\"touchMove\", c), c.targetTouches && c.targetTouches.length > 1) return;\n    n.currentX = h, n.currentY = m;\n    const f = n.currentX - n.startX,\n      g = n.currentY - n.startY;\n    if (s.params.threshold && Math.sqrt(f ** 2 + g ** 2) < s.params.threshold) return;\n    if (void 0 === i.isScrolling) {\n      let e;\n      s.isHorizontal() && n.currentY === n.startY || s.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : f * f + g * g >= 25 && (e = 180 * Math.atan2(Math.abs(g), Math.abs(f)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle);\n    }\n    if (i.isScrolling && s.emit(\"touchMoveOpposite\", c), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling) return void (i.isTouched = !1);\n    if (!i.startMoving) return;\n    s.allowClick = !1, !r.cssMode && c.cancelable && c.preventDefault(), r.touchMoveStopPropagation && !r.nested && c.stopPropagation(), i.isMoved || (r.loop && !r.cssMode && s.loopFix(), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating && s.$wrapperEl.trigger(\"webkitTransitionEnd transitionend\"), i.allowMomentumBounce = !1, !r.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit(\"sliderFirstMove\", c)), s.emit(\"sliderMove\", c), i.isMoved = !0;\n    let v = s.isHorizontal() ? f : g;\n    n.diff = v, v *= r.touchRatio, l && (v = -v), s.swipeDirection = v > 0 ? \"prev\" : \"next\", i.currentTranslate = v + i.startTranslate;\n    let w = !0,\n      b = r.resistanceRatio;\n    if (r.touchReleaseOnEdges && (b = 0), v > 0 && i.currentTranslate > s.minTranslate() ? (w = !1, r.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + v) ** b)) : v < 0 && i.currentTranslate < s.maxTranslate() && (w = !1, r.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - v) ** b)), w && (c.preventedByNestedSwiper = !0), !s.allowSlideNext && \"next\" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && \"prev\" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) {\n      if (!(Math.abs(v) > r.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate);\n      if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void (n.diff = s.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY);\n    }\n    r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && s.freeMode || r.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), s.params.freeMode && r.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate));\n  }\n  function I(e) {\n    const t = this,\n      s = t.touchEventsData,\n      {\n        params: a,\n        touches: i,\n        rtlTranslate: r,\n        slidesGrid: n,\n        enabled: l\n      } = t;\n    if (!l) return;\n    let o = e;\n    if (o.originalEvent && (o = o.originalEvent), s.allowTouchCallbacks && t.emit(\"touchEnd\", o), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && a.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void (s.startMoving = !1);\n    a.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);\n    const d = u(),\n      c = d - s.touchStartTime;\n    if (t.allowClick) {\n      const e = o.path || o.composedPath && o.composedPath();\n      t.updateClickedSlide(e && e[0] || o.target), t.emit(\"tap click\", o), c < 300 && d - s.lastClickTime < 300 && t.emit(\"doubleTap doubleClick\", o);\n    }\n    if (s.lastClickTime = u(), p(() => {\n      t.destroyed || (t.allowClick = !0);\n    }), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === i.diff || s.currentTranslate === s.startTranslate) return s.isTouched = !1, s.isMoved = !1, void (s.startMoving = !1);\n    let h;\n    if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = a.followFinger ? r ? t.translate : -t.translate : -s.currentTranslate, a.cssMode) return;\n    if (t.params.freeMode && a.freeMode.enabled) return void t.freeMode.onTouchEnd({\n      currentPos: h\n    });\n    let m = 0,\n      f = t.slidesSizesGrid[0];\n    for (let e = 0; e < n.length; e += e < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) {\n      const t = e < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;\n      void 0 !== n[e + t] ? h >= n[e] && h < n[e + t] && (m = e, f = n[e + t] - n[e]) : h >= n[e] && (m = e, f = n[n.length - 1] - n[n.length - 2]);\n    }\n    let g = null,\n      v = null;\n    a.rewind && (t.isBeginning ? v = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (g = 0));\n    const w = (h - n[m]) / f,\n      b = m < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;\n    if (c > a.longSwipesMs) {\n      if (!a.longSwipes) return void t.slideTo(t.activeIndex);\n      \"next\" === t.swipeDirection && (w >= a.longSwipesRatio ? t.slideTo(a.rewind && t.isEnd ? g : m + b) : t.slideTo(m)), \"prev\" === t.swipeDirection && (w > 1 - a.longSwipesRatio ? t.slideTo(m + b) : null !== v && w < 0 && Math.abs(w) > a.longSwipesRatio ? t.slideTo(v) : t.slideTo(m));\n    } else {\n      if (!a.shortSwipes) return void t.slideTo(t.activeIndex);\n      t.navigation && (o.target === t.navigation.nextEl || o.target === t.navigation.prevEl) ? o.target === t.navigation.nextEl ? t.slideTo(m + b) : t.slideTo(m) : (\"next\" === t.swipeDirection && t.slideTo(null !== g ? g : m + b), \"prev\" === t.swipeDirection && t.slideTo(null !== v ? v : m));\n    }\n  }\n  function A() {\n    const e = this,\n      {\n        params: t,\n        el: s\n      } = e;\n    if (s && 0 === s.offsetWidth) return;\n    t.breakpoints && e.setBreakpoint();\n    const {\n      allowSlideNext: a,\n      allowSlidePrev: i,\n      snapGrid: r\n    } = e;\n    e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), (\"auto\" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow();\n  }\n  function D(e) {\n    const t = this;\n    t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())));\n  }\n  function G() {\n    const e = this,\n      {\n        wrapperEl: t,\n        rtlTranslate: s,\n        enabled: a\n      } = e;\n    if (!a) return;\n    let i;\n    e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();\n    const r = e.maxTranslate() - e.minTranslate();\n    i = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, i !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit(\"setTranslate\", e.translate, !1);\n  }\n  let N = !1;\n  function B() {}\n  const H = (e, t) => {\n    const s = a(),\n      {\n        params: i,\n        touchEvents: r,\n        el: n,\n        wrapperEl: l,\n        device: o,\n        support: d\n      } = e,\n      c = !!i.nested,\n      p = \"on\" === t ? \"addEventListener\" : \"removeEventListener\",\n      u = t;\n    if (d.touch) {\n      const t = !(\"touchstart\" !== r.start || !d.passiveListener || !i.passiveListeners) && {\n        passive: !0,\n        capture: !1\n      };\n      n[p](r.start, e.onTouchStart, t), n[p](r.move, e.onTouchMove, d.passiveListener ? {\n        passive: !1,\n        capture: c\n      } : c), n[p](r.end, e.onTouchEnd, t), r.cancel && n[p](r.cancel, e.onTouchEnd, t);\n    } else n[p](r.start, e.onTouchStart, !1), s[p](r.move, e.onTouchMove, c), s[p](r.end, e.onTouchEnd, !1);\n    (i.preventClicks || i.preventClicksPropagation) && n[p](\"click\", e.onClick, !0), i.cssMode && l[p](\"scroll\", e.onScroll), i.updateOnWindowResize ? e[u](o.ios || o.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", A, !0) : e[u](\"observerUpdate\", A, !0);\n  };\n  var X = {\n    attachEvents: function () {\n      const e = this,\n        t = a(),\n        {\n          params: s,\n          support: i\n        } = e;\n      e.onTouchStart = L.bind(e), e.onTouchMove = O.bind(e), e.onTouchEnd = I.bind(e), s.cssMode && (e.onScroll = G.bind(e)), e.onClick = D.bind(e), i.touch && !N && (t.addEventListener(\"touchstart\", B), N = !0), H(e, \"on\");\n    },\n    detachEvents: function () {\n      H(this, \"off\");\n    }\n  };\n  const Y = (e, t) => e.grid && t.grid && t.grid.rows > 1;\n  var R = {\n    addClasses: function () {\n      const e = this,\n        {\n          classNames: t,\n          params: s,\n          rtl: a,\n          $el: i,\n          device: r,\n          support: n\n        } = e,\n        l = function (e, t) {\n          const s = [];\n          return e.forEach(e => {\n            \"object\" == typeof e ? Object.keys(e).forEach(a => {\n              e[a] && s.push(t + a);\n            }) : \"string\" == typeof e && s.push(t + e);\n          }), s;\n        }([\"initialized\", s.direction, {\n          \"pointer-events\": !n.touch\n        }, {\n          \"free-mode\": e.params.freeMode && s.freeMode.enabled\n        }, {\n          autoheight: s.autoHeight\n        }, {\n          rtl: a\n        }, {\n          grid: s.grid && s.grid.rows > 1\n        }, {\n          \"grid-column\": s.grid && s.grid.rows > 1 && \"column\" === s.grid.fill\n        }, {\n          android: r.android\n        }, {\n          ios: r.ios\n        }, {\n          \"css-mode\": s.cssMode\n        }, {\n          centered: s.cssMode && s.centeredSlides\n        }, {\n          \"watch-progress\": s.watchSlidesProgress\n        }], s.containerModifierClass);\n      t.push(...l), i.addClass([...t].join(\" \")), e.emitContainerClasses();\n    },\n    removeClasses: function () {\n      const {\n        $el: e,\n        classNames: t\n      } = this;\n      e.removeClass(t.join(\" \")), this.emitContainerClasses();\n    }\n  };\n  var W = {\n    init: !0,\n    direction: \"horizontal\",\n    touchEventsTarget: \"wrapper\",\n    initialSlide: 0,\n    speed: 300,\n    cssMode: !1,\n    updateOnWindowResize: !0,\n    resizeObserver: !0,\n    nested: !1,\n    createElements: !1,\n    enabled: !0,\n    focusableElements: \"input, select, option, textarea, button, video, label\",\n    width: null,\n    height: null,\n    preventInteractionOnTransition: !1,\n    userAgent: null,\n    url: null,\n    edgeSwipeDetection: !1,\n    edgeSwipeThreshold: 20,\n    autoHeight: !1,\n    setWrapperSize: !1,\n    virtualTranslate: !1,\n    effect: \"slide\",\n    breakpoints: void 0,\n    breakpointsBase: \"window\",\n    spaceBetween: 0,\n    slidesPerView: 1,\n    slidesPerGroup: 1,\n    slidesPerGroupSkip: 0,\n    slidesPerGroupAuto: !1,\n    centeredSlides: !1,\n    centeredSlidesBounds: !1,\n    slidesOffsetBefore: 0,\n    slidesOffsetAfter: 0,\n    normalizeSlideIndex: !0,\n    centerInsufficientSlides: !1,\n    watchOverflow: !0,\n    roundLengths: !1,\n    touchRatio: 1,\n    touchAngle: 45,\n    simulateTouch: !0,\n    shortSwipes: !0,\n    longSwipes: !0,\n    longSwipesRatio: .5,\n    longSwipesMs: 300,\n    followFinger: !0,\n    allowTouchMove: !0,\n    threshold: 0,\n    touchMoveStopPropagation: !1,\n    touchStartPreventDefault: !0,\n    touchStartForcePreventDefault: !1,\n    touchReleaseOnEdges: !1,\n    uniqueNavElements: !0,\n    resistance: !0,\n    resistanceRatio: .85,\n    watchSlidesProgress: !1,\n    grabCursor: !1,\n    preventClicks: !0,\n    preventClicksPropagation: !0,\n    slideToClickedSlide: !1,\n    preloadImages: !0,\n    updateOnImagesReady: !0,\n    loop: !1,\n    loopAdditionalSlides: 0,\n    loopedSlides: null,\n    loopedSlidesLimit: !0,\n    loopFillGroupWithBlank: !1,\n    loopPreventsSlide: !0,\n    rewind: !1,\n    allowSlidePrev: !0,\n    allowSlideNext: !0,\n    swipeHandler: null,\n    noSwiping: !0,\n    noSwipingClass: \"swiper-no-swiping\",\n    noSwipingSelector: null,\n    passiveListeners: !0,\n    maxBackfaceHiddenSlides: 10,\n    containerModifierClass: \"swiper-\",\n    slideClass: \"swiper-slide\",\n    slideBlankClass: \"swiper-slide-invisible-blank\",\n    slideActiveClass: \"swiper-slide-active\",\n    slideDuplicateActiveClass: \"swiper-slide-duplicate-active\",\n    slideVisibleClass: \"swiper-slide-visible\",\n    slideDuplicateClass: \"swiper-slide-duplicate\",\n    slideNextClass: \"swiper-slide-next\",\n    slideDuplicateNextClass: \"swiper-slide-duplicate-next\",\n    slidePrevClass: \"swiper-slide-prev\",\n    slideDuplicatePrevClass: \"swiper-slide-duplicate-prev\",\n    wrapperClass: \"swiper-wrapper\",\n    runCallbacksOnInit: !0,\n    _emitClasses: !1\n  };\n  function q(e, t) {\n    return function (s) {\n      void 0 === s && (s = {});\n      const a = Object.keys(s)[0],\n        i = s[a];\n      \"object\" == typeof i && null !== i ? ([\"navigation\", \"pagination\", \"scrollbar\"].indexOf(a) >= 0 && !0 === e[a] && (e[a] = {\n        auto: !0\n      }), a in e && \"enabled\" in i ? (!0 === e[a] && (e[a] = {\n        enabled: !0\n      }), \"object\" != typeof e[a] || \"enabled\" in e[a] || (e[a].enabled = !0), e[a] || (e[a] = {\n        enabled: !1\n      }), g(t, s)) : g(t, s)) : g(t, s);\n    };\n  }\n  const j = {\n      eventsEmitter: $,\n      update: S,\n      translate: M,\n      transition: {\n        setTransition: function (e, t) {\n          const s = this;\n          s.params.cssMode || s.$wrapperEl.transition(e), s.emit(\"setTransition\", e, t);\n        },\n        transitionStart: function (e, t) {\n          void 0 === e && (e = !0);\n          const s = this,\n            {\n              params: a\n            } = s;\n          a.cssMode || (a.autoHeight && s.updateAutoHeight(), P({\n            swiper: s,\n            runCallbacks: e,\n            direction: t,\n            step: \"Start\"\n          }));\n        },\n        transitionEnd: function (e, t) {\n          void 0 === e && (e = !0);\n          const s = this,\n            {\n              params: a\n            } = s;\n          s.animating = !1, a.cssMode || (s.setTransition(0), P({\n            swiper: s,\n            runCallbacks: e,\n            direction: t,\n            step: \"End\"\n          }));\n        }\n      },\n      slide: k,\n      loop: z,\n      grabCursor: {\n        setGrabCursor: function (e) {\n          const t = this;\n          if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;\n          const s = \"container\" === t.params.touchEventsTarget ? t.el : t.wrapperEl;\n          s.style.cursor = \"move\", s.style.cursor = e ? \"grabbing\" : \"grab\";\n        },\n        unsetGrabCursor: function () {\n          const e = this;\n          e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e[\"container\" === e.params.touchEventsTarget ? \"el\" : \"wrapperEl\"].style.cursor = \"\");\n        }\n      },\n      events: X,\n      breakpoints: {\n        setBreakpoint: function () {\n          const e = this,\n            {\n              activeIndex: t,\n              initialized: s,\n              loopedSlides: a = 0,\n              params: i,\n              $el: r\n            } = e,\n            n = i.breakpoints;\n          if (!n || n && 0 === Object.keys(n).length) return;\n          const l = e.getBreakpoint(n, e.params.breakpointsBase, e.el);\n          if (!l || e.currentBreakpoint === l) return;\n          const o = (l in n ? n[l] : void 0) || e.originalParams,\n            d = Y(e, i),\n            c = Y(e, o),\n            p = i.enabled;\n          d && !c ? (r.removeClass(`${i.containerModifierClass}grid ${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !d && c && (r.addClass(`${i.containerModifierClass}grid`), (o.grid.fill && \"column\" === o.grid.fill || !o.grid.fill && \"column\" === i.grid.fill) && r.addClass(`${i.containerModifierClass}grid-column`), e.emitContainerClasses()), [\"navigation\", \"pagination\", \"scrollbar\"].forEach(t => {\n            const s = i[t] && i[t].enabled,\n              a = o[t] && o[t].enabled;\n            s && !a && e[t].disable(), !s && a && e[t].enable();\n          });\n          const u = o.direction && o.direction !== i.direction,\n            h = i.loop && (o.slidesPerView !== i.slidesPerView || u);\n          u && s && e.changeDirection(), g(e.params, o);\n          const m = e.params.enabled;\n          Object.assign(e, {\n            allowTouchMove: e.params.allowTouchMove,\n            allowSlideNext: e.params.allowSlideNext,\n            allowSlidePrev: e.params.allowSlidePrev\n          }), p && !m ? e.disable() : !p && m && e.enable(), e.currentBreakpoint = l, e.emit(\"_beforeBreakpoint\", o), h && s && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - a + e.loopedSlides, 0, !1)), e.emit(\"breakpoint\", o);\n        },\n        getBreakpoint: function (e, t, s) {\n          if (void 0 === t && (t = \"window\"), !e || \"container\" === t && !s) return;\n          let a = !1;\n          const i = r(),\n            n = \"window\" === t ? i.innerHeight : s.clientHeight,\n            l = Object.keys(e).map(e => {\n              if (\"string\" == typeof e && 0 === e.indexOf(\"@\")) {\n                const t = parseFloat(e.substr(1));\n                return {\n                  value: n * t,\n                  point: e\n                };\n              }\n              return {\n                value: e,\n                point: e\n              };\n            });\n          l.sort((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10));\n          for (let e = 0; e < l.length; e += 1) {\n            const {\n              point: r,\n              value: n\n            } = l[e];\n            \"window\" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r);\n          }\n          return a || \"max\";\n        }\n      },\n      checkOverflow: {\n        checkOverflow: function () {\n          const e = this,\n            {\n              isLocked: t,\n              params: s\n            } = e,\n            {\n              slidesOffsetBefore: a\n            } = s;\n          if (a) {\n            const t = e.slides.length - 1,\n              s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a;\n            e.isLocked = e.size > s;\n          } else e.isLocked = 1 === e.snapGrid.length;\n          !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? \"lock\" : \"unlock\");\n        }\n      },\n      classes: R,\n      images: {\n        loadImage: function (e, t, s, a, i, n) {\n          const l = r();\n          let o;\n          function c() {\n            n && n();\n          }\n          d(e).parent(\"picture\")[0] || e.complete && i ? c() : t ? (o = new l.Image(), o.onload = c, o.onerror = c, a && (o.sizes = a), s && (o.srcset = s), t && (o.src = t)) : c();\n        },\n        preloadImages: function () {\n          const e = this;\n          function t() {\n            null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit(\"imagesReady\")));\n          }\n          e.imagesToLoad = e.$el.find(\"img\");\n          for (let s = 0; s < e.imagesToLoad.length; s += 1) {\n            const a = e.imagesToLoad[s];\n            e.loadImage(a, a.currentSrc || a.getAttribute(\"src\"), a.srcset || a.getAttribute(\"srcset\"), a.sizes || a.getAttribute(\"sizes\"), !0, t);\n          }\n        }\n      }\n    },\n    _ = {};\n  class V {\n    constructor() {\n      let e, t;\n      for (var s = arguments.length, a = new Array(s), i = 0; i < s; i++) a[i] = arguments[i];\n      if (1 === a.length && a[0].constructor && \"Object\" === Object.prototype.toString.call(a[0]).slice(8, -1) ? t = a[0] : [e, t] = a, t || (t = {}), t = g({}, t), e && !t.el && (t.el = e), t.el && d(t.el).length > 1) {\n        const e = [];\n        return d(t.el).each(s => {\n          const a = g({}, t, {\n            el: s\n          });\n          e.push(new V(a));\n        }), e;\n      }\n      const r = this;\n      r.__swiper__ = !0, r.support = E(), r.device = C({\n        userAgent: t.userAgent\n      }), r.browser = T(), r.eventsListeners = {}, r.eventsAnyListeners = [], r.modules = [...r.__modules__], t.modules && Array.isArray(t.modules) && r.modules.push(...t.modules);\n      const n = {};\n      r.modules.forEach(e => {\n        e({\n          swiper: r,\n          extendParams: q(t, n),\n          on: r.on.bind(r),\n          once: r.once.bind(r),\n          off: r.off.bind(r),\n          emit: r.emit.bind(r)\n        });\n      });\n      const l = g({}, W, n);\n      return r.params = g({}, l, _, t), r.originalParams = g({}, r.params), r.passedParams = g({}, t), r.params && r.params.on && Object.keys(r.params.on).forEach(e => {\n        r.on(e, r.params.on[e]);\n      }), r.params && r.params.onAny && r.onAny(r.params.onAny), r.$ = d, Object.assign(r, {\n        enabled: r.params.enabled,\n        el: e,\n        classNames: [],\n        slides: d(),\n        slidesGrid: [],\n        snapGrid: [],\n        slidesSizesGrid: [],\n        isHorizontal: () => \"horizontal\" === r.params.direction,\n        isVertical: () => \"vertical\" === r.params.direction,\n        activeIndex: 0,\n        realIndex: 0,\n        isBeginning: !0,\n        isEnd: !1,\n        translate: 0,\n        previousTranslate: 0,\n        progress: 0,\n        velocity: 0,\n        animating: !1,\n        allowSlideNext: r.params.allowSlideNext,\n        allowSlidePrev: r.params.allowSlidePrev,\n        touchEvents: function () {\n          const e = [\"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\"],\n            t = [\"pointerdown\", \"pointermove\", \"pointerup\"];\n          return r.touchEventsTouch = {\n            start: e[0],\n            move: e[1],\n            end: e[2],\n            cancel: e[3]\n          }, r.touchEventsDesktop = {\n            start: t[0],\n            move: t[1],\n            end: t[2]\n          }, r.support.touch || !r.params.simulateTouch ? r.touchEventsTouch : r.touchEventsDesktop;\n        }(),\n        touchEventsData: {\n          isTouched: void 0,\n          isMoved: void 0,\n          allowTouchCallbacks: void 0,\n          touchStartTime: void 0,\n          isScrolling: void 0,\n          currentTranslate: void 0,\n          startTranslate: void 0,\n          allowThresholdMove: void 0,\n          focusableElements: r.params.focusableElements,\n          lastClickTime: u(),\n          clickTimeout: void 0,\n          velocities: [],\n          allowMomentumBounce: void 0,\n          isTouchEvent: void 0,\n          startMoving: void 0\n        },\n        allowClick: !0,\n        allowTouchMove: r.params.allowTouchMove,\n        touches: {\n          startX: 0,\n          startY: 0,\n          currentX: 0,\n          currentY: 0,\n          diff: 0\n        },\n        imagesToLoad: [],\n        imagesLoaded: 0\n      }), r.emit(\"_swiper\"), r.params.init && r.init(), r;\n    }\n    enable() {\n      const e = this;\n      e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit(\"enable\"));\n    }\n    disable() {\n      const e = this;\n      e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit(\"disable\"));\n    }\n    setProgress(e, t) {\n      const s = this;\n      e = Math.min(Math.max(e, 0), 1);\n      const a = s.minTranslate(),\n        i = (s.maxTranslate() - a) * e + a;\n      s.translateTo(i, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses();\n    }\n    emitContainerClasses() {\n      const e = this;\n      if (!e.params._emitClasses || !e.el) return;\n      const t = e.el.className.split(\" \").filter(t => 0 === t.indexOf(\"swiper\") || 0 === t.indexOf(e.params.containerModifierClass));\n      e.emit(\"_containerClasses\", t.join(\" \"));\n    }\n    getSlideClasses(e) {\n      const t = this;\n      return t.destroyed ? \"\" : e.className.split(\" \").filter(e => 0 === e.indexOf(\"swiper-slide\") || 0 === e.indexOf(t.params.slideClass)).join(\" \");\n    }\n    emitSlidesClasses() {\n      const e = this;\n      if (!e.params._emitClasses || !e.el) return;\n      const t = [];\n      e.slides.each(s => {\n        const a = e.getSlideClasses(s);\n        t.push({\n          slideEl: s,\n          classNames: a\n        }), e.emit(\"_slideClass\", s, a);\n      }), e.emit(\"_slideClasses\", t);\n    }\n    slidesPerViewDynamic(e, t) {\n      void 0 === e && (e = \"current\"), void 0 === t && (t = !1);\n      const {\n        params: s,\n        slides: a,\n        slidesGrid: i,\n        slidesSizesGrid: r,\n        size: n,\n        activeIndex: l\n      } = this;\n      let o = 1;\n      if (s.centeredSlides) {\n        let e,\n          t = a[l].swiperSlideSize;\n        for (let s = l + 1; s < a.length; s += 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0));\n        for (let s = l - 1; s >= 0; s -= 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0));\n      } else if (\"current\" === e) for (let e = l + 1; e < a.length; e += 1) {\n        (t ? i[e] + r[e] - i[l] < n : i[e] - i[l] < n) && (o += 1);\n      } else for (let e = l - 1; e >= 0; e -= 1) {\n        i[l] - i[e] < n && (o += 1);\n      }\n      return o;\n    }\n    update() {\n      const e = this;\n      if (!e || e.destroyed) return;\n      const {\n        snapGrid: t,\n        params: s\n      } = e;\n      function a() {\n        const t = e.rtlTranslate ? -1 * e.translate : e.translate,\n          s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());\n        e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses();\n      }\n      let i;\n      s.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (a(), e.params.autoHeight && e.updateAutoHeight()) : (i = (\"auto\" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), i || a()), s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit(\"update\");\n    }\n    changeDirection(e, t) {\n      void 0 === t && (t = !0);\n      const s = this,\n        a = s.params.direction;\n      return e || (e = \"horizontal\" === a ? \"vertical\" : \"horizontal\"), e === a || \"horizontal\" !== e && \"vertical\" !== e || (s.$el.removeClass(`${s.params.containerModifierClass}${a}`).addClass(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.each(t => {\n        \"vertical\" === e ? t.style.width = \"\" : t.style.height = \"\";\n      }), s.emit(\"changeDirection\"), t && s.update()), s;\n    }\n    changeLanguageDirection(e) {\n      const t = this;\n      t.rtl && \"rtl\" === e || !t.rtl && \"ltr\" === e || (t.rtl = \"rtl\" === e, t.rtlTranslate = \"horizontal\" === t.params.direction && t.rtl, t.rtl ? (t.$el.addClass(`${t.params.containerModifierClass}rtl`), t.el.dir = \"rtl\") : (t.$el.removeClass(`${t.params.containerModifierClass}rtl`), t.el.dir = \"ltr\"), t.update());\n    }\n    mount(e) {\n      const t = this;\n      if (t.mounted) return !0;\n      const s = d(e || t.params.el);\n      if (!(e = s[0])) return !1;\n      e.swiper = t;\n      const i = () => `.${(t.params.wrapperClass || \"\").trim().split(\" \").join(\".\")}`;\n      let r = (() => {\n        if (e && e.shadowRoot && e.shadowRoot.querySelector) {\n          const t = d(e.shadowRoot.querySelector(i()));\n          return t.children = e => s.children(e), t;\n        }\n        return s.children ? s.children(i()) : d(s).children(i());\n      })();\n      if (0 === r.length && t.params.createElements) {\n        const e = a().createElement(\"div\");\n        r = d(e), e.className = t.params.wrapperClass, s.append(e), s.children(`.${t.params.slideClass}`).each(e => {\n          r.append(e);\n        });\n      }\n      return Object.assign(t, {\n        $el: s,\n        el: e,\n        $wrapperEl: r,\n        wrapperEl: r[0],\n        mounted: !0,\n        rtl: \"rtl\" === e.dir.toLowerCase() || \"rtl\" === s.css(\"direction\"),\n        rtlTranslate: \"horizontal\" === t.params.direction && (\"rtl\" === e.dir.toLowerCase() || \"rtl\" === s.css(\"direction\")),\n        wrongRTL: \"-webkit-box\" === r.css(\"display\")\n      }), !0;\n    }\n    init(e) {\n      const t = this;\n      if (t.initialized) return t;\n      return !1 === t.mount(e) || (t.emit(\"beforeInit\"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit(\"init\"), t.emit(\"afterInit\")), t;\n    }\n    destroy(e, t) {\n      void 0 === e && (e = !0), void 0 === t && (t = !0);\n      const s = this,\n        {\n          params: a,\n          $el: i,\n          $wrapperEl: r,\n          slides: n\n        } = s;\n      return void 0 === s.params || s.destroyed || (s.emit(\"beforeDestroy\"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i.removeAttr(\"style\"), r.removeAttr(\"style\"), n && n.length && n.removeClass([a.slideVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass].join(\" \")).removeAttr(\"style\").removeAttr(\"data-swiper-slide-index\")), s.emit(\"destroy\"), Object.keys(s.eventsListeners).forEach(e => {\n        s.off(e);\n      }), !1 !== e && (s.$el[0].swiper = null, function (e) {\n        const t = e;\n        Object.keys(t).forEach(e => {\n          try {\n            t[e] = null;\n          } catch (e) {}\n          try {\n            delete t[e];\n          } catch (e) {}\n        });\n      }(s)), s.destroyed = !0), null;\n    }\n    static extendDefaults(e) {\n      g(_, e);\n    }\n    static get extendedDefaults() {\n      return _;\n    }\n    static get defaults() {\n      return W;\n    }\n    static installModule(e) {\n      V.prototype.__modules__ || (V.prototype.__modules__ = []);\n      const t = V.prototype.__modules__;\n      \"function\" == typeof e && t.indexOf(e) < 0 && t.push(e);\n    }\n    static use(e) {\n      return Array.isArray(e) ? (e.forEach(e => V.installModule(e)), V) : (V.installModule(e), V);\n    }\n  }\n  function F(e, t, s, i) {\n    const r = a();\n    return e.params.createElements && Object.keys(i).forEach(a => {\n      if (!s[a] && !0 === s.auto) {\n        let n = e.$el.children(`.${i[a]}`)[0];\n        n || (n = r.createElement(\"div\"), n.className = i[a], e.$el.append(n)), s[a] = n, t[a] = n;\n      }\n    }), s;\n  }\n  function U(e) {\n    return void 0 === e && (e = \"\"), `.${e.trim().replace(/([\\.:!\\/])/g, \"\\\\$1\").replace(/ /g, \".\")}`;\n  }\n  function K(e) {\n    const t = this,\n      {\n        $wrapperEl: s,\n        params: a\n      } = t;\n    if (a.loop && t.loopDestroy(), \"object\" == typeof e && \"length\" in e) for (let t = 0; t < e.length; t += 1) e[t] && s.append(e[t]);else s.append(e);\n    a.loop && t.loopCreate(), a.observer || t.update();\n  }\n  function Z(e) {\n    const t = this,\n      {\n        params: s,\n        $wrapperEl: a,\n        activeIndex: i\n      } = t;\n    s.loop && t.loopDestroy();\n    let r = i + 1;\n    if (\"object\" == typeof e && \"length\" in e) {\n      for (let t = 0; t < e.length; t += 1) e[t] && a.prepend(e[t]);\n      r = i + e.length;\n    } else a.prepend(e);\n    s.loop && t.loopCreate(), s.observer || t.update(), t.slideTo(r, 0, !1);\n  }\n  function Q(e, t) {\n    const s = this,\n      {\n        $wrapperEl: a,\n        params: i,\n        activeIndex: r\n      } = s;\n    let n = r;\n    i.loop && (n -= s.loopedSlides, s.loopDestroy(), s.slides = a.children(`.${i.slideClass}`));\n    const l = s.slides.length;\n    if (e <= 0) return void s.prependSlide(t);\n    if (e >= l) return void s.appendSlide(t);\n    let o = n > e ? n + 1 : n;\n    const d = [];\n    for (let t = l - 1; t >= e; t -= 1) {\n      const e = s.slides.eq(t);\n      e.remove(), d.unshift(e);\n    }\n    if (\"object\" == typeof t && \"length\" in t) {\n      for (let e = 0; e < t.length; e += 1) t[e] && a.append(t[e]);\n      o = n > e ? n + t.length : n;\n    } else a.append(t);\n    for (let e = 0; e < d.length; e += 1) a.append(d[e]);\n    i.loop && s.loopCreate(), i.observer || s.update(), i.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1);\n  }\n  function J(e) {\n    const t = this,\n      {\n        params: s,\n        $wrapperEl: a,\n        activeIndex: i\n      } = t;\n    let r = i;\n    s.loop && (r -= t.loopedSlides, t.loopDestroy(), t.slides = a.children(`.${s.slideClass}`));\n    let n,\n      l = r;\n    if (\"object\" == typeof e && \"length\" in e) {\n      for (let s = 0; s < e.length; s += 1) n = e[s], t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1);\n      l = Math.max(l, 0);\n    } else n = e, t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1), l = Math.max(l, 0);\n    s.loop && t.loopCreate(), s.observer || t.update(), s.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1);\n  }\n  function ee() {\n    const e = this,\n      t = [];\n    for (let s = 0; s < e.slides.length; s += 1) t.push(s);\n    e.removeSlide(t);\n  }\n  function te(e) {\n    const {\n      effect: t,\n      swiper: s,\n      on: a,\n      setTranslate: i,\n      setTransition: r,\n      overwriteParams: n,\n      perspective: l,\n      recreateShadows: o,\n      getEffectParams: d\n    } = e;\n    let c;\n    a(\"beforeInit\", () => {\n      if (s.params.effect !== t) return;\n      s.classNames.push(`${s.params.containerModifierClass}${t}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`);\n      const e = n ? n() : {};\n      Object.assign(s.params, e), Object.assign(s.originalParams, e);\n    }), a(\"setTranslate\", () => {\n      s.params.effect === t && i();\n    }), a(\"setTransition\", (e, a) => {\n      s.params.effect === t && r(a);\n    }), a(\"transitionEnd\", () => {\n      if (s.params.effect === t && o) {\n        if (!d || !d().slideShadows) return;\n        s.slides.each(e => {\n          s.$(e).find(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").remove();\n        }), o();\n      }\n    }), a(\"virtualUpdate\", () => {\n      s.params.effect === t && (s.slides.length || (c = !0), requestAnimationFrame(() => {\n        c && s.slides && s.slides.length && (i(), c = !1);\n      }));\n    });\n  }\n  function se(e, t) {\n    return e.transformEl ? t.find(e.transformEl).css({\n      \"backface-visibility\": \"hidden\",\n      \"-webkit-backface-visibility\": \"hidden\"\n    }) : t;\n  }\n  function ae(e) {\n    let {\n      swiper: t,\n      duration: s,\n      transformEl: a,\n      allSlides: i\n    } = e;\n    const {\n      slides: r,\n      activeIndex: n,\n      $wrapperEl: l\n    } = t;\n    if (t.params.virtualTranslate && 0 !== s) {\n      let e,\n        s = !1;\n      e = i ? a ? r.find(a) : r : a ? r.eq(n).find(a) : r.eq(n), e.transitionEnd(() => {\n        if (s) return;\n        if (!t || t.destroyed) return;\n        s = !0, t.animating = !1;\n        const e = [\"webkitTransitionEnd\", \"transitionend\"];\n        for (let t = 0; t < e.length; t += 1) l.trigger(e[t]);\n      });\n    }\n  }\n  function ie(e, t, s) {\n    const a = \"swiper-slide-shadow\" + (s ? `-${s}` : \"\"),\n      i = e.transformEl ? t.find(e.transformEl) : t;\n    let r = i.children(`.${a}`);\n    return r.length || (r = d(`<div class=\"swiper-slide-shadow${s ? `-${s}` : \"\"}\"></div>`), i.append(r)), r;\n  }\n  Object.keys(j).forEach(e => {\n    Object.keys(j[e]).forEach(t => {\n      V.prototype[t] = j[e][t];\n    });\n  }), V.use([function (e) {\n    let {\n      swiper: t,\n      on: s,\n      emit: a\n    } = e;\n    const i = r();\n    let n = null,\n      l = null;\n    const o = () => {\n        t && !t.destroyed && t.initialized && (a(\"beforeResize\"), a(\"resize\"));\n      },\n      d = () => {\n        t && !t.destroyed && t.initialized && a(\"orientationchange\");\n      };\n    s(\"init\", () => {\n      t.params.resizeObserver && void 0 !== i.ResizeObserver ? t && !t.destroyed && t.initialized && (n = new ResizeObserver(e => {\n        l = i.requestAnimationFrame(() => {\n          const {\n            width: s,\n            height: a\n          } = t;\n          let i = s,\n            r = a;\n          e.forEach(e => {\n            let {\n              contentBoxSize: s,\n              contentRect: a,\n              target: n\n            } = e;\n            n && n !== t.el || (i = a ? a.width : (s[0] || s).inlineSize, r = a ? a.height : (s[0] || s).blockSize);\n          }), i === s && r === a || o();\n        });\n      }), n.observe(t.el)) : (i.addEventListener(\"resize\", o), i.addEventListener(\"orientationchange\", d));\n    }), s(\"destroy\", () => {\n      l && i.cancelAnimationFrame(l), n && n.unobserve && t.el && (n.unobserve(t.el), n = null), i.removeEventListener(\"resize\", o), i.removeEventListener(\"orientationchange\", d);\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a,\n      emit: i\n    } = e;\n    const n = [],\n      l = r(),\n      o = function (e, t) {\n        void 0 === t && (t = {});\n        const s = new (l.MutationObserver || l.WebkitMutationObserver)(e => {\n          if (1 === e.length) return void i(\"observerUpdate\", e[0]);\n          const t = function () {\n            i(\"observerUpdate\", e[0]);\n          };\n          l.requestAnimationFrame ? l.requestAnimationFrame(t) : l.setTimeout(t, 0);\n        });\n        s.observe(e, {\n          attributes: void 0 === t.attributes || t.attributes,\n          childList: void 0 === t.childList || t.childList,\n          characterData: void 0 === t.characterData || t.characterData\n        }), n.push(s);\n      };\n    s({\n      observer: !1,\n      observeParents: !1,\n      observeSlideChildren: !1\n    }), a(\"init\", () => {\n      if (t.params.observer) {\n        if (t.params.observeParents) {\n          const e = t.$el.parents();\n          for (let t = 0; t < e.length; t += 1) o(e[t]);\n        }\n        o(t.$el[0], {\n          childList: t.params.observeSlideChildren\n        }), o(t.$wrapperEl[0], {\n          attributes: !1\n        });\n      }\n    }), a(\"destroy\", () => {\n      n.forEach(e => {\n        e.disconnect();\n      }), n.splice(0, n.length);\n    });\n  }]);\n  const re = [function (e) {\n    let t,\n      {\n        swiper: s,\n        extendParams: a,\n        on: i,\n        emit: r\n      } = e;\n    function n(e, t) {\n      const a = s.params.virtual;\n      if (a.cache && s.virtual.cache[t]) return s.virtual.cache[t];\n      const i = a.renderSlide ? d(a.renderSlide.call(s, e, t)) : d(`<div class=\"${s.params.slideClass}\" data-swiper-slide-index=\"${t}\">${e}</div>`);\n      return i.attr(\"data-swiper-slide-index\") || i.attr(\"data-swiper-slide-index\", t), a.cache && (s.virtual.cache[t] = i), i;\n    }\n    function l(e) {\n      const {\n          slidesPerView: t,\n          slidesPerGroup: a,\n          centeredSlides: i\n        } = s.params,\n        {\n          addSlidesBefore: l,\n          addSlidesAfter: o\n        } = s.params.virtual,\n        {\n          from: d,\n          to: c,\n          slides: p,\n          slidesGrid: u,\n          offset: h\n        } = s.virtual;\n      s.params.cssMode || s.updateActiveIndex();\n      const m = s.activeIndex || 0;\n      let f, g, v;\n      f = s.rtlTranslate ? \"right\" : s.isHorizontal() ? \"left\" : \"top\", i ? (g = Math.floor(t / 2) + a + o, v = Math.floor(t / 2) + a + l) : (g = t + (a - 1) + o, v = a + l);\n      const w = Math.max((m || 0) - v, 0),\n        b = Math.min((m || 0) + g, p.length - 1),\n        x = (s.slidesGrid[w] || 0) - (s.slidesGrid[0] || 0);\n      function y() {\n        s.updateSlides(), s.updateProgress(), s.updateSlidesClasses(), s.lazy && s.params.lazy.enabled && s.lazy.load(), r(\"virtualUpdate\");\n      }\n      if (Object.assign(s.virtual, {\n        from: w,\n        to: b,\n        offset: x,\n        slidesGrid: s.slidesGrid\n      }), d === w && c === b && !e) return s.slidesGrid !== u && x !== h && s.slides.css(f, `${x}px`), s.updateProgress(), void r(\"virtualUpdate\");\n      if (s.params.virtual.renderExternal) return s.params.virtual.renderExternal.call(s, {\n        offset: x,\n        from: w,\n        to: b,\n        slides: function () {\n          const e = [];\n          for (let t = w; t <= b; t += 1) e.push(p[t]);\n          return e;\n        }()\n      }), void (s.params.virtual.renderExternalUpdate ? y() : r(\"virtualUpdate\"));\n      const E = [],\n        C = [];\n      if (e) s.$wrapperEl.find(`.${s.params.slideClass}`).remove();else for (let e = d; e <= c; e += 1) (e < w || e > b) && s.$wrapperEl.find(`.${s.params.slideClass}[data-swiper-slide-index=\"${e}\"]`).remove();\n      for (let t = 0; t < p.length; t += 1) t >= w && t <= b && (void 0 === c || e ? C.push(t) : (t > c && C.push(t), t < d && E.push(t)));\n      C.forEach(e => {\n        s.$wrapperEl.append(n(p[e], e));\n      }), E.sort((e, t) => t - e).forEach(e => {\n        s.$wrapperEl.prepend(n(p[e], e));\n      }), s.$wrapperEl.children(\".swiper-slide\").css(f, `${x}px`), y();\n    }\n    a({\n      virtual: {\n        enabled: !1,\n        slides: [],\n        cache: !0,\n        renderSlide: null,\n        renderExternal: null,\n        renderExternalUpdate: !0,\n        addSlidesBefore: 0,\n        addSlidesAfter: 0\n      }\n    }), s.virtual = {\n      cache: {},\n      from: void 0,\n      to: void 0,\n      slides: [],\n      offset: 0,\n      slidesGrid: []\n    }, i(\"beforeInit\", () => {\n      s.params.virtual.enabled && (s.virtual.slides = s.params.virtual.slides, s.classNames.push(`${s.params.containerModifierClass}virtual`), s.params.watchSlidesProgress = !0, s.originalParams.watchSlidesProgress = !0, s.params.initialSlide || l());\n    }), i(\"setTranslate\", () => {\n      s.params.virtual.enabled && (s.params.cssMode && !s._immediateVirtual ? (clearTimeout(t), t = setTimeout(() => {\n        l();\n      }, 100)) : l());\n    }), i(\"init update resize\", () => {\n      s.params.virtual.enabled && s.params.cssMode && v(s.wrapperEl, \"--swiper-virtual-size\", `${s.virtualSize}px`);\n    }), Object.assign(s.virtual, {\n      appendSlide: function (e) {\n        if (\"object\" == typeof e && \"length\" in e) for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.push(e[t]);else s.virtual.slides.push(e);\n        l(!0);\n      },\n      prependSlide: function (e) {\n        const t = s.activeIndex;\n        let a = t + 1,\n          i = 1;\n        if (Array.isArray(e)) {\n          for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.unshift(e[t]);\n          a = t + e.length, i = e.length;\n        } else s.virtual.slides.unshift(e);\n        if (s.params.virtual.cache) {\n          const e = s.virtual.cache,\n            t = {};\n          Object.keys(e).forEach(s => {\n            const a = e[s],\n              r = a.attr(\"data-swiper-slide-index\");\n            r && a.attr(\"data-swiper-slide-index\", parseInt(r, 10) + i), t[parseInt(s, 10) + i] = a;\n          }), s.virtual.cache = t;\n        }\n        l(!0), s.slideTo(a, 0);\n      },\n      removeSlide: function (e) {\n        if (null == e) return;\n        let t = s.activeIndex;\n        if (Array.isArray(e)) for (let a = e.length - 1; a >= 0; a -= 1) s.virtual.slides.splice(e[a], 1), s.params.virtual.cache && delete s.virtual.cache[e[a]], e[a] < t && (t -= 1), t = Math.max(t, 0);else s.virtual.slides.splice(e, 1), s.params.virtual.cache && delete s.virtual.cache[e], e < t && (t -= 1), t = Math.max(t, 0);\n        l(!0), s.slideTo(t, 0);\n      },\n      removeAllSlides: function () {\n        s.virtual.slides = [], s.params.virtual.cache && (s.virtual.cache = {}), l(!0), s.slideTo(0, 0);\n      },\n      update: l\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: i,\n      emit: n\n    } = e;\n    const l = a(),\n      o = r();\n    function c(e) {\n      if (!t.enabled) return;\n      const {\n        rtlTranslate: s\n      } = t;\n      let a = e;\n      a.originalEvent && (a = a.originalEvent);\n      const i = a.keyCode || a.charCode,\n        r = t.params.keyboard.pageUpDown,\n        d = r && 33 === i,\n        c = r && 34 === i,\n        p = 37 === i,\n        u = 39 === i,\n        h = 38 === i,\n        m = 40 === i;\n      if (!t.allowSlideNext && (t.isHorizontal() && u || t.isVertical() && m || c)) return !1;\n      if (!t.allowSlidePrev && (t.isHorizontal() && p || t.isVertical() && h || d)) return !1;\n      if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || l.activeElement && l.activeElement.nodeName && (\"input\" === l.activeElement.nodeName.toLowerCase() || \"textarea\" === l.activeElement.nodeName.toLowerCase()))) {\n        if (t.params.keyboard.onlyInViewport && (d || c || p || u || h || m)) {\n          let e = !1;\n          if (t.$el.parents(`.${t.params.slideClass}`).length > 0 && 0 === t.$el.parents(`.${t.params.slideActiveClass}`).length) return;\n          const a = t.$el,\n            i = a[0].clientWidth,\n            r = a[0].clientHeight,\n            n = o.innerWidth,\n            l = o.innerHeight,\n            d = t.$el.offset();\n          s && (d.left -= t.$el[0].scrollLeft);\n          const c = [[d.left, d.top], [d.left + i, d.top], [d.left, d.top + r], [d.left + i, d.top + r]];\n          for (let t = 0; t < c.length; t += 1) {\n            const s = c[t];\n            if (s[0] >= 0 && s[0] <= n && s[1] >= 0 && s[1] <= l) {\n              if (0 === s[0] && 0 === s[1]) continue;\n              e = !0;\n            }\n          }\n          if (!e) return;\n        }\n        t.isHorizontal() ? ((d || c || p || u) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((c || u) && !s || (d || p) && s) && t.slideNext(), ((d || p) && !s || (c || u) && s) && t.slidePrev()) : ((d || c || h || m) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (c || m) && t.slideNext(), (d || h) && t.slidePrev()), n(\"keyPress\", i);\n      }\n    }\n    function p() {\n      t.keyboard.enabled || (d(l).on(\"keydown\", c), t.keyboard.enabled = !0);\n    }\n    function u() {\n      t.keyboard.enabled && (d(l).off(\"keydown\", c), t.keyboard.enabled = !1);\n    }\n    t.keyboard = {\n      enabled: !1\n    }, s({\n      keyboard: {\n        enabled: !1,\n        onlyInViewport: !0,\n        pageUpDown: !0\n      }\n    }), i(\"init\", () => {\n      t.params.keyboard.enabled && p();\n    }), i(\"destroy\", () => {\n      t.keyboard.enabled && u();\n    }), Object.assign(t.keyboard, {\n      enable: p,\n      disable: u\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a,\n      emit: i\n    } = e;\n    const n = r();\n    let l;\n    s({\n      mousewheel: {\n        enabled: !1,\n        releaseOnEdges: !1,\n        invert: !1,\n        forceToAxis: !1,\n        sensitivity: 1,\n        eventsTarget: \"container\",\n        thresholdDelta: null,\n        thresholdTime: null\n      }\n    }), t.mousewheel = {\n      enabled: !1\n    };\n    let o,\n      c = u();\n    const h = [];\n    function m() {\n      t.enabled && (t.mouseEntered = !0);\n    }\n    function f() {\n      t.enabled && (t.mouseEntered = !1);\n    }\n    function g(e) {\n      return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta) && !(t.params.mousewheel.thresholdTime && u() - c < t.params.mousewheel.thresholdTime) && (e.delta >= 6 && u() - c < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), i(\"scroll\", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), i(\"scroll\", e.raw)), c = new n.Date().getTime(), !1));\n    }\n    function v(e) {\n      let s = e,\n        a = !0;\n      if (!t.enabled) return;\n      const r = t.params.mousewheel;\n      t.params.cssMode && s.preventDefault();\n      let n = t.$el;\n      if (\"container\" !== t.params.mousewheel.eventsTarget && (n = d(t.params.mousewheel.eventsTarget)), !t.mouseEntered && !n[0].contains(s.target) && !r.releaseOnEdges) return !0;\n      s.originalEvent && (s = s.originalEvent);\n      let c = 0;\n      const m = t.rtlTranslate ? -1 : 1,\n        f = function (e) {\n          let t = 0,\n            s = 0,\n            a = 0,\n            i = 0;\n          return \"detail\" in e && (s = e.detail), \"wheelDelta\" in e && (s = -e.wheelDelta / 120), \"wheelDeltaY\" in e && (s = -e.wheelDeltaY / 120), \"wheelDeltaX\" in e && (t = -e.wheelDeltaX / 120), \"axis\" in e && e.axis === e.HORIZONTAL_AXIS && (t = s, s = 0), a = 10 * t, i = 10 * s, \"deltaY\" in e && (i = e.deltaY), \"deltaX\" in e && (a = e.deltaX), e.shiftKey && !a && (a = i, i = 0), (a || i) && e.deltaMode && (1 === e.deltaMode ? (a *= 40, i *= 40) : (a *= 800, i *= 800)), a && !t && (t = a < 1 ? -1 : 1), i && !s && (s = i < 1 ? -1 : 1), {\n            spinX: t,\n            spinY: s,\n            pixelX: a,\n            pixelY: i\n          };\n        }(s);\n      if (r.forceToAxis) {\n        if (t.isHorizontal()) {\n          if (!(Math.abs(f.pixelX) > Math.abs(f.pixelY))) return !0;\n          c = -f.pixelX * m;\n        } else {\n          if (!(Math.abs(f.pixelY) > Math.abs(f.pixelX))) return !0;\n          c = -f.pixelY;\n        }\n      } else c = Math.abs(f.pixelX) > Math.abs(f.pixelY) ? -f.pixelX * m : -f.pixelY;\n      if (0 === c) return !0;\n      r.invert && (c = -c);\n      let v = t.getTranslate() + c * r.sensitivity;\n      if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), a = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), a && t.params.nested && s.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) {\n        const e = {\n            time: u(),\n            delta: Math.abs(c),\n            direction: Math.sign(c)\n          },\n          a = o && e.time < o.time + 500 && e.delta <= o.delta && e.direction === o.direction;\n        if (!a) {\n          o = void 0, t.params.loop && t.loopFix();\n          let n = t.getTranslate() + c * r.sensitivity;\n          const d = t.isBeginning,\n            u = t.isEnd;\n          if (n >= t.minTranslate() && (n = t.minTranslate()), n <= t.maxTranslate() && (n = t.maxTranslate()), t.setTransition(0), t.setTranslate(n), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!d && t.isBeginning || !u && t.isEnd) && t.updateSlidesClasses(), t.params.freeMode.sticky) {\n            clearTimeout(l), l = void 0, h.length >= 15 && h.shift();\n            const s = h.length ? h[h.length - 1] : void 0,\n              a = h[0];\n            if (h.push(e), s && (e.delta > s.delta || e.direction !== s.direction)) h.splice(0);else if (h.length >= 15 && e.time - a.time < 500 && a.delta - e.delta >= 1 && e.delta <= 6) {\n              const s = c > 0 ? .8 : .2;\n              o = e, h.splice(0), l = p(() => {\n                t.slideToClosest(t.params.speed, !0, void 0, s);\n              }, 0);\n            }\n            l || (l = p(() => {\n              o = e, h.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5);\n            }, 500));\n          }\n          if (a || i(\"scroll\", s), t.params.autoplay && t.params.autoplayDisableOnInteraction && t.autoplay.stop(), n === t.minTranslate() || n === t.maxTranslate()) return !0;\n        }\n      } else {\n        const s = {\n          time: u(),\n          delta: Math.abs(c),\n          direction: Math.sign(c),\n          raw: e\n        };\n        h.length >= 2 && h.shift();\n        const a = h.length ? h[h.length - 1] : void 0;\n        if (h.push(s), a ? (s.direction !== a.direction || s.delta > a.delta || s.time > a.time + 150) && g(s) : g(s), function (e) {\n          const s = t.params.mousewheel;\n          if (e.direction < 0) {\n            if (t.isEnd && !t.params.loop && s.releaseOnEdges) return !0;\n          } else if (t.isBeginning && !t.params.loop && s.releaseOnEdges) return !0;\n          return !1;\n        }(s)) return !0;\n      }\n      return s.preventDefault ? s.preventDefault() : s.returnValue = !1, !1;\n    }\n    function w(e) {\n      let s = t.$el;\n      \"container\" !== t.params.mousewheel.eventsTarget && (s = d(t.params.mousewheel.eventsTarget)), s[e](\"mouseenter\", m), s[e](\"mouseleave\", f), s[e](\"wheel\", v);\n    }\n    function b() {\n      return t.params.cssMode ? (t.wrapperEl.removeEventListener(\"wheel\", v), !0) : !t.mousewheel.enabled && (w(\"on\"), t.mousewheel.enabled = !0, !0);\n    }\n    function x() {\n      return t.params.cssMode ? (t.wrapperEl.addEventListener(event, v), !0) : !!t.mousewheel.enabled && (w(\"off\"), t.mousewheel.enabled = !1, !0);\n    }\n    a(\"init\", () => {\n      !t.params.mousewheel.enabled && t.params.cssMode && x(), t.params.mousewheel.enabled && b();\n    }), a(\"destroy\", () => {\n      t.params.cssMode && b(), t.mousewheel.enabled && x();\n    }), Object.assign(t.mousewheel, {\n      enable: b,\n      disable: x\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a,\n      emit: i\n    } = e;\n    function r(e) {\n      let s;\n      return e && (s = d(e), t.params.uniqueNavElements && \"string\" == typeof e && s.length > 1 && 1 === t.$el.find(e).length && (s = t.$el.find(e))), s;\n    }\n    function n(e, s) {\n      const a = t.params.navigation;\n      e && e.length > 0 && (e[s ? \"addClass\" : \"removeClass\"](a.disabledClass), e[0] && \"BUTTON\" === e[0].tagName && (e[0].disabled = s), t.params.watchOverflow && t.enabled && e[t.isLocked ? \"addClass\" : \"removeClass\"](a.lockClass));\n    }\n    function l() {\n      if (t.params.loop) return;\n      const {\n        $nextEl: e,\n        $prevEl: s\n      } = t.navigation;\n      n(s, t.isBeginning && !t.params.rewind), n(e, t.isEnd && !t.params.rewind);\n    }\n    function o(e) {\n      e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), i(\"navigationPrev\"));\n    }\n    function c(e) {\n      e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), i(\"navigationNext\"));\n    }\n    function p() {\n      const e = t.params.navigation;\n      if (t.params.navigation = F(t, t.originalParams.navigation, t.params.navigation, {\n        nextEl: \"swiper-button-next\",\n        prevEl: \"swiper-button-prev\"\n      }), !e.nextEl && !e.prevEl) return;\n      const s = r(e.nextEl),\n        a = r(e.prevEl);\n      s && s.length > 0 && s.on(\"click\", c), a && a.length > 0 && a.on(\"click\", o), Object.assign(t.navigation, {\n        $nextEl: s,\n        nextEl: s && s[0],\n        $prevEl: a,\n        prevEl: a && a[0]\n      }), t.enabled || (s && s.addClass(e.lockClass), a && a.addClass(e.lockClass));\n    }\n    function u() {\n      const {\n        $nextEl: e,\n        $prevEl: s\n      } = t.navigation;\n      e && e.length && (e.off(\"click\", c), e.removeClass(t.params.navigation.disabledClass)), s && s.length && (s.off(\"click\", o), s.removeClass(t.params.navigation.disabledClass));\n    }\n    s({\n      navigation: {\n        nextEl: null,\n        prevEl: null,\n        hideOnClick: !1,\n        disabledClass: \"swiper-button-disabled\",\n        hiddenClass: \"swiper-button-hidden\",\n        lockClass: \"swiper-button-lock\",\n        navigationDisabledClass: \"swiper-navigation-disabled\"\n      }\n    }), t.navigation = {\n      nextEl: null,\n      $nextEl: null,\n      prevEl: null,\n      $prevEl: null\n    }, a(\"init\", () => {\n      !1 === t.params.navigation.enabled ? h() : (p(), l());\n    }), a(\"toEdge fromEdge lock unlock\", () => {\n      l();\n    }), a(\"destroy\", () => {\n      u();\n    }), a(\"enable disable\", () => {\n      const {\n        $nextEl: e,\n        $prevEl: s\n      } = t.navigation;\n      e && e[t.enabled ? \"removeClass\" : \"addClass\"](t.params.navigation.lockClass), s && s[t.enabled ? \"removeClass\" : \"addClass\"](t.params.navigation.lockClass);\n    }), a(\"click\", (e, s) => {\n      const {\n          $nextEl: a,\n          $prevEl: r\n        } = t.navigation,\n        n = s.target;\n      if (t.params.navigation.hideOnClick && !d(n).is(r) && !d(n).is(a)) {\n        if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === n || t.pagination.el.contains(n))) return;\n        let e;\n        a ? e = a.hasClass(t.params.navigation.hiddenClass) : r && (e = r.hasClass(t.params.navigation.hiddenClass)), i(!0 === e ? \"navigationShow\" : \"navigationHide\"), a && a.toggleClass(t.params.navigation.hiddenClass), r && r.toggleClass(t.params.navigation.hiddenClass);\n      }\n    });\n    const h = () => {\n      t.$el.addClass(t.params.navigation.navigationDisabledClass), u();\n    };\n    Object.assign(t.navigation, {\n      enable: () => {\n        t.$el.removeClass(t.params.navigation.navigationDisabledClass), p(), l();\n      },\n      disable: h,\n      update: l,\n      init: p,\n      destroy: u\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a,\n      emit: i\n    } = e;\n    const r = \"swiper-pagination\";\n    let n;\n    s({\n      pagination: {\n        el: null,\n        bulletElement: \"span\",\n        clickable: !1,\n        hideOnClick: !1,\n        renderBullet: null,\n        renderProgressbar: null,\n        renderFraction: null,\n        renderCustom: null,\n        progressbarOpposite: !1,\n        type: \"bullets\",\n        dynamicBullets: !1,\n        dynamicMainBullets: 1,\n        formatFractionCurrent: e => e,\n        formatFractionTotal: e => e,\n        bulletClass: `${r}-bullet`,\n        bulletActiveClass: `${r}-bullet-active`,\n        modifierClass: `${r}-`,\n        currentClass: `${r}-current`,\n        totalClass: `${r}-total`,\n        hiddenClass: `${r}-hidden`,\n        progressbarFillClass: `${r}-progressbar-fill`,\n        progressbarOppositeClass: `${r}-progressbar-opposite`,\n        clickableClass: `${r}-clickable`,\n        lockClass: `${r}-lock`,\n        horizontalClass: `${r}-horizontal`,\n        verticalClass: `${r}-vertical`,\n        paginationDisabledClass: `${r}-disabled`\n      }\n    }), t.pagination = {\n      el: null,\n      $el: null,\n      bullets: []\n    };\n    let l = 0;\n    function o() {\n      return !t.params.pagination.el || !t.pagination.el || !t.pagination.$el || 0 === t.pagination.$el.length;\n    }\n    function c(e, s) {\n      const {\n        bulletActiveClass: a\n      } = t.params.pagination;\n      e[s]().addClass(`${a}-${s}`)[s]().addClass(`${a}-${s}-${s}`);\n    }\n    function p() {\n      const e = t.rtl,\n        s = t.params.pagination;\n      if (o()) return;\n      const a = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,\n        r = t.pagination.$el;\n      let p;\n      const u = t.params.loop ? Math.ceil((a - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length;\n      if (t.params.loop ? (p = Math.ceil((t.activeIndex - t.loopedSlides) / t.params.slidesPerGroup), p > a - 1 - 2 * t.loopedSlides && (p -= a - 2 * t.loopedSlides), p > u - 1 && (p -= u), p < 0 && \"bullets\" !== t.params.paginationType && (p = u + p)) : p = void 0 !== t.snapIndex ? t.snapIndex : t.activeIndex || 0, \"bullets\" === s.type && t.pagination.bullets && t.pagination.bullets.length > 0) {\n        const a = t.pagination.bullets;\n        let i, o, u;\n        if (s.dynamicBullets && (n = a.eq(0)[t.isHorizontal() ? \"outerWidth\" : \"outerHeight\"](!0), r.css(t.isHorizontal() ? \"width\" : \"height\", n * (s.dynamicMainBullets + 4) + \"px\"), s.dynamicMainBullets > 1 && void 0 !== t.previousIndex && (l += p - (t.previousIndex - t.loopedSlides || 0), l > s.dynamicMainBullets - 1 ? l = s.dynamicMainBullets - 1 : l < 0 && (l = 0)), i = Math.max(p - l, 0), o = i + (Math.min(a.length, s.dynamicMainBullets) - 1), u = (o + i) / 2), a.removeClass([\"\", \"-next\", \"-next-next\", \"-prev\", \"-prev-prev\", \"-main\"].map(e => `${s.bulletActiveClass}${e}`).join(\" \")), r.length > 1) a.each(e => {\n          const t = d(e),\n            a = t.index();\n          a === p && t.addClass(s.bulletActiveClass), s.dynamicBullets && (a >= i && a <= o && t.addClass(`${s.bulletActiveClass}-main`), a === i && c(t, \"prev\"), a === o && c(t, \"next\"));\n        });else {\n          const e = a.eq(p),\n            r = e.index();\n          if (e.addClass(s.bulletActiveClass), s.dynamicBullets) {\n            const e = a.eq(i),\n              n = a.eq(o);\n            for (let e = i; e <= o; e += 1) a.eq(e).addClass(`${s.bulletActiveClass}-main`);\n            if (t.params.loop) {\n              if (r >= a.length) {\n                for (let e = s.dynamicMainBullets; e >= 0; e -= 1) a.eq(a.length - e).addClass(`${s.bulletActiveClass}-main`);\n                a.eq(a.length - s.dynamicMainBullets - 1).addClass(`${s.bulletActiveClass}-prev`);\n              } else c(e, \"prev\"), c(n, \"next\");\n            } else c(e, \"prev\"), c(n, \"next\");\n          }\n        }\n        if (s.dynamicBullets) {\n          const i = Math.min(a.length, s.dynamicMainBullets + 4),\n            r = (n * i - n) / 2 - u * n,\n            l = e ? \"right\" : \"left\";\n          a.css(t.isHorizontal() ? l : \"top\", `${r}px`);\n        }\n      }\n      if (\"fraction\" === s.type && (r.find(U(s.currentClass)).text(s.formatFractionCurrent(p + 1)), r.find(U(s.totalClass)).text(s.formatFractionTotal(u))), \"progressbar\" === s.type) {\n        let e;\n        e = s.progressbarOpposite ? t.isHorizontal() ? \"vertical\" : \"horizontal\" : t.isHorizontal() ? \"horizontal\" : \"vertical\";\n        const a = (p + 1) / u;\n        let i = 1,\n          n = 1;\n        \"horizontal\" === e ? i = a : n = a, r.find(U(s.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${i}) scaleY(${n})`).transition(t.params.speed);\n      }\n      \"custom\" === s.type && s.renderCustom ? (r.html(s.renderCustom(t, p + 1, u)), i(\"paginationRender\", r[0])) : i(\"paginationUpdate\", r[0]), t.params.watchOverflow && t.enabled && r[t.isLocked ? \"addClass\" : \"removeClass\"](s.lockClass);\n    }\n    function u() {\n      const e = t.params.pagination;\n      if (o()) return;\n      const s = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,\n        a = t.pagination.$el;\n      let r = \"\";\n      if (\"bullets\" === e.type) {\n        let i = t.params.loop ? Math.ceil((s - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length;\n        t.params.freeMode && t.params.freeMode.enabled && !t.params.loop && i > s && (i = s);\n        for (let s = 0; s < i; s += 1) e.renderBullet ? r += e.renderBullet.call(t, s, e.bulletClass) : r += `<${e.bulletElement} class=\"${e.bulletClass}\"></${e.bulletElement}>`;\n        a.html(r), t.pagination.bullets = a.find(U(e.bulletClass));\n      }\n      \"fraction\" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class=\"${e.currentClass}\"></span> / <span class=\"${e.totalClass}\"></span>`, a.html(r)), \"progressbar\" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class=\"${e.progressbarFillClass}\"></span>`, a.html(r)), \"custom\" !== e.type && i(\"paginationRender\", t.pagination.$el[0]);\n    }\n    function h() {\n      t.params.pagination = F(t, t.originalParams.pagination, t.params.pagination, {\n        el: \"swiper-pagination\"\n      });\n      const e = t.params.pagination;\n      if (!e.el) return;\n      let s = d(e.el);\n      0 !== s.length && (t.params.uniqueNavElements && \"string\" == typeof e.el && s.length > 1 && (s = t.$el.find(e.el), s.length > 1 && (s = s.filter(e => d(e).parents(\".swiper\")[0] === t.el))), \"bullets\" === e.type && e.clickable && s.addClass(e.clickableClass), s.addClass(e.modifierClass + e.type), s.addClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), \"bullets\" === e.type && e.dynamicBullets && (s.addClass(`${e.modifierClass}${e.type}-dynamic`), l = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), \"progressbar\" === e.type && e.progressbarOpposite && s.addClass(e.progressbarOppositeClass), e.clickable && s.on(\"click\", U(e.bulletClass), function (e) {\n        e.preventDefault();\n        let s = d(this).index() * t.params.slidesPerGroup;\n        t.params.loop && (s += t.loopedSlides), t.slideTo(s);\n      }), Object.assign(t.pagination, {\n        $el: s,\n        el: s[0]\n      }), t.enabled || s.addClass(e.lockClass));\n    }\n    function m() {\n      const e = t.params.pagination;\n      if (o()) return;\n      const s = t.pagination.$el;\n      s.removeClass(e.hiddenClass), s.removeClass(e.modifierClass + e.type), s.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.pagination.bullets && t.pagination.bullets.removeClass && t.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && s.off(\"click\", U(e.bulletClass));\n    }\n    a(\"init\", () => {\n      !1 === t.params.pagination.enabled ? f() : (h(), u(), p());\n    }), a(\"activeIndexChange\", () => {\n      (t.params.loop || void 0 === t.snapIndex) && p();\n    }), a(\"snapIndexChange\", () => {\n      t.params.loop || p();\n    }), a(\"slidesLengthChange\", () => {\n      t.params.loop && (u(), p());\n    }), a(\"snapGridLengthChange\", () => {\n      t.params.loop || (u(), p());\n    }), a(\"destroy\", () => {\n      m();\n    }), a(\"enable disable\", () => {\n      const {\n        $el: e\n      } = t.pagination;\n      e && e[t.enabled ? \"removeClass\" : \"addClass\"](t.params.pagination.lockClass);\n    }), a(\"lock unlock\", () => {\n      p();\n    }), a(\"click\", (e, s) => {\n      const a = s.target,\n        {\n          $el: r\n        } = t.pagination;\n      if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !d(a).hasClass(t.params.pagination.bulletClass)) {\n        if (t.navigation && (t.navigation.nextEl && a === t.navigation.nextEl || t.navigation.prevEl && a === t.navigation.prevEl)) return;\n        const e = r.hasClass(t.params.pagination.hiddenClass);\n        i(!0 === e ? \"paginationShow\" : \"paginationHide\"), r.toggleClass(t.params.pagination.hiddenClass);\n      }\n    });\n    const f = () => {\n      t.$el.addClass(t.params.pagination.paginationDisabledClass), t.pagination.$el && t.pagination.$el.addClass(t.params.pagination.paginationDisabledClass), m();\n    };\n    Object.assign(t.pagination, {\n      enable: () => {\n        t.$el.removeClass(t.params.pagination.paginationDisabledClass), t.pagination.$el && t.pagination.$el.removeClass(t.params.pagination.paginationDisabledClass), h(), u(), p();\n      },\n      disable: f,\n      render: u,\n      update: p,\n      init: h,\n      destroy: m\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: i,\n      emit: r\n    } = e;\n    const n = a();\n    let l,\n      o,\n      c,\n      u,\n      h = !1,\n      m = null,\n      f = null;\n    function g() {\n      if (!t.params.scrollbar.el || !t.scrollbar.el) return;\n      const {\n          scrollbar: e,\n          rtlTranslate: s,\n          progress: a\n        } = t,\n        {\n          $dragEl: i,\n          $el: r\n        } = e,\n        n = t.params.scrollbar;\n      let l = o,\n        d = (c - o) * a;\n      s ? (d = -d, d > 0 ? (l = o - d, d = 0) : -d + o > c && (l = c + d)) : d < 0 ? (l = o + d, d = 0) : d + o > c && (l = c - d), t.isHorizontal() ? (i.transform(`translate3d(${d}px, 0, 0)`), i[0].style.width = `${l}px`) : (i.transform(`translate3d(0px, ${d}px, 0)`), i[0].style.height = `${l}px`), n.hide && (clearTimeout(m), r[0].style.opacity = 1, m = setTimeout(() => {\n        r[0].style.opacity = 0, r.transition(400);\n      }, 1e3));\n    }\n    function v() {\n      if (!t.params.scrollbar.el || !t.scrollbar.el) return;\n      const {\n          scrollbar: e\n        } = t,\n        {\n          $dragEl: s,\n          $el: a\n        } = e;\n      s[0].style.width = \"\", s[0].style.height = \"\", c = t.isHorizontal() ? a[0].offsetWidth : a[0].offsetHeight, u = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), o = \"auto\" === t.params.scrollbar.dragSize ? c * u : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? s[0].style.width = `${o}px` : s[0].style.height = `${o}px`, a[0].style.display = u >= 1 ? \"none\" : \"\", t.params.scrollbar.hide && (a[0].style.opacity = 0), t.params.watchOverflow && t.enabled && e.$el[t.isLocked ? \"addClass\" : \"removeClass\"](t.params.scrollbar.lockClass);\n    }\n    function w(e) {\n      return t.isHorizontal() ? \"touchstart\" === e.type || \"touchmove\" === e.type ? e.targetTouches[0].clientX : e.clientX : \"touchstart\" === e.type || \"touchmove\" === e.type ? e.targetTouches[0].clientY : e.clientY;\n    }\n    function b(e) {\n      const {\n          scrollbar: s,\n          rtlTranslate: a\n        } = t,\n        {\n          $el: i\n        } = s;\n      let r;\n      r = (w(e) - i.offset()[t.isHorizontal() ? \"left\" : \"top\"] - (null !== l ? l : o / 2)) / (c - o), r = Math.max(Math.min(r, 1), 0), a && (r = 1 - r);\n      const n = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * r;\n      t.updateProgress(n), t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses();\n    }\n    function x(e) {\n      const s = t.params.scrollbar,\n        {\n          scrollbar: a,\n          $wrapperEl: i\n        } = t,\n        {\n          $el: n,\n          $dragEl: o\n        } = a;\n      h = !0, l = e.target === o[0] || e.target === o ? w(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? \"left\" : \"top\"] : null, e.preventDefault(), e.stopPropagation(), i.transition(100), o.transition(100), b(e), clearTimeout(f), n.transition(0), s.hide && n.css(\"opacity\", 1), t.params.cssMode && t.$wrapperEl.css(\"scroll-snap-type\", \"none\"), r(\"scrollbarDragStart\", e);\n    }\n    function y(e) {\n      const {\n          scrollbar: s,\n          $wrapperEl: a\n        } = t,\n        {\n          $el: i,\n          $dragEl: n\n        } = s;\n      h && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, b(e), a.transition(0), i.transition(0), n.transition(0), r(\"scrollbarDragMove\", e));\n    }\n    function E(e) {\n      const s = t.params.scrollbar,\n        {\n          scrollbar: a,\n          $wrapperEl: i\n        } = t,\n        {\n          $el: n\n        } = a;\n      h && (h = !1, t.params.cssMode && (t.$wrapperEl.css(\"scroll-snap-type\", \"\"), i.transition(\"\")), s.hide && (clearTimeout(f), f = p(() => {\n        n.css(\"opacity\", 0), n.transition(400);\n      }, 1e3)), r(\"scrollbarDragEnd\", e), s.snapOnRelease && t.slideToClosest());\n    }\n    function C(e) {\n      const {\n          scrollbar: s,\n          touchEventsTouch: a,\n          touchEventsDesktop: i,\n          params: r,\n          support: l\n        } = t,\n        o = s.$el;\n      if (!o) return;\n      const d = o[0],\n        c = !(!l.passiveListener || !r.passiveListeners) && {\n          passive: !1,\n          capture: !1\n        },\n        p = !(!l.passiveListener || !r.passiveListeners) && {\n          passive: !0,\n          capture: !1\n        };\n      if (!d) return;\n      const u = \"on\" === e ? \"addEventListener\" : \"removeEventListener\";\n      l.touch ? (d[u](a.start, x, c), d[u](a.move, y, c), d[u](a.end, E, p)) : (d[u](i.start, x, c), n[u](i.move, y, c), n[u](i.end, E, p));\n    }\n    function T() {\n      const {\n        scrollbar: e,\n        $el: s\n      } = t;\n      t.params.scrollbar = F(t, t.originalParams.scrollbar, t.params.scrollbar, {\n        el: \"swiper-scrollbar\"\n      });\n      const a = t.params.scrollbar;\n      if (!a.el) return;\n      let i = d(a.el);\n      t.params.uniqueNavElements && \"string\" == typeof a.el && i.length > 1 && 1 === s.find(a.el).length && (i = s.find(a.el)), i.addClass(t.isHorizontal() ? a.horizontalClass : a.verticalClass);\n      let r = i.find(`.${t.params.scrollbar.dragClass}`);\n      0 === r.length && (r = d(`<div class=\"${t.params.scrollbar.dragClass}\"></div>`), i.append(r)), Object.assign(e, {\n        $el: i,\n        el: i[0],\n        $dragEl: r,\n        dragEl: r[0]\n      }), a.draggable && t.params.scrollbar.el && t.scrollbar.el && C(\"on\"), i && i[t.enabled ? \"removeClass\" : \"addClass\"](t.params.scrollbar.lockClass);\n    }\n    function $() {\n      const e = t.params.scrollbar,\n        s = t.scrollbar.$el;\n      s && s.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.params.scrollbar.el && t.scrollbar.el && C(\"off\");\n    }\n    s({\n      scrollbar: {\n        el: null,\n        dragSize: \"auto\",\n        hide: !1,\n        draggable: !1,\n        snapOnRelease: !0,\n        lockClass: \"swiper-scrollbar-lock\",\n        dragClass: \"swiper-scrollbar-drag\",\n        scrollbarDisabledClass: \"swiper-scrollbar-disabled\",\n        horizontalClass: \"swiper-scrollbar-horizontal\",\n        verticalClass: \"swiper-scrollbar-vertical\"\n      }\n    }), t.scrollbar = {\n      el: null,\n      dragEl: null,\n      $el: null,\n      $dragEl: null\n    }, i(\"init\", () => {\n      !1 === t.params.scrollbar.enabled ? S() : (T(), v(), g());\n    }), i(\"update resize observerUpdate lock unlock\", () => {\n      v();\n    }), i(\"setTranslate\", () => {\n      g();\n    }), i(\"setTransition\", (e, s) => {\n      !function (e) {\n        t.params.scrollbar.el && t.scrollbar.el && t.scrollbar.$dragEl.transition(e);\n      }(s);\n    }), i(\"enable disable\", () => {\n      const {\n        $el: e\n      } = t.scrollbar;\n      e && e[t.enabled ? \"removeClass\" : \"addClass\"](t.params.scrollbar.lockClass);\n    }), i(\"destroy\", () => {\n      $();\n    });\n    const S = () => {\n      t.$el.addClass(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.$el && t.scrollbar.$el.addClass(t.params.scrollbar.scrollbarDisabledClass), $();\n    };\n    Object.assign(t.scrollbar, {\n      enable: () => {\n        t.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.$el && t.scrollbar.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass), T(), v(), g();\n      },\n      disable: S,\n      updateSize: v,\n      setTranslate: g,\n      init: T,\n      destroy: $\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a\n    } = e;\n    s({\n      parallax: {\n        enabled: !1\n      }\n    });\n    const i = (e, s) => {\n        const {\n            rtl: a\n          } = t,\n          i = d(e),\n          r = a ? -1 : 1,\n          n = i.attr(\"data-swiper-parallax\") || \"0\";\n        let l = i.attr(\"data-swiper-parallax-x\"),\n          o = i.attr(\"data-swiper-parallax-y\");\n        const c = i.attr(\"data-swiper-parallax-scale\"),\n          p = i.attr(\"data-swiper-parallax-opacity\");\n        if (l || o ? (l = l || \"0\", o = o || \"0\") : t.isHorizontal() ? (l = n, o = \"0\") : (o = n, l = \"0\"), l = l.indexOf(\"%\") >= 0 ? parseInt(l, 10) * s * r + \"%\" : l * s * r + \"px\", o = o.indexOf(\"%\") >= 0 ? parseInt(o, 10) * s + \"%\" : o * s + \"px\", null != p) {\n          const e = p - (p - 1) * (1 - Math.abs(s));\n          i[0].style.opacity = e;\n        }\n        if (null == c) i.transform(`translate3d(${l}, ${o}, 0px)`);else {\n          const e = c - (c - 1) * (1 - Math.abs(s));\n          i.transform(`translate3d(${l}, ${o}, 0px) scale(${e})`);\n        }\n      },\n      r = () => {\n        const {\n          $el: e,\n          slides: s,\n          progress: a,\n          snapGrid: r\n        } = t;\n        e.children(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").each(e => {\n          i(e, a);\n        }), s.each((e, s) => {\n          let n = e.progress;\n          t.params.slidesPerGroup > 1 && \"auto\" !== t.params.slidesPerView && (n += Math.ceil(s / 2) - a * (r.length - 1)), n = Math.min(Math.max(n, -1), 1), d(e).find(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").each(e => {\n            i(e, n);\n          });\n        });\n      };\n    a(\"beforeInit\", () => {\n      t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0);\n    }), a(\"init\", () => {\n      t.params.parallax.enabled && r();\n    }), a(\"setTranslate\", () => {\n      t.params.parallax.enabled && r();\n    }), a(\"setTransition\", (e, s) => {\n      t.params.parallax.enabled && function (e) {\n        void 0 === e && (e = t.params.speed);\n        const {\n          $el: s\n        } = t;\n        s.find(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").each(t => {\n          const s = d(t);\n          let a = parseInt(s.attr(\"data-swiper-parallax-duration\"), 10) || e;\n          0 === e && (a = 0), s.transition(a);\n        });\n      }(s);\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a,\n      emit: i\n    } = e;\n    const n = r();\n    s({\n      zoom: {\n        enabled: !1,\n        maxRatio: 3,\n        minRatio: 1,\n        toggle: !0,\n        containerClass: \"swiper-zoom-container\",\n        zoomedSlideClass: \"swiper-slide-zoomed\"\n      }\n    }), t.zoom = {\n      enabled: !1\n    };\n    let l,\n      o,\n      c,\n      p = 1,\n      u = !1;\n    const m = {\n        $slideEl: void 0,\n        slideWidth: void 0,\n        slideHeight: void 0,\n        $imageEl: void 0,\n        $imageWrapEl: void 0,\n        maxRatio: 3\n      },\n      f = {\n        isTouched: void 0,\n        isMoved: void 0,\n        currentX: void 0,\n        currentY: void 0,\n        minX: void 0,\n        minY: void 0,\n        maxX: void 0,\n        maxY: void 0,\n        width: void 0,\n        height: void 0,\n        startX: void 0,\n        startY: void 0,\n        touchesStart: {},\n        touchesCurrent: {}\n      },\n      g = {\n        x: void 0,\n        y: void 0,\n        prevPositionX: void 0,\n        prevPositionY: void 0,\n        prevTime: void 0\n      };\n    let v = 1;\n    function w(e) {\n      if (e.targetTouches.length < 2) return 1;\n      const t = e.targetTouches[0].pageX,\n        s = e.targetTouches[0].pageY,\n        a = e.targetTouches[1].pageX,\n        i = e.targetTouches[1].pageY;\n      return Math.sqrt((a - t) ** 2 + (i - s) ** 2);\n    }\n    function b(e) {\n      const s = t.support,\n        a = t.params.zoom;\n      if (o = !1, c = !1, !s.gestures) {\n        if (\"touchstart\" !== e.type || \"touchstart\" === e.type && e.targetTouches.length < 2) return;\n        o = !0, m.scaleStart = w(e);\n      }\n      m.$slideEl && m.$slideEl.length || (m.$slideEl = d(e.target).closest(`.${t.params.slideClass}`), 0 === m.$slideEl.length && (m.$slideEl = t.slides.eq(t.activeIndex)), m.$imageEl = m.$slideEl.find(`.${a.containerClass}`).eq(0).find(\"picture, img, svg, canvas, .swiper-zoom-target\").eq(0), m.$imageWrapEl = m.$imageEl.parent(`.${a.containerClass}`), m.maxRatio = m.$imageWrapEl.attr(\"data-swiper-zoom\") || a.maxRatio, 0 !== m.$imageWrapEl.length) ? (m.$imageEl && m.$imageEl.transition(0), u = !0) : m.$imageEl = void 0;\n    }\n    function x(e) {\n      const s = t.support,\n        a = t.params.zoom,\n        i = t.zoom;\n      if (!s.gestures) {\n        if (\"touchmove\" !== e.type || \"touchmove\" === e.type && e.targetTouches.length < 2) return;\n        c = !0, m.scaleMove = w(e);\n      }\n      m.$imageEl && 0 !== m.$imageEl.length ? (s.gestures ? i.scale = e.scale * p : i.scale = m.scaleMove / m.scaleStart * p, i.scale > m.maxRatio && (i.scale = m.maxRatio - 1 + (i.scale - m.maxRatio + 1) ** .5), i.scale < a.minRatio && (i.scale = a.minRatio + 1 - (a.minRatio - i.scale + 1) ** .5), m.$imageEl.transform(`translate3d(0,0,0) scale(${i.scale})`)) : \"gesturechange\" === e.type && b(e);\n    }\n    function y(e) {\n      const s = t.device,\n        a = t.support,\n        i = t.params.zoom,\n        r = t.zoom;\n      if (!a.gestures) {\n        if (!o || !c) return;\n        if (\"touchend\" !== e.type || \"touchend\" === e.type && e.changedTouches.length < 2 && !s.android) return;\n        o = !1, c = !1;\n      }\n      m.$imageEl && 0 !== m.$imageEl.length && (r.scale = Math.max(Math.min(r.scale, m.maxRatio), i.minRatio), m.$imageEl.transition(t.params.speed).transform(`translate3d(0,0,0) scale(${r.scale})`), p = r.scale, u = !1, 1 === r.scale && (m.$slideEl = void 0));\n    }\n    function E(e) {\n      const s = t.zoom;\n      if (!m.$imageEl || 0 === m.$imageEl.length) return;\n      if (t.allowClick = !1, !f.isTouched || !m.$slideEl) return;\n      f.isMoved || (f.width = m.$imageEl[0].offsetWidth, f.height = m.$imageEl[0].offsetHeight, f.startX = h(m.$imageWrapEl[0], \"x\") || 0, f.startY = h(m.$imageWrapEl[0], \"y\") || 0, m.slideWidth = m.$slideEl[0].offsetWidth, m.slideHeight = m.$slideEl[0].offsetHeight, m.$imageWrapEl.transition(0));\n      const a = f.width * s.scale,\n        i = f.height * s.scale;\n      if (!(a < m.slideWidth && i < m.slideHeight)) {\n        if (f.minX = Math.min(m.slideWidth / 2 - a / 2, 0), f.maxX = -f.minX, f.minY = Math.min(m.slideHeight / 2 - i / 2, 0), f.maxY = -f.minY, f.touchesCurrent.x = \"touchmove\" === e.type ? e.targetTouches[0].pageX : e.pageX, f.touchesCurrent.y = \"touchmove\" === e.type ? e.targetTouches[0].pageY : e.pageY, !f.isMoved && !u) {\n          if (t.isHorizontal() && (Math.floor(f.minX) === Math.floor(f.startX) && f.touchesCurrent.x < f.touchesStart.x || Math.floor(f.maxX) === Math.floor(f.startX) && f.touchesCurrent.x > f.touchesStart.x)) return void (f.isTouched = !1);\n          if (!t.isHorizontal() && (Math.floor(f.minY) === Math.floor(f.startY) && f.touchesCurrent.y < f.touchesStart.y || Math.floor(f.maxY) === Math.floor(f.startY) && f.touchesCurrent.y > f.touchesStart.y)) return void (f.isTouched = !1);\n        }\n        e.cancelable && e.preventDefault(), e.stopPropagation(), f.isMoved = !0, f.currentX = f.touchesCurrent.x - f.touchesStart.x + f.startX, f.currentY = f.touchesCurrent.y - f.touchesStart.y + f.startY, f.currentX < f.minX && (f.currentX = f.minX + 1 - (f.minX - f.currentX + 1) ** .8), f.currentX > f.maxX && (f.currentX = f.maxX - 1 + (f.currentX - f.maxX + 1) ** .8), f.currentY < f.minY && (f.currentY = f.minY + 1 - (f.minY - f.currentY + 1) ** .8), f.currentY > f.maxY && (f.currentY = f.maxY - 1 + (f.currentY - f.maxY + 1) ** .8), g.prevPositionX || (g.prevPositionX = f.touchesCurrent.x), g.prevPositionY || (g.prevPositionY = f.touchesCurrent.y), g.prevTime || (g.prevTime = Date.now()), g.x = (f.touchesCurrent.x - g.prevPositionX) / (Date.now() - g.prevTime) / 2, g.y = (f.touchesCurrent.y - g.prevPositionY) / (Date.now() - g.prevTime) / 2, Math.abs(f.touchesCurrent.x - g.prevPositionX) < 2 && (g.x = 0), Math.abs(f.touchesCurrent.y - g.prevPositionY) < 2 && (g.y = 0), g.prevPositionX = f.touchesCurrent.x, g.prevPositionY = f.touchesCurrent.y, g.prevTime = Date.now(), m.$imageWrapEl.transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`);\n      }\n    }\n    function C() {\n      const e = t.zoom;\n      m.$slideEl && t.previousIndex !== t.activeIndex && (m.$imageEl && m.$imageEl.transform(\"translate3d(0,0,0) scale(1)\"), m.$imageWrapEl && m.$imageWrapEl.transform(\"translate3d(0,0,0)\"), e.scale = 1, p = 1, m.$slideEl = void 0, m.$imageEl = void 0, m.$imageWrapEl = void 0);\n    }\n    function T(e) {\n      const s = t.zoom,\n        a = t.params.zoom;\n      if (m.$slideEl || (e && e.target && (m.$slideEl = d(e.target).closest(`.${t.params.slideClass}`)), m.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? m.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : m.$slideEl = t.slides.eq(t.activeIndex)), m.$imageEl = m.$slideEl.find(`.${a.containerClass}`).eq(0).find(\"picture, img, svg, canvas, .swiper-zoom-target\").eq(0), m.$imageWrapEl = m.$imageEl.parent(`.${a.containerClass}`)), !m.$imageEl || 0 === m.$imageEl.length || !m.$imageWrapEl || 0 === m.$imageWrapEl.length) return;\n      let i, r, l, o, c, u, h, g, v, w, b, x, y, E, C, T, $, S;\n      t.params.cssMode && (t.wrapperEl.style.overflow = \"hidden\", t.wrapperEl.style.touchAction = \"none\"), m.$slideEl.addClass(`${a.zoomedSlideClass}`), void 0 === f.touchesStart.x && e ? (i = \"touchend\" === e.type ? e.changedTouches[0].pageX : e.pageX, r = \"touchend\" === e.type ? e.changedTouches[0].pageY : e.pageY) : (i = f.touchesStart.x, r = f.touchesStart.y), s.scale = m.$imageWrapEl.attr(\"data-swiper-zoom\") || a.maxRatio, p = m.$imageWrapEl.attr(\"data-swiper-zoom\") || a.maxRatio, e ? ($ = m.$slideEl[0].offsetWidth, S = m.$slideEl[0].offsetHeight, l = m.$slideEl.offset().left + n.scrollX, o = m.$slideEl.offset().top + n.scrollY, c = l + $ / 2 - i, u = o + S / 2 - r, v = m.$imageEl[0].offsetWidth, w = m.$imageEl[0].offsetHeight, b = v * s.scale, x = w * s.scale, y = Math.min($ / 2 - b / 2, 0), E = Math.min(S / 2 - x / 2, 0), C = -y, T = -E, h = c * s.scale, g = u * s.scale, h < y && (h = y), h > C && (h = C), g < E && (g = E), g > T && (g = T)) : (h = 0, g = 0), m.$imageWrapEl.transition(300).transform(`translate3d(${h}px, ${g}px,0)`), m.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${s.scale})`);\n    }\n    function $() {\n      const e = t.zoom,\n        s = t.params.zoom;\n      m.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? m.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : m.$slideEl = t.slides.eq(t.activeIndex), m.$imageEl = m.$slideEl.find(`.${s.containerClass}`).eq(0).find(\"picture, img, svg, canvas, .swiper-zoom-target\").eq(0), m.$imageWrapEl = m.$imageEl.parent(`.${s.containerClass}`)), m.$imageEl && 0 !== m.$imageEl.length && m.$imageWrapEl && 0 !== m.$imageWrapEl.length && (t.params.cssMode && (t.wrapperEl.style.overflow = \"\", t.wrapperEl.style.touchAction = \"\"), e.scale = 1, p = 1, m.$imageWrapEl.transition(300).transform(\"translate3d(0,0,0)\"), m.$imageEl.transition(300).transform(\"translate3d(0,0,0) scale(1)\"), m.$slideEl.removeClass(`${s.zoomedSlideClass}`), m.$slideEl = void 0);\n    }\n    function S(e) {\n      const s = t.zoom;\n      s.scale && 1 !== s.scale ? $() : T(e);\n    }\n    function M() {\n      const e = t.support;\n      return {\n        passiveListener: !(\"touchstart\" !== t.touchEvents.start || !e.passiveListener || !t.params.passiveListeners) && {\n          passive: !0,\n          capture: !1\n        },\n        activeListenerWithCapture: !e.passiveListener || {\n          passive: !1,\n          capture: !0\n        }\n      };\n    }\n    function P() {\n      return `.${t.params.slideClass}`;\n    }\n    function k(e) {\n      const {\n          passiveListener: s\n        } = M(),\n        a = P();\n      t.$wrapperEl[e](\"gesturestart\", a, b, s), t.$wrapperEl[e](\"gesturechange\", a, x, s), t.$wrapperEl[e](\"gestureend\", a, y, s);\n    }\n    function z() {\n      l || (l = !0, k(\"on\"));\n    }\n    function L() {\n      l && (l = !1, k(\"off\"));\n    }\n    function O() {\n      const e = t.zoom;\n      if (e.enabled) return;\n      e.enabled = !0;\n      const s = t.support,\n        {\n          passiveListener: a,\n          activeListenerWithCapture: i\n        } = M(),\n        r = P();\n      s.gestures ? (t.$wrapperEl.on(t.touchEvents.start, z, a), t.$wrapperEl.on(t.touchEvents.end, L, a)) : \"touchstart\" === t.touchEvents.start && (t.$wrapperEl.on(t.touchEvents.start, r, b, a), t.$wrapperEl.on(t.touchEvents.move, r, x, i), t.$wrapperEl.on(t.touchEvents.end, r, y, a), t.touchEvents.cancel && t.$wrapperEl.on(t.touchEvents.cancel, r, y, a)), t.$wrapperEl.on(t.touchEvents.move, `.${t.params.zoom.containerClass}`, E, i);\n    }\n    function I() {\n      const e = t.zoom;\n      if (!e.enabled) return;\n      const s = t.support;\n      e.enabled = !1;\n      const {\n          passiveListener: a,\n          activeListenerWithCapture: i\n        } = M(),\n        r = P();\n      s.gestures ? (t.$wrapperEl.off(t.touchEvents.start, z, a), t.$wrapperEl.off(t.touchEvents.end, L, a)) : \"touchstart\" === t.touchEvents.start && (t.$wrapperEl.off(t.touchEvents.start, r, b, a), t.$wrapperEl.off(t.touchEvents.move, r, x, i), t.$wrapperEl.off(t.touchEvents.end, r, y, a), t.touchEvents.cancel && t.$wrapperEl.off(t.touchEvents.cancel, r, y, a)), t.$wrapperEl.off(t.touchEvents.move, `.${t.params.zoom.containerClass}`, E, i);\n    }\n    Object.defineProperty(t.zoom, \"scale\", {\n      get: () => v,\n      set(e) {\n        if (v !== e) {\n          const t = m.$imageEl ? m.$imageEl[0] : void 0,\n            s = m.$slideEl ? m.$slideEl[0] : void 0;\n          i(\"zoomChange\", e, t, s);\n        }\n        v = e;\n      }\n    }), a(\"init\", () => {\n      t.params.zoom.enabled && O();\n    }), a(\"destroy\", () => {\n      I();\n    }), a(\"touchStart\", (e, s) => {\n      t.zoom.enabled && function (e) {\n        const s = t.device;\n        m.$imageEl && 0 !== m.$imageEl.length && (f.isTouched || (s.android && e.cancelable && e.preventDefault(), f.isTouched = !0, f.touchesStart.x = \"touchstart\" === e.type ? e.targetTouches[0].pageX : e.pageX, f.touchesStart.y = \"touchstart\" === e.type ? e.targetTouches[0].pageY : e.pageY));\n      }(s);\n    }), a(\"touchEnd\", (e, s) => {\n      t.zoom.enabled && function () {\n        const e = t.zoom;\n        if (!m.$imageEl || 0 === m.$imageEl.length) return;\n        if (!f.isTouched || !f.isMoved) return f.isTouched = !1, void (f.isMoved = !1);\n        f.isTouched = !1, f.isMoved = !1;\n        let s = 300,\n          a = 300;\n        const i = g.x * s,\n          r = f.currentX + i,\n          n = g.y * a,\n          l = f.currentY + n;\n        0 !== g.x && (s = Math.abs((r - f.currentX) / g.x)), 0 !== g.y && (a = Math.abs((l - f.currentY) / g.y));\n        const o = Math.max(s, a);\n        f.currentX = r, f.currentY = l;\n        const d = f.width * e.scale,\n          c = f.height * e.scale;\n        f.minX = Math.min(m.slideWidth / 2 - d / 2, 0), f.maxX = -f.minX, f.minY = Math.min(m.slideHeight / 2 - c / 2, 0), f.maxY = -f.minY, f.currentX = Math.max(Math.min(f.currentX, f.maxX), f.minX), f.currentY = Math.max(Math.min(f.currentY, f.maxY), f.minY), m.$imageWrapEl.transition(o).transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`);\n      }();\n    }), a(\"doubleTap\", (e, s) => {\n      !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && S(s);\n    }), a(\"transitionEnd\", () => {\n      t.zoom.enabled && t.params.zoom.enabled && C();\n    }), a(\"slideChange\", () => {\n      t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && C();\n    }), Object.assign(t.zoom, {\n      enable: O,\n      disable: I,\n      in: T,\n      out: $,\n      toggle: S\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a,\n      emit: i\n    } = e;\n    s({\n      lazy: {\n        checkInView: !1,\n        enabled: !1,\n        loadPrevNext: !1,\n        loadPrevNextAmount: 1,\n        loadOnTransitionStart: !1,\n        scrollingElement: \"\",\n        elementClass: \"swiper-lazy\",\n        loadingClass: \"swiper-lazy-loading\",\n        loadedClass: \"swiper-lazy-loaded\",\n        preloaderClass: \"swiper-lazy-preloader\"\n      }\n    }), t.lazy = {};\n    let n = !1,\n      l = !1;\n    function o(e, s) {\n      void 0 === s && (s = !0);\n      const a = t.params.lazy;\n      if (void 0 === e) return;\n      if (0 === t.slides.length) return;\n      const r = t.virtual && t.params.virtual.enabled ? t.$wrapperEl.children(`.${t.params.slideClass}[data-swiper-slide-index=\"${e}\"]`) : t.slides.eq(e),\n        n = r.find(`.${a.elementClass}:not(.${a.loadedClass}):not(.${a.loadingClass})`);\n      !r.hasClass(a.elementClass) || r.hasClass(a.loadedClass) || r.hasClass(a.loadingClass) || n.push(r[0]), 0 !== n.length && n.each(e => {\n        const n = d(e);\n        n.addClass(a.loadingClass);\n        const l = n.attr(\"data-background\"),\n          c = n.attr(\"data-src\"),\n          p = n.attr(\"data-srcset\"),\n          u = n.attr(\"data-sizes\"),\n          h = n.parent(\"picture\");\n        t.loadImage(n[0], c || l, p, u, !1, () => {\n          if (null != t && t && (!t || t.params) && !t.destroyed) {\n            if (l ? (n.css(\"background-image\", `url(\"${l}\")`), n.removeAttr(\"data-background\")) : (p && (n.attr(\"srcset\", p), n.removeAttr(\"data-srcset\")), u && (n.attr(\"sizes\", u), n.removeAttr(\"data-sizes\")), h.length && h.children(\"source\").each(e => {\n              const t = d(e);\n              t.attr(\"data-srcset\") && (t.attr(\"srcset\", t.attr(\"data-srcset\")), t.removeAttr(\"data-srcset\"));\n            }), c && (n.attr(\"src\", c), n.removeAttr(\"data-src\"))), n.addClass(a.loadedClass).removeClass(a.loadingClass), r.find(`.${a.preloaderClass}`).remove(), t.params.loop && s) {\n              const e = r.attr(\"data-swiper-slide-index\");\n              if (r.hasClass(t.params.slideDuplicateClass)) {\n                o(t.$wrapperEl.children(`[data-swiper-slide-index=\"${e}\"]:not(.${t.params.slideDuplicateClass})`).index(), !1);\n              } else {\n                o(t.$wrapperEl.children(`.${t.params.slideDuplicateClass}[data-swiper-slide-index=\"${e}\"]`).index(), !1);\n              }\n            }\n            i(\"lazyImageReady\", r[0], n[0]), t.params.autoHeight && t.updateAutoHeight();\n          }\n        }), i(\"lazyImageLoad\", r[0], n[0]);\n      });\n    }\n    function c() {\n      const {\n          $wrapperEl: e,\n          params: s,\n          slides: a,\n          activeIndex: i\n        } = t,\n        r = t.virtual && s.virtual.enabled,\n        n = s.lazy;\n      let c = s.slidesPerView;\n      function p(t) {\n        if (r) {\n          if (e.children(`.${s.slideClass}[data-swiper-slide-index=\"${t}\"]`).length) return !0;\n        } else if (a[t]) return !0;\n        return !1;\n      }\n      function u(e) {\n        return r ? d(e).attr(\"data-swiper-slide-index\") : d(e).index();\n      }\n      if (\"auto\" === c && (c = 0), l || (l = !0), t.params.watchSlidesProgress) e.children(`.${s.slideVisibleClass}`).each(e => {\n        o(r ? d(e).attr(\"data-swiper-slide-index\") : d(e).index());\n      });else if (c > 1) for (let e = i; e < i + c; e += 1) p(e) && o(e);else o(i);\n      if (n.loadPrevNext) if (c > 1 || n.loadPrevNextAmount && n.loadPrevNextAmount > 1) {\n        const e = n.loadPrevNextAmount,\n          t = Math.ceil(c),\n          s = Math.min(i + t + Math.max(e, t), a.length),\n          r = Math.max(i - Math.max(t, e), 0);\n        for (let e = i + t; e < s; e += 1) p(e) && o(e);\n        for (let e = r; e < i; e += 1) p(e) && o(e);\n      } else {\n        const t = e.children(`.${s.slideNextClass}`);\n        t.length > 0 && o(u(t));\n        const a = e.children(`.${s.slidePrevClass}`);\n        a.length > 0 && o(u(a));\n      }\n    }\n    function p() {\n      const e = r();\n      if (!t || t.destroyed) return;\n      const s = t.params.lazy.scrollingElement ? d(t.params.lazy.scrollingElement) : d(e),\n        a = s[0] === e,\n        i = a ? e.innerWidth : s[0].offsetWidth,\n        l = a ? e.innerHeight : s[0].offsetHeight,\n        o = t.$el.offset(),\n        {\n          rtlTranslate: u\n        } = t;\n      let h = !1;\n      u && (o.left -= t.$el[0].scrollLeft);\n      const m = [[o.left, o.top], [o.left + t.width, o.top], [o.left, o.top + t.height], [o.left + t.width, o.top + t.height]];\n      for (let e = 0; e < m.length; e += 1) {\n        const t = m[e];\n        if (t[0] >= 0 && t[0] <= i && t[1] >= 0 && t[1] <= l) {\n          if (0 === t[0] && 0 === t[1]) continue;\n          h = !0;\n        }\n      }\n      const f = !(\"touchstart\" !== t.touchEvents.start || !t.support.passiveListener || !t.params.passiveListeners) && {\n        passive: !0,\n        capture: !1\n      };\n      h ? (c(), s.off(\"scroll\", p, f)) : n || (n = !0, s.on(\"scroll\", p, f));\n    }\n    a(\"beforeInit\", () => {\n      t.params.lazy.enabled && t.params.preloadImages && (t.params.preloadImages = !1);\n    }), a(\"init\", () => {\n      t.params.lazy.enabled && (t.params.lazy.checkInView ? p() : c());\n    }), a(\"scroll\", () => {\n      t.params.freeMode && t.params.freeMode.enabled && !t.params.freeMode.sticky && c();\n    }), a(\"scrollbarDragMove resize _freeModeNoMomentumRelease\", () => {\n      t.params.lazy.enabled && (t.params.lazy.checkInView ? p() : c());\n    }), a(\"transitionStart\", () => {\n      t.params.lazy.enabled && (t.params.lazy.loadOnTransitionStart || !t.params.lazy.loadOnTransitionStart && !l) && (t.params.lazy.checkInView ? p() : c());\n    }), a(\"transitionEnd\", () => {\n      t.params.lazy.enabled && !t.params.lazy.loadOnTransitionStart && (t.params.lazy.checkInView ? p() : c());\n    }), a(\"slideChange\", () => {\n      const {\n        lazy: e,\n        cssMode: s,\n        watchSlidesProgress: a,\n        touchReleaseOnEdges: i,\n        resistanceRatio: r\n      } = t.params;\n      e.enabled && (s || a && (i || 0 === r)) && c();\n    }), a(\"destroy\", () => {\n      t.$el && t.$el.find(`.${t.params.lazy.loadingClass}`).removeClass(t.params.lazy.loadingClass);\n    }), Object.assign(t.lazy, {\n      load: c,\n      loadInSlide: o\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a\n    } = e;\n    function i(e, t) {\n      const s = function () {\n        let e, t, s;\n        return (a, i) => {\n          for (t = -1, e = a.length; e - t > 1;) s = e + t >> 1, a[s] <= i ? t = s : e = s;\n          return e;\n        };\n      }();\n      let a, i;\n      return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) {\n        return e ? (i = s(this.x, e), a = i - 1, (e - this.x[a]) * (this.y[i] - this.y[a]) / (this.x[i] - this.x[a]) + this.y[a]) : 0;\n      }, this;\n    }\n    function r() {\n      t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline);\n    }\n    s({\n      controller: {\n        control: void 0,\n        inverse: !1,\n        by: \"slide\"\n      }\n    }), t.controller = {\n      control: void 0\n    }, a(\"beforeInit\", () => {\n      t.controller.control = t.params.controller.control;\n    }), a(\"update\", () => {\n      r();\n    }), a(\"resize\", () => {\n      r();\n    }), a(\"observerUpdate\", () => {\n      r();\n    }), a(\"setTranslate\", (e, s, a) => {\n      t.controller.control && t.controller.setTranslate(s, a);\n    }), a(\"setTransition\", (e, s, a) => {\n      t.controller.control && t.controller.setTransition(s, a);\n    }), Object.assign(t.controller, {\n      setTranslate: function (e, s) {\n        const a = t.controller.control;\n        let r, n;\n        const l = t.constructor;\n        function o(e) {\n          const s = t.rtlTranslate ? -t.translate : t.translate;\n          \"slide\" === t.params.controller.by && (!function (e) {\n            t.controller.spline || (t.controller.spline = t.params.loop ? new i(t.slidesGrid, e.slidesGrid) : new i(t.snapGrid, e.snapGrid));\n          }(e), n = -t.controller.spline.interpolate(-s)), n && \"container\" !== t.params.controller.by || (r = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), n = (s - t.minTranslate()) * r + e.minTranslate()), t.params.controller.inverse && (n = e.maxTranslate() - n), e.updateProgress(n), e.setTranslate(n, t), e.updateActiveIndex(), e.updateSlidesClasses();\n        }\n        if (Array.isArray(a)) for (let e = 0; e < a.length; e += 1) a[e] !== s && a[e] instanceof l && o(a[e]);else a instanceof l && s !== a && o(a);\n      },\n      setTransition: function (e, s) {\n        const a = t.constructor,\n          i = t.controller.control;\n        let r;\n        function n(s) {\n          s.setTransition(e, t), 0 !== e && (s.transitionStart(), s.params.autoHeight && p(() => {\n            s.updateAutoHeight();\n          }), s.$wrapperEl.transitionEnd(() => {\n            i && (s.params.loop && \"slide\" === t.params.controller.by && s.loopFix(), s.transitionEnd());\n          }));\n        }\n        if (Array.isArray(i)) for (r = 0; r < i.length; r += 1) i[r] !== s && i[r] instanceof a && n(i[r]);else i instanceof a && s !== i && n(i);\n      }\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a\n    } = e;\n    s({\n      a11y: {\n        enabled: !0,\n        notificationClass: \"swiper-notification\",\n        prevSlideMessage: \"Previous slide\",\n        nextSlideMessage: \"Next slide\",\n        firstSlideMessage: \"This is the first slide\",\n        lastSlideMessage: \"This is the last slide\",\n        paginationBulletMessage: \"Go to slide {{index}}\",\n        slideLabelMessage: \"{{index}} / {{slidesLength}}\",\n        containerMessage: null,\n        containerRoleDescriptionMessage: null,\n        itemRoleDescriptionMessage: null,\n        slideRole: \"group\",\n        id: null\n      }\n    }), t.a11y = {\n      clicked: !1\n    };\n    let i = null;\n    function r(e) {\n      const t = i;\n      0 !== t.length && (t.html(\"\"), t.html(e));\n    }\n    function n(e) {\n      e.attr(\"tabIndex\", \"0\");\n    }\n    function l(e) {\n      e.attr(\"tabIndex\", \"-1\");\n    }\n    function o(e, t) {\n      e.attr(\"role\", t);\n    }\n    function c(e, t) {\n      e.attr(\"aria-roledescription\", t);\n    }\n    function p(e, t) {\n      e.attr(\"aria-label\", t);\n    }\n    function u(e) {\n      e.attr(\"aria-disabled\", !0);\n    }\n    function h(e) {\n      e.attr(\"aria-disabled\", !1);\n    }\n    function m(e) {\n      if (13 !== e.keyCode && 32 !== e.keyCode) return;\n      const s = t.params.a11y,\n        a = d(e.target);\n      t.navigation && t.navigation.$nextEl && a.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? r(s.lastSlideMessage) : r(s.nextSlideMessage)), t.navigation && t.navigation.$prevEl && a.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? r(s.firstSlideMessage) : r(s.prevSlideMessage)), t.pagination && a.is(U(t.params.pagination.bulletClass)) && a[0].click();\n    }\n    function f() {\n      return t.pagination && t.pagination.bullets && t.pagination.bullets.length;\n    }\n    function g() {\n      return f() && t.params.pagination.clickable;\n    }\n    const v = (e, t, s) => {\n        n(e), \"BUTTON\" !== e[0].tagName && (o(e, \"button\"), e.on(\"keydown\", m)), p(e, s), function (e, t) {\n          e.attr(\"aria-controls\", t);\n        }(e, t);\n      },\n      w = () => {\n        t.a11y.clicked = !0;\n      },\n      b = () => {\n        requestAnimationFrame(() => {\n          requestAnimationFrame(() => {\n            t.a11y.clicked = !1;\n          });\n        });\n      },\n      x = e => {\n        if (t.a11y.clicked) return;\n        const s = e.target.closest(`.${t.params.slideClass}`);\n        if (!s || !t.slides.includes(s)) return;\n        const a = t.slides.indexOf(s) === t.activeIndex,\n          i = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(s);\n        a || i || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, t.slideTo(t.slides.indexOf(s), 0));\n      },\n      y = () => {\n        const e = t.params.a11y;\n        e.itemRoleDescriptionMessage && c(d(t.slides), e.itemRoleDescriptionMessage), e.slideRole && o(d(t.slides), e.slideRole);\n        const s = t.params.loop ? t.slides.filter(e => !e.classList.contains(t.params.slideDuplicateClass)).length : t.slides.length;\n        e.slideLabelMessage && t.slides.each((a, i) => {\n          const r = d(a),\n            n = t.params.loop ? parseInt(r.attr(\"data-swiper-slide-index\"), 10) : i;\n          p(r, e.slideLabelMessage.replace(/\\{\\{index\\}\\}/, n + 1).replace(/\\{\\{slidesLength\\}\\}/, s));\n        });\n      },\n      E = () => {\n        const e = t.params.a11y;\n        t.$el.append(i);\n        const s = t.$el;\n        e.containerRoleDescriptionMessage && c(s, e.containerRoleDescriptionMessage), e.containerMessage && p(s, e.containerMessage);\n        const a = t.$wrapperEl,\n          r = e.id || a.attr(\"id\") || `swiper-wrapper-${(n = 16, void 0 === n && (n = 16), \"x\".repeat(n).replace(/x/g, () => Math.round(16 * Math.random()).toString(16)))}`;\n        var n;\n        const l = t.params.autoplay && t.params.autoplay.enabled ? \"off\" : \"polite\";\n        var o;\n        let d, u;\n        o = r, a.attr(\"id\", o), function (e, t) {\n          e.attr(\"aria-live\", t);\n        }(a, l), y(), t.navigation && t.navigation.$nextEl && (d = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (u = t.navigation.$prevEl), d && d.length && v(d, r, e.nextSlideMessage), u && u.length && v(u, r, e.prevSlideMessage), g() && t.pagination.$el.on(\"keydown\", U(t.params.pagination.bulletClass), m), t.$el.on(\"focus\", x, !0), t.$el.on(\"pointerdown\", w, !0), t.$el.on(\"pointerup\", b, !0);\n      };\n    a(\"beforeInit\", () => {\n      i = d(`<span class=\"${t.params.a11y.notificationClass}\" aria-live=\"assertive\" aria-atomic=\"true\"></span>`);\n    }), a(\"afterInit\", () => {\n      t.params.a11y.enabled && E();\n    }), a(\"slidesLengthChange snapGridLengthChange slidesGridLengthChange\", () => {\n      t.params.a11y.enabled && y();\n    }), a(\"fromEdge toEdge afterInit lock unlock\", () => {\n      t.params.a11y.enabled && function () {\n        if (t.params.loop || t.params.rewind || !t.navigation) return;\n        const {\n          $nextEl: e,\n          $prevEl: s\n        } = t.navigation;\n        s && s.length > 0 && (t.isBeginning ? (u(s), l(s)) : (h(s), n(s))), e && e.length > 0 && (t.isEnd ? (u(e), l(e)) : (h(e), n(e)));\n      }();\n    }), a(\"paginationUpdate\", () => {\n      t.params.a11y.enabled && function () {\n        const e = t.params.a11y;\n        f() && t.pagination.bullets.each(s => {\n          const a = d(s);\n          t.params.pagination.clickable && (n(a), t.params.pagination.renderBullet || (o(a, \"button\"), p(a, e.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, a.index() + 1)))), a.is(`.${t.params.pagination.bulletActiveClass}`) ? a.attr(\"aria-current\", \"true\") : a.removeAttr(\"aria-current\");\n        });\n      }();\n    }), a(\"destroy\", () => {\n      t.params.a11y.enabled && function () {\n        let e, s;\n        i && i.length > 0 && i.remove(), t.navigation && t.navigation.$nextEl && (e = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (s = t.navigation.$prevEl), e && e.off(\"keydown\", m), s && s.off(\"keydown\", m), g() && t.pagination.$el.off(\"keydown\", U(t.params.pagination.bulletClass), m), t.$el.off(\"focus\", x, !0), t.$el.off(\"pointerdown\", w, !0), t.$el.off(\"pointerup\", b, !0);\n      }();\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a\n    } = e;\n    s({\n      history: {\n        enabled: !1,\n        root: \"\",\n        replaceState: !1,\n        key: \"slides\",\n        keepQuery: !1\n      }\n    });\n    let i = !1,\n      n = {};\n    const l = e => e.toString().replace(/\\s+/g, \"-\").replace(/[^\\w-]+/g, \"\").replace(/--+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\"),\n      o = e => {\n        const t = r();\n        let s;\n        s = e ? new URL(e) : t.location;\n        const a = s.pathname.slice(1).split(\"/\").filter(e => \"\" !== e),\n          i = a.length;\n        return {\n          key: a[i - 2],\n          value: a[i - 1]\n        };\n      },\n      d = (e, s) => {\n        const a = r();\n        if (!i || !t.params.history.enabled) return;\n        let n;\n        n = t.params.url ? new URL(t.params.url) : a.location;\n        const o = t.slides.eq(s);\n        let d = l(o.attr(\"data-history\"));\n        if (t.params.history.root.length > 0) {\n          let s = t.params.history.root;\n          \"/\" === s[s.length - 1] && (s = s.slice(0, s.length - 1)), d = `${s}/${e}/${d}`;\n        } else n.pathname.includes(e) || (d = `${e}/${d}`);\n        t.params.history.keepQuery && (d += n.search);\n        const c = a.history.state;\n        c && c.value === d || (t.params.history.replaceState ? a.history.replaceState({\n          value: d\n        }, null, d) : a.history.pushState({\n          value: d\n        }, null, d));\n      },\n      c = (e, s, a) => {\n        if (s) for (let i = 0, r = t.slides.length; i < r; i += 1) {\n          const r = t.slides.eq(i);\n          if (l(r.attr(\"data-history\")) === s && !r.hasClass(t.params.slideDuplicateClass)) {\n            const s = r.index();\n            t.slideTo(s, e, a);\n          }\n        } else t.slideTo(0, e, a);\n      },\n      p = () => {\n        n = o(t.params.url), c(t.params.speed, n.value, !1);\n      };\n    a(\"init\", () => {\n      t.params.history.enabled && (() => {\n        const e = r();\n        if (t.params.history) {\n          if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void (t.params.hashNavigation.enabled = !0);\n          i = !0, n = o(t.params.url), (n.key || n.value) && (c(0, n.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener(\"popstate\", p));\n        }\n      })();\n    }), a(\"destroy\", () => {\n      t.params.history.enabled && (() => {\n        const e = r();\n        t.params.history.replaceState || e.removeEventListener(\"popstate\", p);\n      })();\n    }), a(\"transitionEnd _freeModeNoMomentumRelease\", () => {\n      i && d(t.params.history.key, t.activeIndex);\n    }), a(\"slideChange\", () => {\n      i && t.params.cssMode && d(t.params.history.key, t.activeIndex);\n    });\n  }, function (e) {\n    let {\n        swiper: t,\n        extendParams: s,\n        emit: i,\n        on: n\n      } = e,\n      l = !1;\n    const o = a(),\n      c = r();\n    s({\n      hashNavigation: {\n        enabled: !1,\n        replaceState: !1,\n        watchState: !1\n      }\n    });\n    const p = () => {\n        i(\"hashChange\");\n        const e = o.location.hash.replace(\"#\", \"\");\n        if (e !== t.slides.eq(t.activeIndex).attr(\"data-hash\")) {\n          const s = t.$wrapperEl.children(`.${t.params.slideClass}[data-hash=\"${e}\"]`).index();\n          if (void 0 === s) return;\n          t.slideTo(s);\n        }\n      },\n      u = () => {\n        if (l && t.params.hashNavigation.enabled) if (t.params.hashNavigation.replaceState && c.history && c.history.replaceState) c.history.replaceState(null, null, `#${t.slides.eq(t.activeIndex).attr(\"data-hash\")}` || \"\"), i(\"hashSet\");else {\n          const e = t.slides.eq(t.activeIndex),\n            s = e.attr(\"data-hash\") || e.attr(\"data-history\");\n          o.location.hash = s || \"\", i(\"hashSet\");\n        }\n      };\n    n(\"init\", () => {\n      t.params.hashNavigation.enabled && (() => {\n        if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return;\n        l = !0;\n        const e = o.location.hash.replace(\"#\", \"\");\n        if (e) {\n          const s = 0;\n          for (let a = 0, i = t.slides.length; a < i; a += 1) {\n            const i = t.slides.eq(a);\n            if ((i.attr(\"data-hash\") || i.attr(\"data-history\")) === e && !i.hasClass(t.params.slideDuplicateClass)) {\n              const e = i.index();\n              t.slideTo(e, s, t.params.runCallbacksOnInit, !0);\n            }\n          }\n        }\n        t.params.hashNavigation.watchState && d(c).on(\"hashchange\", p);\n      })();\n    }), n(\"destroy\", () => {\n      t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && d(c).off(\"hashchange\", p);\n    }), n(\"transitionEnd _freeModeNoMomentumRelease\", () => {\n      l && u();\n    }), n(\"slideChange\", () => {\n      l && t.params.cssMode && u();\n    });\n  }, function (e) {\n    let t,\n      {\n        swiper: s,\n        extendParams: i,\n        on: r,\n        emit: n\n      } = e;\n    function l() {\n      if (!s.size) return s.autoplay.running = !1, void (s.autoplay.paused = !1);\n      const e = s.slides.eq(s.activeIndex);\n      let a = s.params.autoplay.delay;\n      e.attr(\"data-swiper-autoplay\") && (a = e.attr(\"data-swiper-autoplay\") || s.params.autoplay.delay), clearTimeout(t), t = p(() => {\n        let e;\n        s.params.autoplay.reverseDirection ? s.params.loop ? (s.loopFix(), e = s.slidePrev(s.params.speed, !0, !0), n(\"autoplay\")) : s.isBeginning ? s.params.autoplay.stopOnLastSlide ? d() : (e = s.slideTo(s.slides.length - 1, s.params.speed, !0, !0), n(\"autoplay\")) : (e = s.slidePrev(s.params.speed, !0, !0), n(\"autoplay\")) : s.params.loop ? (s.loopFix(), e = s.slideNext(s.params.speed, !0, !0), n(\"autoplay\")) : s.isEnd ? s.params.autoplay.stopOnLastSlide ? d() : (e = s.slideTo(0, s.params.speed, !0, !0), n(\"autoplay\")) : (e = s.slideNext(s.params.speed, !0, !0), n(\"autoplay\")), (s.params.cssMode && s.autoplay.running || !1 === e) && l();\n      }, a);\n    }\n    function o() {\n      return void 0 === t && !s.autoplay.running && (s.autoplay.running = !0, n(\"autoplayStart\"), l(), !0);\n    }\n    function d() {\n      return !!s.autoplay.running && void 0 !== t && (t && (clearTimeout(t), t = void 0), s.autoplay.running = !1, n(\"autoplayStop\"), !0);\n    }\n    function c(e) {\n      s.autoplay.running && (s.autoplay.paused || (t && clearTimeout(t), s.autoplay.paused = !0, 0 !== e && s.params.autoplay.waitForTransition ? [\"transitionend\", \"webkitTransitionEnd\"].forEach(e => {\n        s.$wrapperEl[0].addEventListener(e, h);\n      }) : (s.autoplay.paused = !1, l())));\n    }\n    function u() {\n      const e = a();\n      \"hidden\" === e.visibilityState && s.autoplay.running && c(), \"visible\" === e.visibilityState && s.autoplay.paused && (l(), s.autoplay.paused = !1);\n    }\n    function h(e) {\n      s && !s.destroyed && s.$wrapperEl && e.target === s.$wrapperEl[0] && ([\"transitionend\", \"webkitTransitionEnd\"].forEach(e => {\n        s.$wrapperEl[0].removeEventListener(e, h);\n      }), s.autoplay.paused = !1, s.autoplay.running ? l() : d());\n    }\n    function m() {\n      s.params.autoplay.disableOnInteraction ? d() : (n(\"autoplayPause\"), c()), [\"transitionend\", \"webkitTransitionEnd\"].forEach(e => {\n        s.$wrapperEl[0].removeEventListener(e, h);\n      });\n    }\n    function f() {\n      s.params.autoplay.disableOnInteraction || (s.autoplay.paused = !1, n(\"autoplayResume\"), l());\n    }\n    s.autoplay = {\n      running: !1,\n      paused: !1\n    }, i({\n      autoplay: {\n        enabled: !1,\n        delay: 3e3,\n        waitForTransition: !0,\n        disableOnInteraction: !0,\n        stopOnLastSlide: !1,\n        reverseDirection: !1,\n        pauseOnMouseEnter: !1\n      }\n    }), r(\"init\", () => {\n      if (s.params.autoplay.enabled) {\n        o();\n        a().addEventListener(\"visibilitychange\", u), s.params.autoplay.pauseOnMouseEnter && (s.$el.on(\"mouseenter\", m), s.$el.on(\"mouseleave\", f));\n      }\n    }), r(\"beforeTransitionStart\", (e, t, a) => {\n      s.autoplay.running && (a || !s.params.autoplay.disableOnInteraction ? s.autoplay.pause(t) : d());\n    }), r(\"sliderFirstMove\", () => {\n      s.autoplay.running && (s.params.autoplay.disableOnInteraction ? d() : c());\n    }), r(\"touchEnd\", () => {\n      s.params.cssMode && s.autoplay.paused && !s.params.autoplay.disableOnInteraction && l();\n    }), r(\"destroy\", () => {\n      s.$el.off(\"mouseenter\", m), s.$el.off(\"mouseleave\", f), s.autoplay.running && d();\n      a().removeEventListener(\"visibilitychange\", u);\n    }), Object.assign(s.autoplay, {\n      pause: c,\n      run: l,\n      start: o,\n      stop: d\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a\n    } = e;\n    s({\n      thumbs: {\n        swiper: null,\n        multipleActiveThumbs: !0,\n        autoScrollOffset: 0,\n        slideThumbActiveClass: \"swiper-slide-thumb-active\",\n        thumbsContainerClass: \"swiper-thumbs\"\n      }\n    });\n    let i = !1,\n      r = !1;\n    function n() {\n      const e = t.thumbs.swiper;\n      if (!e || e.destroyed) return;\n      const s = e.clickedIndex,\n        a = e.clickedSlide;\n      if (a && d(a).hasClass(t.params.thumbs.slideThumbActiveClass)) return;\n      if (null == s) return;\n      let i;\n      if (i = e.params.loop ? parseInt(d(e.clickedSlide).attr(\"data-swiper-slide-index\"), 10) : s, t.params.loop) {\n        let e = t.activeIndex;\n        t.slides.eq(e).hasClass(t.params.slideDuplicateClass) && (t.loopFix(), t._clientLeft = t.$wrapperEl[0].clientLeft, e = t.activeIndex);\n        const s = t.slides.eq(e).prevAll(`[data-swiper-slide-index=\"${i}\"]`).eq(0).index(),\n          a = t.slides.eq(e).nextAll(`[data-swiper-slide-index=\"${i}\"]`).eq(0).index();\n        i = void 0 === s ? a : void 0 === a ? s : a - e < e - s ? a : s;\n      }\n      t.slideTo(i);\n    }\n    function l() {\n      const {\n        thumbs: e\n      } = t.params;\n      if (i) return !1;\n      i = !0;\n      const s = t.constructor;\n      if (e.swiper instanceof s) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, {\n        watchSlidesProgress: !0,\n        slideToClickedSlide: !1\n      }), Object.assign(t.thumbs.swiper.params, {\n        watchSlidesProgress: !0,\n        slideToClickedSlide: !1\n      });else if (m(e.swiper)) {\n        const a = Object.assign({}, e.swiper);\n        Object.assign(a, {\n          watchSlidesProgress: !0,\n          slideToClickedSlide: !1\n        }), t.thumbs.swiper = new s(a), r = !0;\n      }\n      return t.thumbs.swiper.$el.addClass(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on(\"tap\", n), !0;\n    }\n    function o(e) {\n      const s = t.thumbs.swiper;\n      if (!s || s.destroyed) return;\n      const a = \"auto\" === s.params.slidesPerView ? s.slidesPerViewDynamic() : s.params.slidesPerView;\n      let i = 1;\n      const r = t.params.thumbs.slideThumbActiveClass;\n      if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (i = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (i = 1), i = Math.floor(i), s.slides.removeClass(r), s.params.loop || s.params.virtual && s.params.virtual.enabled) for (let e = 0; e < i; e += 1) s.$wrapperEl.children(`[data-swiper-slide-index=\"${t.realIndex + e}\"]`).addClass(r);else for (let e = 0; e < i; e += 1) s.slides.eq(t.realIndex + e).addClass(r);\n      const n = t.params.thumbs.autoScrollOffset,\n        l = n && !s.params.loop;\n      if (t.realIndex !== s.realIndex || l) {\n        let i,\n          r,\n          o = s.activeIndex;\n        if (s.params.loop) {\n          s.slides.eq(o).hasClass(s.params.slideDuplicateClass) && (s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft, o = s.activeIndex);\n          const e = s.slides.eq(o).prevAll(`[data-swiper-slide-index=\"${t.realIndex}\"]`).eq(0).index(),\n            a = s.slides.eq(o).nextAll(`[data-swiper-slide-index=\"${t.realIndex}\"]`).eq(0).index();\n          i = void 0 === e ? a : void 0 === a ? e : a - o == o - e ? s.params.slidesPerGroup > 1 ? a : o : a - o < o - e ? a : e, r = t.activeIndex > t.previousIndex ? \"next\" : \"prev\";\n        } else i = t.realIndex, r = i > t.previousIndex ? \"next\" : \"prev\";\n        l && (i += \"next\" === r ? n : -1 * n), s.visibleSlidesIndexes && s.visibleSlidesIndexes.indexOf(i) < 0 && (s.params.centeredSlides ? i = i > o ? i - Math.floor(a / 2) + 1 : i + Math.floor(a / 2) - 1 : i > o && s.params.slidesPerGroup, s.slideTo(i, e ? 0 : void 0));\n      }\n    }\n    t.thumbs = {\n      swiper: null\n    }, a(\"beforeInit\", () => {\n      const {\n        thumbs: e\n      } = t.params;\n      e && e.swiper && (l(), o(!0));\n    }), a(\"slideChange update resize observerUpdate\", () => {\n      o();\n    }), a(\"setTransition\", (e, s) => {\n      const a = t.thumbs.swiper;\n      a && !a.destroyed && a.setTransition(s);\n    }), a(\"beforeDestroy\", () => {\n      const e = t.thumbs.swiper;\n      e && !e.destroyed && r && e.destroy();\n    }), Object.assign(t.thumbs, {\n      init: l,\n      update: o\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      emit: a,\n      once: i\n    } = e;\n    s({\n      freeMode: {\n        enabled: !1,\n        momentum: !0,\n        momentumRatio: 1,\n        momentumBounce: !0,\n        momentumBounceRatio: 1,\n        momentumVelocityRatio: 1,\n        sticky: !1,\n        minimumVelocity: .02\n      }\n    }), Object.assign(t, {\n      freeMode: {\n        onTouchStart: function () {\n          const e = t.getTranslate();\n          t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({\n            currentPos: t.rtl ? t.translate : -t.translate\n          });\n        },\n        onTouchMove: function () {\n          const {\n            touchEventsData: e,\n            touches: s\n          } = t;\n          0 === e.velocities.length && e.velocities.push({\n            position: s[t.isHorizontal() ? \"startX\" : \"startY\"],\n            time: e.touchStartTime\n          }), e.velocities.push({\n            position: s[t.isHorizontal() ? \"currentX\" : \"currentY\"],\n            time: u()\n          });\n        },\n        onTouchEnd: function (e) {\n          let {\n            currentPos: s\n          } = e;\n          const {\n              params: r,\n              $wrapperEl: n,\n              rtlTranslate: l,\n              snapGrid: o,\n              touchEventsData: d\n            } = t,\n            c = u() - d.touchStartTime;\n          if (s < -t.minTranslate()) t.slideTo(t.activeIndex);else if (s > -t.maxTranslate()) t.slides.length < o.length ? t.slideTo(o.length - 1) : t.slideTo(t.slides.length - 1);else {\n            if (r.freeMode.momentum) {\n              if (d.velocities.length > 1) {\n                const e = d.velocities.pop(),\n                  s = d.velocities.pop(),\n                  a = e.position - s.position,\n                  i = e.time - s.time;\n                t.velocity = a / i, t.velocity /= 2, Math.abs(t.velocity) < r.freeMode.minimumVelocity && (t.velocity = 0), (i > 150 || u() - e.time > 300) && (t.velocity = 0);\n              } else t.velocity = 0;\n              t.velocity *= r.freeMode.momentumVelocityRatio, d.velocities.length = 0;\n              let e = 1e3 * r.freeMode.momentumRatio;\n              const s = t.velocity * e;\n              let c = t.translate + s;\n              l && (c = -c);\n              let p,\n                h = !1;\n              const m = 20 * Math.abs(t.velocity) * r.freeMode.momentumBounceRatio;\n              let f;\n              if (c < t.maxTranslate()) r.freeMode.momentumBounce ? (c + t.maxTranslate() < -m && (c = t.maxTranslate() - m), p = t.maxTranslate(), h = !0, d.allowMomentumBounce = !0) : c = t.maxTranslate(), r.loop && r.centeredSlides && (f = !0);else if (c > t.minTranslate()) r.freeMode.momentumBounce ? (c - t.minTranslate() > m && (c = t.minTranslate() + m), p = t.minTranslate(), h = !0, d.allowMomentumBounce = !0) : c = t.minTranslate(), r.loop && r.centeredSlides && (f = !0);else if (r.freeMode.sticky) {\n                let e;\n                for (let t = 0; t < o.length; t += 1) if (o[t] > -c) {\n                  e = t;\n                  break;\n                }\n                c = Math.abs(o[e] - c) < Math.abs(o[e - 1] - c) || \"next\" === t.swipeDirection ? o[e] : o[e - 1], c = -c;\n              }\n              if (f && i(\"transitionEnd\", () => {\n                t.loopFix();\n              }), 0 !== t.velocity) {\n                if (e = l ? Math.abs((-c - t.translate) / t.velocity) : Math.abs((c - t.translate) / t.velocity), r.freeMode.sticky) {\n                  const s = Math.abs((l ? -c : c) - t.translate),\n                    a = t.slidesSizesGrid[t.activeIndex];\n                  e = s < a ? r.speed : s < 2 * a ? 1.5 * r.speed : 2.5 * r.speed;\n                }\n              } else if (r.freeMode.sticky) return void t.slideToClosest();\n              r.freeMode.momentumBounce && h ? (t.updateProgress(p), t.setTransition(e), t.setTranslate(c), t.transitionStart(!0, t.swipeDirection), t.animating = !0, n.transitionEnd(() => {\n                t && !t.destroyed && d.allowMomentumBounce && (a(\"momentumBounce\"), t.setTransition(r.speed), setTimeout(() => {\n                  t.setTranslate(p), n.transitionEnd(() => {\n                    t && !t.destroyed && t.transitionEnd();\n                  });\n                }, 0));\n              })) : t.velocity ? (a(\"_freeModeNoMomentumRelease\"), t.updateProgress(c), t.setTransition(e), t.setTranslate(c), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, n.transitionEnd(() => {\n                t && !t.destroyed && t.transitionEnd();\n              }))) : t.updateProgress(c), t.updateActiveIndex(), t.updateSlidesClasses();\n            } else {\n              if (r.freeMode.sticky) return void t.slideToClosest();\n              r.freeMode && a(\"_freeModeNoMomentumRelease\");\n            }\n            (!r.freeMode.momentum || c >= r.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses());\n          }\n        }\n      }\n    });\n  }, function (e) {\n    let t,\n      s,\n      a,\n      {\n        swiper: i,\n        extendParams: r\n      } = e;\n    r({\n      grid: {\n        rows: 1,\n        fill: \"column\"\n      }\n    }), i.grid = {\n      initSlides: e => {\n        const {\n            slidesPerView: r\n          } = i.params,\n          {\n            rows: n,\n            fill: l\n          } = i.params.grid;\n        s = t / n, a = Math.floor(e / n), t = Math.floor(e / n) === e / n ? e : Math.ceil(e / n) * n, \"auto\" !== r && \"row\" === l && (t = Math.max(t, r * n));\n      },\n      updateSlide: (e, r, n, l) => {\n        const {\n            slidesPerGroup: o,\n            spaceBetween: d\n          } = i.params,\n          {\n            rows: c,\n            fill: p\n          } = i.params.grid;\n        let u, h, m;\n        if (\"row\" === p && o > 1) {\n          const s = Math.floor(e / (o * c)),\n            a = e - c * o * s,\n            i = 0 === s ? o : Math.min(Math.ceil((n - s * c * o) / c), o);\n          m = Math.floor(a / i), h = a - m * i + s * o, u = h + m * t / c, r.css({\n            \"-webkit-order\": u,\n            order: u\n          });\n        } else \"column\" === p ? (h = Math.floor(e / c), m = e - h * c, (h > a || h === a && m === c - 1) && (m += 1, m >= c && (m = 0, h += 1))) : (m = Math.floor(e / s), h = e - m * s);\n        r.css(l(\"margin-top\"), 0 !== m ? d && `${d}px` : \"\");\n      },\n      updateWrapperSize: (e, s, a) => {\n        const {\n            spaceBetween: r,\n            centeredSlides: n,\n            roundLengths: l\n          } = i.params,\n          {\n            rows: o\n          } = i.params.grid;\n        if (i.virtualSize = (e + r) * t, i.virtualSize = Math.ceil(i.virtualSize / o) - r, i.$wrapperEl.css({\n          [a(\"width\")]: `${i.virtualSize + r}px`\n        }), n) {\n          s.splice(0, s.length);\n          const e = [];\n          for (let t = 0; t < s.length; t += 1) {\n            let a = s[t];\n            l && (a = Math.floor(a)), s[t] < i.virtualSize + s[0] && e.push(a);\n          }\n          s.push(...e);\n        }\n      }\n    };\n  }, function (e) {\n    let {\n      swiper: t\n    } = e;\n    Object.assign(t, {\n      appendSlide: K.bind(t),\n      prependSlide: Z.bind(t),\n      addSlide: Q.bind(t),\n      removeSlide: J.bind(t),\n      removeAllSlides: ee.bind(t)\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a\n    } = e;\n    s({\n      fadeEffect: {\n        crossFade: !1,\n        transformEl: null\n      }\n    }), te({\n      effect: \"fade\",\n      swiper: t,\n      on: a,\n      setTranslate: () => {\n        const {\n            slides: e\n          } = t,\n          s = t.params.fadeEffect;\n        for (let a = 0; a < e.length; a += 1) {\n          const e = t.slides.eq(a);\n          let i = -e[0].swiperSlideOffset;\n          t.params.virtualTranslate || (i -= t.translate);\n          let r = 0;\n          t.isHorizontal() || (r = i, i = 0);\n          const n = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e[0].progress), 0) : 1 + Math.min(Math.max(e[0].progress, -1), 0);\n          se(s, e).css({\n            opacity: n\n          }).transform(`translate3d(${i}px, ${r}px, 0px)`);\n        }\n      },\n      setTransition: e => {\n        const {\n          transformEl: s\n        } = t.params.fadeEffect;\n        (s ? t.slides.find(s) : t.slides).transition(e), ae({\n          swiper: t,\n          duration: e,\n          transformEl: s,\n          allSlides: !0\n        });\n      },\n      overwriteParams: () => ({\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: !0,\n        spaceBetween: 0,\n        virtualTranslate: !t.params.cssMode\n      })\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a\n    } = e;\n    s({\n      cubeEffect: {\n        slideShadows: !0,\n        shadow: !0,\n        shadowOffset: 20,\n        shadowScale: .94\n      }\n    });\n    const i = (e, t, s) => {\n      let a = s ? e.find(\".swiper-slide-shadow-left\") : e.find(\".swiper-slide-shadow-top\"),\n        i = s ? e.find(\".swiper-slide-shadow-right\") : e.find(\".swiper-slide-shadow-bottom\");\n      0 === a.length && (a = d(`<div class=\"swiper-slide-shadow-${s ? \"left\" : \"top\"}\"></div>`), e.append(a)), 0 === i.length && (i = d(`<div class=\"swiper-slide-shadow-${s ? \"right\" : \"bottom\"}\"></div>`), e.append(i)), a.length && (a[0].style.opacity = Math.max(-t, 0)), i.length && (i[0].style.opacity = Math.max(t, 0));\n    };\n    te({\n      effect: \"cube\",\n      swiper: t,\n      on: a,\n      setTranslate: () => {\n        const {\n            $el: e,\n            $wrapperEl: s,\n            slides: a,\n            width: r,\n            height: n,\n            rtlTranslate: l,\n            size: o,\n            browser: c\n          } = t,\n          p = t.params.cubeEffect,\n          u = t.isHorizontal(),\n          h = t.virtual && t.params.virtual.enabled;\n        let m,\n          f = 0;\n        p.shadow && (u ? (m = s.find(\".swiper-cube-shadow\"), 0 === m.length && (m = d('<div class=\"swiper-cube-shadow\"></div>'), s.append(m)), m.css({\n          height: `${r}px`\n        })) : (m = e.find(\".swiper-cube-shadow\"), 0 === m.length && (m = d('<div class=\"swiper-cube-shadow\"></div>'), e.append(m))));\n        for (let e = 0; e < a.length; e += 1) {\n          const t = a.eq(e);\n          let s = e;\n          h && (s = parseInt(t.attr(\"data-swiper-slide-index\"), 10));\n          let r = 90 * s,\n            n = Math.floor(r / 360);\n          l && (r = -r, n = Math.floor(-r / 360));\n          const d = Math.max(Math.min(t[0].progress, 1), -1);\n          let c = 0,\n            m = 0,\n            g = 0;\n          s % 4 == 0 ? (c = 4 * -n * o, g = 0) : (s - 1) % 4 == 0 ? (c = 0, g = 4 * -n * o) : (s - 2) % 4 == 0 ? (c = o + 4 * n * o, g = o) : (s - 3) % 4 == 0 && (c = -o, g = 3 * o + 4 * o * n), l && (c = -c), u || (m = c, c = 0);\n          const v = `rotateX(${u ? 0 : -r}deg) rotateY(${u ? r : 0}deg) translate3d(${c}px, ${m}px, ${g}px)`;\n          d <= 1 && d > -1 && (f = 90 * s + 90 * d, l && (f = 90 * -s - 90 * d)), t.transform(v), p.slideShadows && i(t, d, u);\n        }\n        if (s.css({\n          \"-webkit-transform-origin\": `50% 50% -${o / 2}px`,\n          \"transform-origin\": `50% 50% -${o / 2}px`\n        }), p.shadow) if (u) m.transform(`translate3d(0px, ${r / 2 + p.shadowOffset}px, ${-r / 2}px) rotateX(90deg) rotateZ(0deg) scale(${p.shadowScale})`);else {\n          const e = Math.abs(f) - 90 * Math.floor(Math.abs(f) / 90),\n            t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2),\n            s = p.shadowScale,\n            a = p.shadowScale / t,\n            i = p.shadowOffset;\n          m.transform(`scale3d(${s}, 1, ${a}) translate3d(0px, ${n / 2 + i}px, ${-n / 2 / a}px) rotateX(-90deg)`);\n        }\n        const g = c.isSafari || c.isWebView ? -o / 2 : 0;\n        s.transform(`translate3d(0px,0,${g}px) rotateX(${t.isHorizontal() ? 0 : f}deg) rotateY(${t.isHorizontal() ? -f : 0}deg)`), s[0].style.setProperty(\"--swiper-cube-translate-z\", `${g}px`);\n      },\n      setTransition: e => {\n        const {\n          $el: s,\n          slides: a\n        } = t;\n        a.transition(e).find(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").transition(e), t.params.cubeEffect.shadow && !t.isHorizontal() && s.find(\".swiper-cube-shadow\").transition(e);\n      },\n      recreateShadows: () => {\n        const e = t.isHorizontal();\n        t.slides.each(t => {\n          const s = Math.max(Math.min(t.progress, 1), -1);\n          i(d(t), s, e);\n        });\n      },\n      getEffectParams: () => t.params.cubeEffect,\n      perspective: () => !0,\n      overwriteParams: () => ({\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: !0,\n        resistanceRatio: 0,\n        spaceBetween: 0,\n        centeredSlides: !1,\n        virtualTranslate: !0\n      })\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a\n    } = e;\n    s({\n      flipEffect: {\n        slideShadows: !0,\n        limitRotation: !0,\n        transformEl: null\n      }\n    });\n    const i = (e, s, a) => {\n      let i = t.isHorizontal() ? e.find(\".swiper-slide-shadow-left\") : e.find(\".swiper-slide-shadow-top\"),\n        r = t.isHorizontal() ? e.find(\".swiper-slide-shadow-right\") : e.find(\".swiper-slide-shadow-bottom\");\n      0 === i.length && (i = ie(a, e, t.isHorizontal() ? \"left\" : \"top\")), 0 === r.length && (r = ie(a, e, t.isHorizontal() ? \"right\" : \"bottom\")), i.length && (i[0].style.opacity = Math.max(-s, 0)), r.length && (r[0].style.opacity = Math.max(s, 0));\n    };\n    te({\n      effect: \"flip\",\n      swiper: t,\n      on: a,\n      setTranslate: () => {\n        const {\n            slides: e,\n            rtlTranslate: s\n          } = t,\n          a = t.params.flipEffect;\n        for (let r = 0; r < e.length; r += 1) {\n          const n = e.eq(r);\n          let l = n[0].progress;\n          t.params.flipEffect.limitRotation && (l = Math.max(Math.min(n[0].progress, 1), -1));\n          const o = n[0].swiperSlideOffset;\n          let d = -180 * l,\n            c = 0,\n            p = t.params.cssMode ? -o - t.translate : -o,\n            u = 0;\n          t.isHorizontal() ? s && (d = -d) : (u = p, p = 0, c = -d, d = 0), n[0].style.zIndex = -Math.abs(Math.round(l)) + e.length, a.slideShadows && i(n, l, a);\n          const h = `translate3d(${p}px, ${u}px, 0px) rotateX(${c}deg) rotateY(${d}deg)`;\n          se(a, n).transform(h);\n        }\n      },\n      setTransition: e => {\n        const {\n          transformEl: s\n        } = t.params.flipEffect;\n        (s ? t.slides.find(s) : t.slides).transition(e).find(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").transition(e), ae({\n          swiper: t,\n          duration: e,\n          transformEl: s\n        });\n      },\n      recreateShadows: () => {\n        const e = t.params.flipEffect;\n        t.slides.each(s => {\n          const a = d(s);\n          let r = a[0].progress;\n          t.params.flipEffect.limitRotation && (r = Math.max(Math.min(s.progress, 1), -1)), i(a, r, e);\n        });\n      },\n      getEffectParams: () => t.params.flipEffect,\n      perspective: () => !0,\n      overwriteParams: () => ({\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: !0,\n        spaceBetween: 0,\n        virtualTranslate: !t.params.cssMode\n      })\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a\n    } = e;\n    s({\n      coverflowEffect: {\n        rotate: 50,\n        stretch: 0,\n        depth: 100,\n        scale: 1,\n        modifier: 1,\n        slideShadows: !0,\n        transformEl: null\n      }\n    }), te({\n      effect: \"coverflow\",\n      swiper: t,\n      on: a,\n      setTranslate: () => {\n        const {\n            width: e,\n            height: s,\n            slides: a,\n            slidesSizesGrid: i\n          } = t,\n          r = t.params.coverflowEffect,\n          n = t.isHorizontal(),\n          l = t.translate,\n          o = n ? e / 2 - l : s / 2 - l,\n          d = n ? r.rotate : -r.rotate,\n          c = r.depth;\n        for (let e = 0, t = a.length; e < t; e += 1) {\n          const t = a.eq(e),\n            s = i[e],\n            l = (o - t[0].swiperSlideOffset - s / 2) / s,\n            p = \"function\" == typeof r.modifier ? r.modifier(l) : l * r.modifier;\n          let u = n ? d * p : 0,\n            h = n ? 0 : d * p,\n            m = -c * Math.abs(p),\n            f = r.stretch;\n          \"string\" == typeof f && -1 !== f.indexOf(\"%\") && (f = parseFloat(r.stretch) / 100 * s);\n          let g = n ? 0 : f * p,\n            v = n ? f * p : 0,\n            w = 1 - (1 - r.scale) * Math.abs(p);\n          Math.abs(v) < .001 && (v = 0), Math.abs(g) < .001 && (g = 0), Math.abs(m) < .001 && (m = 0), Math.abs(u) < .001 && (u = 0), Math.abs(h) < .001 && (h = 0), Math.abs(w) < .001 && (w = 0);\n          const b = `translate3d(${v}px,${g}px,${m}px)  rotateX(${h}deg) rotateY(${u}deg) scale(${w})`;\n          if (se(r, t).transform(b), t[0].style.zIndex = 1 - Math.abs(Math.round(p)), r.slideShadows) {\n            let e = n ? t.find(\".swiper-slide-shadow-left\") : t.find(\".swiper-slide-shadow-top\"),\n              s = n ? t.find(\".swiper-slide-shadow-right\") : t.find(\".swiper-slide-shadow-bottom\");\n            0 === e.length && (e = ie(r, t, n ? \"left\" : \"top\")), 0 === s.length && (s = ie(r, t, n ? \"right\" : \"bottom\")), e.length && (e[0].style.opacity = p > 0 ? p : 0), s.length && (s[0].style.opacity = -p > 0 ? -p : 0);\n          }\n        }\n      },\n      setTransition: e => {\n        const {\n          transformEl: s\n        } = t.params.coverflowEffect;\n        (s ? t.slides.find(s) : t.slides).transition(e).find(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").transition(e);\n      },\n      perspective: () => !0,\n      overwriteParams: () => ({\n        watchSlidesProgress: !0\n      })\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a\n    } = e;\n    s({\n      creativeEffect: {\n        transformEl: null,\n        limitProgress: 1,\n        shadowPerProgress: !1,\n        progressMultiplier: 1,\n        perspective: !0,\n        prev: {\n          translate: [0, 0, 0],\n          rotate: [0, 0, 0],\n          opacity: 1,\n          scale: 1\n        },\n        next: {\n          translate: [0, 0, 0],\n          rotate: [0, 0, 0],\n          opacity: 1,\n          scale: 1\n        }\n      }\n    });\n    const i = e => \"string\" == typeof e ? e : `${e}px`;\n    te({\n      effect: \"creative\",\n      swiper: t,\n      on: a,\n      setTranslate: () => {\n        const {\n            slides: e,\n            $wrapperEl: s,\n            slidesSizesGrid: a\n          } = t,\n          r = t.params.creativeEffect,\n          {\n            progressMultiplier: n\n          } = r,\n          l = t.params.centeredSlides;\n        if (l) {\n          const e = a[0] / 2 - t.params.slidesOffsetBefore || 0;\n          s.transform(`translateX(calc(50% - ${e}px))`);\n        }\n        for (let s = 0; s < e.length; s += 1) {\n          const a = e.eq(s),\n            o = a[0].progress,\n            d = Math.min(Math.max(a[0].progress, -r.limitProgress), r.limitProgress);\n          let c = d;\n          l || (c = Math.min(Math.max(a[0].originalProgress, -r.limitProgress), r.limitProgress));\n          const p = a[0].swiperSlideOffset,\n            u = [t.params.cssMode ? -p - t.translate : -p, 0, 0],\n            h = [0, 0, 0];\n          let m = !1;\n          t.isHorizontal() || (u[1] = u[0], u[0] = 0);\n          let f = {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            scale: 1,\n            opacity: 1\n          };\n          d < 0 ? (f = r.next, m = !0) : d > 0 && (f = r.prev, m = !0), u.forEach((e, t) => {\n            u[t] = `calc(${e}px + (${i(f.translate[t])} * ${Math.abs(d * n)}))`;\n          }), h.forEach((e, t) => {\n            h[t] = f.rotate[t] * Math.abs(d * n);\n          }), a[0].style.zIndex = -Math.abs(Math.round(o)) + e.length;\n          const g = u.join(\", \"),\n            v = `rotateX(${h[0]}deg) rotateY(${h[1]}deg) rotateZ(${h[2]}deg)`,\n            w = c < 0 ? `scale(${1 + (1 - f.scale) * c * n})` : `scale(${1 - (1 - f.scale) * c * n})`,\n            b = c < 0 ? 1 + (1 - f.opacity) * c * n : 1 - (1 - f.opacity) * c * n,\n            x = `translate3d(${g}) ${v} ${w}`;\n          if (m && f.shadow || !m) {\n            let e = a.children(\".swiper-slide-shadow\");\n            if (0 === e.length && f.shadow && (e = ie(r, a)), e.length) {\n              const t = r.shadowPerProgress ? d * (1 / r.limitProgress) : d;\n              e[0].style.opacity = Math.min(Math.max(Math.abs(t), 0), 1);\n            }\n          }\n          const y = se(r, a);\n          y.transform(x).css({\n            opacity: b\n          }), f.origin && y.css(\"transform-origin\", f.origin);\n        }\n      },\n      setTransition: e => {\n        const {\n          transformEl: s\n        } = t.params.creativeEffect;\n        (s ? t.slides.find(s) : t.slides).transition(e).find(\".swiper-slide-shadow\").transition(e), ae({\n          swiper: t,\n          duration: e,\n          transformEl: s,\n          allSlides: !0\n        });\n      },\n      perspective: () => t.params.creativeEffect.perspective,\n      overwriteParams: () => ({\n        watchSlidesProgress: !0,\n        virtualTranslate: !t.params.cssMode\n      })\n    });\n  }, function (e) {\n    let {\n      swiper: t,\n      extendParams: s,\n      on: a\n    } = e;\n    s({\n      cardsEffect: {\n        slideShadows: !0,\n        transformEl: null,\n        rotate: !0,\n        perSlideRotate: 2,\n        perSlideOffset: 8\n      }\n    }), te({\n      effect: \"cards\",\n      swiper: t,\n      on: a,\n      setTranslate: () => {\n        const {\n            slides: e,\n            activeIndex: s\n          } = t,\n          a = t.params.cardsEffect,\n          {\n            startTranslate: i,\n            isTouched: r\n          } = t.touchEventsData,\n          n = t.translate;\n        for (let l = 0; l < e.length; l += 1) {\n          const o = e.eq(l),\n            d = o[0].progress,\n            c = Math.min(Math.max(d, -4), 4);\n          let p = o[0].swiperSlideOffset;\n          t.params.centeredSlides && !t.params.cssMode && t.$wrapperEl.transform(`translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (p -= e[0].swiperSlideOffset);\n          let u = t.params.cssMode ? -p - t.translate : -p,\n            h = 0;\n          const m = -100 * Math.abs(c);\n          let f = 1,\n            g = -a.perSlideRotate * c,\n            v = a.perSlideOffset - .75 * Math.abs(c);\n          const w = t.virtual && t.params.virtual.enabled ? t.virtual.from + l : l,\n            b = (w === s || w === s - 1) && c > 0 && c < 1 && (r || t.params.cssMode) && n < i,\n            x = (w === s || w === s + 1) && c < 0 && c > -1 && (r || t.params.cssMode) && n > i;\n          if (b || x) {\n            const e = (1 - Math.abs((Math.abs(c) - .5) / .5)) ** .5;\n            g += -28 * c * e, f += -.5 * e, v += 96 * e, h = -25 * e * Math.abs(c) + \"%\";\n          }\n          if (u = c < 0 ? `calc(${u}px + (${v * Math.abs(c)}%))` : c > 0 ? `calc(${u}px + (-${v * Math.abs(c)}%))` : `${u}px`, !t.isHorizontal()) {\n            const e = h;\n            h = u, u = e;\n          }\n          const y = c < 0 ? \"\" + (1 + (1 - f) * c) : \"\" + (1 - (1 - f) * c),\n            E = `\\n        translate3d(${u}, ${h}, ${m}px)\\n        rotateZ(${a.rotate ? g : 0}deg)\\n        scale(${y})\\n      `;\n          if (a.slideShadows) {\n            let e = o.find(\".swiper-slide-shadow\");\n            0 === e.length && (e = ie(a, o)), e.length && (e[0].style.opacity = Math.min(Math.max((Math.abs(c) - .5) / .5, 0), 1));\n          }\n          o[0].style.zIndex = -Math.abs(Math.round(d)) + e.length;\n          se(a, o).transform(E);\n        }\n      },\n      setTransition: e => {\n        const {\n          transformEl: s\n        } = t.params.cardsEffect;\n        (s ? t.slides.find(s) : t.slides).transition(e).find(\".swiper-slide-shadow\").transition(e), ae({\n          swiper: t,\n          duration: e,\n          transformEl: s\n        });\n      },\n      perspective: () => !0,\n      overwriteParams: () => ({\n        watchSlidesProgress: !0,\n        virtualTranslate: !t.params.cssMode\n      })\n    });\n  }];\n  return V.use(re), V;\n});","map":{"version":3,"mappings":"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","names":["isObject","obj","constructor","Object","extend","target","src","keys","forEach","key","length","ssrDocument","body","addEventListener","removeEventListener","activeElement","blur","nodeName","querySelector","querySelectorAll","getElementById","createEvent","initEvent","createElement","children","childNodes","style","setAttribute","getElementsByTagName","createElementNS","importNode","location","hash","host","hostname","href","origin","pathname","protocol","search","getDocument","doc","document","ssrWindow","navigator","userAgent","history","replaceState","pushState","go","back","CustomEvent","this","getComputedStyle","getPropertyValue","Image","Date","screen","setTimeout","clearTimeout","matchMedia","requestAnimationFrame","callback","cancelAnimationFrame","id","getWindow","win","window","Dom7","Array","items","super","proto","__proto__","defineProperty","get","set","value","makeReactive","arrayFlat","arr","res","el","isArray","push","arrayFilter","prototype","filter","call","$","selector","context","html","trim","indexOf","toCreate","tempParent","innerHTML","i","a","qsa","nodeType","uniqueArray","arrayUnique","fn","Methods","addClass","classes","_key","classNames","map","c","split","classList","add","removeClass","_key2","remove","hasClass","_key4","className","contains","toggleClass","_key3","toggle","attr","attrs","arguments","getAttribute","attrName","removeAttr","removeAttribute","transform","duration","transitionDuration","on","args","_key5","eventType","targetSelector","listener","capture","handleLiveEvent","e","eventData","dom7EventData","unshift","is","apply","parents","k","handleEvent","undefined","events","j","event","dom7LiveListeners","proxyListener","dom7Listeners","off","_key6","handlers","handler","dom7proxy","splice","trigger","_key9","evt","detail","bubbles","cancelable","data","dataIndex","dispatchEvent","dom","fireCallBack","outerWidth","includeMargins","styles","offsetWidth","parseFloat","outerHeight","offsetHeight","offset","box","getBoundingClientRect","clientTop","clientLeft","scrollTop","scrollY","scrollLeft","scrollX","top","left","css","props","prop","each","index","text","textContent","compareWith","matches","webkitMatchesSelector","msMatchesSelector","child","previousSibling","eq","returnIndex","append","newChild","tempDiv","firstChild","appendChild","prepend","insertBefore","next","nextElementSibling","nextAll","nextEls","prev","previousElementSibling","prevAll","prevEls","parent","parentNode","closest","find","foundElements","found","removeChild","nextTick","delay","now","getTranslate","axis","matrix","curTransform","transformMatrix","curStyle","currentStyle","WebKitCSSMatrix","webkitTransform","replace","join","MozTransform","OTransform","MsTransform","msTransform","toString","m41","m42","o","slice","isNode","node","HTMLElement","to","noExtend","nextSource","keysArray","nextIndex","len","nextKey","desc","getOwnPropertyDescriptor","enumerable","__swiper__","setCSSProperty","varName","varValue","setProperty","animateCSSModeScroll","_ref","swiper","targetPosition","side","startPosition","translate","time","startTime","params","speed","wrapperEl","scrollSnapType","cssModeFrameID","dir","isOutOfBound","current","animate","getTime","progress","Math","max","min","easeProgress","cos","PI","currentPosition","scrollTo","overflow","support","deviceCached","browser","getSupport","smoothScroll","documentElement","touch","DocumentTouch","passiveListener","supportsPassive","opts","gestures","calcSupport","getDevice","overrides","_temp","platform","ua","device","ios","android","screenWidth","width","screenHeight","height","match","ipad","ipod","iphone","windows","macos","os","calcDevice","getBrowser","isSafari","toLowerCase","isWebView","test","calcBrowser","methodName","writable","priority","self","eventsListeners","destroyed","method","once","onceHandler","__emitterProxy","onAny","eventsAnyListeners","offAny","eventHandler","emit","updateSize","$el","clientWidth","clientHeight","isHorizontal","isVertical","parseInt","Number","isNaN","assign","size","updateSlides","getDirectionLabel","property","marginRight","getDirectionPropertyValue","label","$wrapperEl","swiperSize","rtlTranslate","rtl","wrongRTL","isVirtual","virtual","enabled","previousSlidesLength","slides","slideClass","slidesLength","snapGrid","slidesGrid","slidesSizesGrid","offsetBefore","slidesOffsetBefore","offsetAfter","slidesOffsetAfter","previousSnapGridLength","previousSlidesGridLength","spaceBetween","slidePosition","prevSlideSize","virtualSize","marginLeft","marginBottom","marginTop","centeredSlides","cssMode","gridEnabled","grid","rows","slideSize","initSlides","shouldResetSlideSize","slidesPerView","breakpoints","slide","updateSlide","slideStyles","currentTransform","currentWebKitTransform","roundLengths","paddingLeft","paddingRight","boxSizing","floor","swiperSlideSize","abs","slidesPerGroup","slidesPerGroupSkip","effect","setWrapperSize","updateWrapperSize","newSlidesGrid","slidesGridItem","_","slideIndex","centeredSlidesBounds","allSlidesSize","slideSizeValue","maxSnap","snap","centerInsufficientSlides","allSlidesOffset","snapIndex","addToSnapGrid","addToSlidesGrid","v","watchOverflow","checkOverflow","watchSlidesProgress","updateSlidesOffset","backFaceHiddenClass","containerModifierClass","hasClassBackfaceClassAdded","maxBackfaceHiddenSlides","updateAutoHeight","activeSlides","newHeight","setTransition","getSlideByIndex","visibleSlides","ceil","activeIndex","swiperSlideOffset","offsetLeft","offsetTop","updateSlidesProgress","offsetCenter","slideVisibleClass","visibleSlidesIndexes","slideOffset","slideProgress","minTranslate","originalSlideProgress","slideBefore","slideAfter","originalProgress","updateProgress","multiplier","translatesDiff","maxTranslate","isBeginning","isEnd","wasBeginning","wasEnd","autoHeight","updateSlidesClasses","realIndex","activeSlide","slideActiveClass","slideNextClass","slidePrevClass","slideDuplicateActiveClass","slideDuplicateNextClass","slideDuplicatePrevClass","loop","slideDuplicateClass","nextSlide","prevSlide","emitSlidesClasses","updateActiveIndex","newActiveIndex","previousIndex","previousRealIndex","previousSnapIndex","normalizeSlideIndex","skip","initialized","runCallbacksOnInit","updateClickedSlide","slideFound","clickedSlide","clickedIndex","slideToClickedSlide","virtualTranslate","currentTranslate","setTranslate","byController","newProgress","x","y","previousTranslate","translateTo","runCallbacks","translateBounds","internal","animating","preventInteractionOnTransition","newTranslate","isH","behavior","onTranslateToWrapperTransitionEnd","transitionEmit","direction","step","slideTo","initial","Error","indexAsNumber","isFinite","normalizedTranslate","normalizedGrid","normalizedGridNext","allowSlideNext","allowSlidePrev","transitionStart","transitionEnd","t","_immediateVirtual","_swiperImmediateVirtual","onSlideToWrapperTransitionEnd","slideToLoop","newIndex","loopedSlides","slideNext","perGroup","slidesPerGroupAuto","slidesPerViewDynamic","increment","loopPreventsSlide","loopFix","_clientLeft","rewind","slidePrev","normalize","val","normalizedSnapGrid","prevSnap","prevSnapIndex","prevIndex","lastIndex","slideReset","slideToClosest","threshold","currentSnap","slideToIndex","loopCreate","$selector","loopFillGroupWithBlank","blankSlidesNum","blankNode","slideBlankClass","loopAdditionalSlides","loopedSlidesLimit","prependSlides","appendSlides","cloneNode","diff","loopDestroy","onTouchStart","touchEventsData","touches","originalEvent","$targetEl","touchEventsTarget","isTouchEvent","type","which","button","isTouched","isMoved","swipingClassHasValue","noSwipingClass","eventPath","composedPath","path","shadowRoot","noSwipingSelector","isTargetShadow","noSwiping","base","__closestFrom","assignedSlot","getRootNode","closestElement","allowClick","swipeHandler","currentX","targetTouches","pageX","currentY","pageY","startX","startY","edgeSwipeDetection","iOSEdgeSwipeDetection","edgeSwipeThreshold","iOSEdgeSwipeThreshold","innerWidth","preventDefault","allowTouchCallbacks","isScrolling","startMoving","touchStartTime","swipeDirection","allowThresholdMove","focusableElements","shouldPreventDefault","allowTouchMove","touchStartPreventDefault","touchStartForcePreventDefault","isContentEditable","freeMode","onTouchMove","targetTouch","changedTouches","preventedByNestedSwiper","touchReleaseOnEdges","diffX","diffY","sqrt","touchAngle","atan2","touchMoveStopPropagation","nested","stopPropagation","startTranslate","allowMomentumBounce","grabCursor","setGrabCursor","touchRatio","disableParentSwiper","resistanceRatio","resistance","followFinger","onTouchEnd","touchEndTime","timeDiff","pathTree","lastClickTime","currentPos","stopIndex","groupSize","rewindFirstIndex","rewindLastIndex","ratio","longSwipesMs","longSwipes","longSwipesRatio","shortSwipes","navigation","nextEl","prevEl","onResize","setBreakpoint","autoplay","running","paused","run","onClick","preventClicks","preventClicksPropagation","stopImmediatePropagation","onScroll","dummyEventAttached","dummyEventListener","touchEvents","domMethod","swiperMethod","start","passiveListeners","passive","move","end","cancel","updateOnWindowResize","attachEvents","bind","detachEvents","isGridEnabled","addClasses","suffixes","entries","prefix","resultClasses","item","prepareClasses","autoheight","fill","centered","emitContainerClasses","removeClasses","defaults","init","initialSlide","resizeObserver","createElements","url","breakpointsBase","simulateTouch","uniqueNavElements","preloadImages","updateOnImagesReady","wrapperClass","_emitClasses","moduleExtendParams","allModulesParams","moduleParamName","moduleParams","auto","prototypes","eventsEmitter","update","transition","moving","isLocked","cursor","unsetGrabCursor","breakpoint","getBreakpoint","currentBreakpoint","breakpointParams","originalParams","wasMultiRow","isMultiRow","wasEnabled","wasModuleEnabled","isModuleEnabled","disable","enable","directionChanged","needsReLoop","changeDirection","isEnabled","containerEl","currentHeight","innerHeight","points","point","minRatio","substr","sort","b","wasLocked","lastSlideIndex","lastSlideRightEdge","images","loadImage","imageEl","srcset","sizes","checkForComplete","image","onReady","complete","onload","onerror","imagesLoaded","imagesToLoad","currentSrc","extendedDefaults","Swiper","swipers","newParams","modules","__modules__","mod","extendParams","swiperParams","passedParams","eventName","velocity","desktop","touchEventsTouch","touchEventsDesktop","clickTimeout","velocities","setProgress","cls","getSlideClasses","slideEl","updates","view","exact","spv","breakLoop","translateValue","translated","newDirection","needUpdate","currentDirection","changeLanguageDirection","mount","mounted","getWrapperSelector","options","getWrapper","wrapper","destroy","deleteInstance","cleanStyles","object","deleteProps","static","newDefaults","module","m","installModule","createElementIfNotDefined","checkProps","element","classesToSelector","appendSlide","observer","prependSlide","addSlide","activeIndexBuffer","baseLength","slidesBuffer","currentSlide","removeSlide","slidesIndexes","indexToRemove","removeAllSlides","effectInit","overwriteParams","perspective","recreateShadows","getEffectParams","requireUpdateOnVirtual","overwriteParamsResult","_s","slideShadows","effectTarget","effectParams","$slideEl","transformEl","effectVirtualTransitionEnd","allSlides","$transitionEndTarget","eventTriggered","triggerEvents","createShadow","shadowClass","$shadowContainer","$shadowEl","prototypeGroup","protoMethod","use","animationFrame","resizeHandler","orientationChangeHandler","ResizeObserver","newWidth","_ref2","contentBoxSize","contentRect","inlineSize","blockSize","observe","unobserve","observers","attach","MutationObserver","WebkitMutationObserver","mutations","observerUpdate","attributes","childList","characterData","observeParents","observeSlideChildren","containerParents","disconnect","cssModeTimeout","renderSlide","cache","force","addSlidesBefore","addSlidesAfter","from","previousFrom","previousTo","previousSlidesGrid","previousOffset","offsetProp","slidesAfter","slidesBefore","onRendered","lazy","load","renderExternal","slidesToRender","renderExternalUpdate","prependIndexes","appendIndexes","numberOfNewSlides","newCache","cachedIndex","$cachedEl","cachedElIndex","handle","kc","keyCode","charCode","pageUpDown","keyboard","isPageUp","isPageDown","isArrowLeft","isArrowRight","isArrowUp","isArrowDown","shiftKey","altKey","ctrlKey","metaKey","onlyInViewport","inView","swiperWidth","swiperHeight","windowWidth","windowHeight","swiperOffset","swiperCoord","returnValue","timeout","mousewheel","releaseOnEdges","invert","forceToAxis","sensitivity","eventsTarget","thresholdDelta","thresholdTime","lastEventBeforeSnap","lastScrollTime","recentWheelEvents","handleMouseEnter","mouseEntered","handleMouseLeave","animateSlider","newEvent","delta","raw","rtlFactor","sX","sY","pX","pY","wheelDelta","wheelDeltaY","wheelDeltaX","HORIZONTAL_AXIS","deltaY","deltaX","deltaMode","spinX","spinY","pixelX","pixelY","positions","sign","ignoreWheelEvents","position","sticky","shift","prevEvent","firstEvent","snapToThreshold","autoplayDisableOnInteraction","stop","releaseScroll","getEl","toggleEl","disabled","disabledClass","tagName","lockClass","$nextEl","$prevEl","onPrevClick","onNextClick","hideOnClick","hiddenClass","navigationDisabledClass","targetEl","pagination","clickable","isHidden","pfx","bulletSize","bulletElement","renderBullet","renderProgressbar","renderFraction","renderCustom","progressbarOpposite","dynamicBullets","dynamicMainBullets","formatFractionCurrent","number","formatFractionTotal","bulletClass","bulletActiveClass","modifierClass","currentClass","totalClass","progressbarFillClass","progressbarOppositeClass","clickableClass","horizontalClass","verticalClass","paginationDisabledClass","bullets","dynamicBulletIndex","isPaginationDisabled","setSideBullets","$bulletEl","total","paginationType","firstIndex","midIndex","suffix","bullet","$bullet","bulletIndex","$firstDisplayedBullet","$lastDisplayedBullet","dynamicBulletsLength","bulletsOffset","progressbarDirection","scale","scaleX","scaleY","render","paginationHTML","numberOfBullets","dragStartPos","dragSize","trackSize","divider","dragTimeout","scrollbar","$dragEl","newSize","newPos","hide","opacity","display","getPointerPosition","clientX","clientY","setDragPosition","positionRatio","onDragStart","onDragMove","onDragEnd","snapOnRelease","activeListener","eventMethod","$swiperEl","dragClass","dragEl","draggable","scrollbarDisabledClass","parallax","setTransform","p","currentOpacity","currentScale","_swiper","parallaxEl","$parallaxEl","parallaxDuration","zoom","maxRatio","containerClass","zoomedSlideClass","gesturesEnabled","fakeGestureTouched","fakeGestureMoved","isScaling","gesture","slideWidth","slideHeight","$imageEl","$imageWrapEl","minX","minY","maxX","maxY","touchesStart","touchesCurrent","prevPositionX","prevPositionY","prevTime","getDistanceBetweenTouches","x1","y1","x2","y2","onGestureStart","scaleStart","onGestureChange","scaleMove","onGestureEnd","scaledWidth","scaledHeight","onTransitionEnd","zoomIn","touchX","touchY","offsetX","offsetY","translateX","translateY","imageWidth","imageHeight","translateMinX","translateMinY","translateMaxX","translateMaxY","touchAction","zoomOut","zoomToggle","getListeners","activeListenerWithCapture","getSlideSelector","toggleGestures","slideSelector","enableGestures","disableGestures","momentumDurationX","momentumDurationY","momentumDistanceX","newPositionX","momentumDistanceY","newPositionY","momentumDuration","in","out","checkInView","loadPrevNext","loadPrevNextAmount","loadOnTransitionStart","scrollingElement","elementClass","loadingClass","loadedClass","preloaderClass","scrollHandlerAttached","initialImageLoaded","loadInSlide","loadInDuplicate","$images","background","$pictureEl","sourceEl","$source","slideOriginalIndex","slideExist","amount","maxIndex","minIndex","checkInViewOnLoad","$scrollElement","isWindow","scrollElementWidth","scrollElementHeight","LinearSpline","binarySearch","guess","array","i1","i3","interpolate","removeSpline","controller","control","spline","inverse","by","_t","controlled","controlledTranslate","setControlledTranslate","getInterpolateFunction","setControlledTransition","a11y","notificationClass","prevSlideMessage","nextSlideMessage","firstSlideMessage","lastSlideMessage","paginationBulletMessage","slideLabelMessage","containerMessage","containerRoleDescriptionMessage","itemRoleDescriptionMessage","slideRole","clicked","liveRegion","notify","message","notification","makeElFocusable","makeElNotFocusable","addElRole","role","addElRoleDescription","description","addElLabel","disableEl","enableEl","onEnterOrSpaceKey","click","hasPagination","hasClickablePagination","initNavEl","wrapperId","controls","addElControls","handlePointerDown","handlePointerUp","handleFocus","includes","isActive","isVisible","$containerEl","repeat","round","random","live","addElLive","updateNavigation","bulletEl","updatePagination","root","keepQuery","paths","slugify","getPathValues","urlOverride","URL","pathArray","part","setHistory","currentState","state","scrollToSlide","setHistoryPopState","hashNavigation","watchState","onHashChange","newHash","setHash","$activeSlideEl","autoplayResult","reverseDirection","stopOnLastSlide","pause","waitForTransition","onVisibilityChange","visibilityState","onMouseEnter","disableOnInteraction","onMouseLeave","pauseOnMouseEnter","thumbs","multipleActiveThumbs","autoScrollOffset","slideThumbActiveClass","thumbsContainerClass","swiperCreated","onThumbClick","thumbsSwiper","currentIndex","thumbsParams","SwiperClass","thumbsSwiperParams","thumbsToActivate","thumbActiveClass","useOffset","newThumbsIndex","currentThumbsIndex","prevThumbsIndex","nextThumbsIndex","momentum","momentumRatio","momentumBounce","momentumBounceRatio","momentumVelocityRatio","minimumVelocity","lastMoveEvent","pop","velocityEvent","distance","momentumDistance","newPosition","afterBouncePosition","doBounce","bounceAmount","needsLoopFix","moveDistance","currentSlideSize","slidesNumberEvenToRows","slidesPerRow","numFullColumns","newSlideOrderIndex","column","row","groupIndex","slideIndexInGroup","columnsInGroup","order","fadeEffect","crossFade","tx","ty","slideOpacity","cubeEffect","shadow","shadowOffset","shadowScale","createSlideShadows","shadowBefore","shadowAfter","$cubeShadowEl","wrapperRotate","slideAngle","tz","shadowAngle","sin","scale1","scale2","zFactor","flipEffect","limitRotation","rotateY","rotateX","zIndex","coverflowEffect","rotate","stretch","depth","modifier","center","centerOffset","offsetMultiplier","translateZ","slideTransform","$shadowBeforeEl","$shadowAfterEl","creativeEffect","limitProgress","shadowPerProgress","progressMultiplier","getTranslateValue","isCenteredSlides","margin","r","custom","translateString","rotateString","scaleString","opacityString","shadowOpacity","cardsEffect","perSlideRotate","perSlideOffset","tX","tY","tZ","tXAdd","isSwipeToNext","isSwipeToPrev","subProgress","prevY"],"sources":["/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/node_modules/ssr-window/ssr-window.esm.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/node_modules/dom7/dom7.esm.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/shared/dom.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/shared/utils.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/shared/get-support.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/shared/get-device.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/shared/get-browser.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/events-emitter.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/update/index.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/update/updateSize.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/update/updateSlides.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/update/updateAutoHeight.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/update/updateSlidesOffset.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/update/updateSlidesProgress.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/update/updateProgress.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/update/updateSlidesClasses.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/update/updateActiveIndex.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/update/updateClickedSlide.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/translate/index.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/translate/getTranslate.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/translate/setTranslate.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/translate/minTranslate.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/translate/maxTranslate.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/translate/translateTo.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/transition/transitionEmit.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/slide/index.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/slide/slideTo.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/slide/slideToLoop.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/slide/slideNext.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/slide/slidePrev.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/slide/slideReset.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/slide/slideToClosest.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/slide/slideToClickedSlide.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/loop/index.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/loop/loopCreate.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/loop/loopFix.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/loop/loopDestroy.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/events/onTouchStart.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/events/onTouchMove.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/events/onTouchEnd.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/events/onResize.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/events/onClick.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/events/onScroll.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/events/index.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/breakpoints/setBreakpoint.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/classes/index.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/classes/addClasses.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/classes/removeClasses.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/check-overflow/index.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/defaults.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/moduleExtendParams.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/core.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/transition/index.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/transition/setTransition.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/transition/transitionStart.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/transition/transitionEnd.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/grab-cursor/index.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/grab-cursor/setGrabCursor.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/grab-cursor/unsetGrabCursor.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/breakpoints/index.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/breakpoints/getBreakpoint.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/images/index.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/images/loadImage.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/images/preloadImages.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/shared/create-element-if-not-defined.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/shared/classes-to-selector.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/manipulation/methods/appendSlide.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/manipulation/methods/prependSlide.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/manipulation/methods/addSlide.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/manipulation/methods/removeSlide.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/manipulation/methods/removeAllSlides.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/shared/effect-init.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/shared/effect-target.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/shared/effect-virtual-transition-end.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/shared/create-shadow.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/modules/resize/resize.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/core/modules/observer/observer.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/swiper.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/virtual/virtual.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/keyboard/keyboard.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/mousewheel/mousewheel.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/navigation/navigation.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/pagination/pagination.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/scrollbar/scrollbar.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/parallax/parallax.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/zoom/zoom.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/lazy/lazy.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/controller/controller.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/a11y/a11y.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/history/history.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/hash-navigation/hash-navigation.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/autoplay/autoplay.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/thumbs/thumbs.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/free-mode/free-mode.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/grid/grid.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/manipulation/manipulation.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/effect-fade/effect-fade.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/effect-cube/effect-cube.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/effect-flip/effect-flip.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/effect-coverflow/effect-coverflow.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/effect-creative/effect-creative.js","/Users/q605336/Documents/Kelly/Transfer/my-app/src/assets/vendor/src/modules/effect-cards/effect-cards.js"],"sourcesContent":["/**\n * SSR Window 4.0.2\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2021, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: December 13, 2021\n */\n/* eslint-disable no-param-reassign */\nfunction isObject(obj) {\n    return (obj !== null &&\n        typeof obj === 'object' &&\n        'constructor' in obj &&\n        obj.constructor === Object);\n}\nfunction extend(target = {}, src = {}) {\n    Object.keys(src).forEach((key) => {\n        if (typeof target[key] === 'undefined')\n            target[key] = src[key];\n        else if (isObject(src[key]) &&\n            isObject(target[key]) &&\n            Object.keys(src[key]).length > 0) {\n            extend(target[key], src[key]);\n        }\n    });\n}\n\nconst ssrDocument = {\n    body: {},\n    addEventListener() { },\n    removeEventListener() { },\n    activeElement: {\n        blur() { },\n        nodeName: '',\n    },\n    querySelector() {\n        return null;\n    },\n    querySelectorAll() {\n        return [];\n    },\n    getElementById() {\n        return null;\n    },\n    createEvent() {\n        return {\n            initEvent() { },\n        };\n    },\n    createElement() {\n        return {\n            children: [],\n            childNodes: [],\n            style: {},\n            setAttribute() { },\n            getElementsByTagName() {\n                return [];\n            },\n        };\n    },\n    createElementNS() {\n        return {};\n    },\n    importNode() {\n        return null;\n    },\n    location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: '',\n    },\n};\nfunction getDocument() {\n    const doc = typeof document !== 'undefined' ? document : {};\n    extend(doc, ssrDocument);\n    return doc;\n}\n\nconst ssrWindow = {\n    document: ssrDocument,\n    navigator: {\n        userAgent: '',\n    },\n    location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: '',\n    },\n    history: {\n        replaceState() { },\n        pushState() { },\n        go() { },\n        back() { },\n    },\n    CustomEvent: function CustomEvent() {\n        return this;\n    },\n    addEventListener() { },\n    removeEventListener() { },\n    getComputedStyle() {\n        return {\n            getPropertyValue() {\n                return '';\n            },\n        };\n    },\n    Image() { },\n    Date() { },\n    screen: {},\n    setTimeout() { },\n    clearTimeout() { },\n    matchMedia() {\n        return {};\n    },\n    requestAnimationFrame(callback) {\n        if (typeof setTimeout === 'undefined') {\n            callback();\n            return null;\n        }\n        return setTimeout(callback, 0);\n    },\n    cancelAnimationFrame(id) {\n        if (typeof setTimeout === 'undefined') {\n            return;\n        }\n        clearTimeout(id);\n    },\n};\nfunction getWindow() {\n    const win = typeof window !== 'undefined' ? window : {};\n    extend(win, ssrWindow);\n    return win;\n}\n\nexport { extend, getDocument, getWindow, ssrDocument, ssrWindow };\n","/**\n * Dom7 4.0.4\n * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API\n * https://framework7.io/docs/dom7.html\n *\n * Copyright 2022, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: January 11, 2022\n */\nimport { getWindow, getDocument } from 'ssr-window';\n\n/* eslint-disable no-proto */\nfunction makeReactive(obj) {\n  const proto = obj.__proto__;\n  Object.defineProperty(obj, '__proto__', {\n    get() {\n      return proto;\n    },\n\n    set(value) {\n      proto.__proto__ = value;\n    }\n\n  });\n}\n\nclass Dom7 extends Array {\n  constructor(items) {\n    if (typeof items === 'number') {\n      super(items);\n    } else {\n      super(...(items || []));\n      makeReactive(this);\n    }\n  }\n\n}\n\nfunction arrayFlat(arr = []) {\n  const res = [];\n  arr.forEach(el => {\n    if (Array.isArray(el)) {\n      res.push(...arrayFlat(el));\n    } else {\n      res.push(el);\n    }\n  });\n  return res;\n}\nfunction arrayFilter(arr, callback) {\n  return Array.prototype.filter.call(arr, callback);\n}\nfunction arrayUnique(arr) {\n  const uniqueArray = [];\n\n  for (let i = 0; i < arr.length; i += 1) {\n    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);\n  }\n\n  return uniqueArray;\n}\nfunction toCamelCase(string) {\n  return string.toLowerCase().replace(/-(.)/g, (match, group) => group.toUpperCase());\n}\n\n// eslint-disable-next-line\n\nfunction qsa(selector, context) {\n  if (typeof selector !== 'string') {\n    return [selector];\n  }\n\n  const a = [];\n  const res = context.querySelectorAll(selector);\n\n  for (let i = 0; i < res.length; i += 1) {\n    a.push(res[i]);\n  }\n\n  return a;\n}\n\nfunction $(selector, context) {\n  const window = getWindow();\n  const document = getDocument();\n  let arr = [];\n\n  if (!context && selector instanceof Dom7) {\n    return selector;\n  }\n\n  if (!selector) {\n    return new Dom7(arr);\n  }\n\n  if (typeof selector === 'string') {\n    const html = selector.trim();\n\n    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {\n      let toCreate = 'div';\n      if (html.indexOf('<li') === 0) toCreate = 'ul';\n      if (html.indexOf('<tr') === 0) toCreate = 'tbody';\n      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';\n      if (html.indexOf('<tbody') === 0) toCreate = 'table';\n      if (html.indexOf('<option') === 0) toCreate = 'select';\n      const tempParent = document.createElement(toCreate);\n      tempParent.innerHTML = html;\n\n      for (let i = 0; i < tempParent.childNodes.length; i += 1) {\n        arr.push(tempParent.childNodes[i]);\n      }\n    } else {\n      arr = qsa(selector.trim(), context || document);\n    } // arr = qsa(selector, document);\n\n  } else if (selector.nodeType || selector === window || selector === document) {\n    arr.push(selector);\n  } else if (Array.isArray(selector)) {\n    if (selector instanceof Dom7) return selector;\n    arr = selector;\n  }\n\n  return new Dom7(arrayUnique(arr));\n}\n\n$.fn = Dom7.prototype;\n\n// eslint-disable-next-line\n\nfunction addClass(...classes) {\n  const classNames = arrayFlat(classes.map(c => c.split(' ')));\n  this.forEach(el => {\n    el.classList.add(...classNames);\n  });\n  return this;\n}\n\nfunction removeClass(...classes) {\n  const classNames = arrayFlat(classes.map(c => c.split(' ')));\n  this.forEach(el => {\n    el.classList.remove(...classNames);\n  });\n  return this;\n}\n\nfunction toggleClass(...classes) {\n  const classNames = arrayFlat(classes.map(c => c.split(' ')));\n  this.forEach(el => {\n    classNames.forEach(className => {\n      el.classList.toggle(className);\n    });\n  });\n}\n\nfunction hasClass(...classes) {\n  const classNames = arrayFlat(classes.map(c => c.split(' ')));\n  return arrayFilter(this, el => {\n    return classNames.filter(className => el.classList.contains(className)).length > 0;\n  }).length > 0;\n}\n\nfunction attr(attrs, value) {\n  if (arguments.length === 1 && typeof attrs === 'string') {\n    // Get attr\n    if (this[0]) return this[0].getAttribute(attrs);\n    return undefined;\n  } // Set attrs\n\n\n  for (let i = 0; i < this.length; i += 1) {\n    if (arguments.length === 2) {\n      // String\n      this[i].setAttribute(attrs, value);\n    } else {\n      // Object\n      for (const attrName in attrs) {\n        this[i][attrName] = attrs[attrName];\n        this[i].setAttribute(attrName, attrs[attrName]);\n      }\n    }\n  }\n\n  return this;\n}\n\nfunction removeAttr(attr) {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].removeAttribute(attr);\n  }\n\n  return this;\n}\n\nfunction prop(props, value) {\n  if (arguments.length === 1 && typeof props === 'string') {\n    // Get prop\n    if (this[0]) return this[0][props];\n  } else {\n    // Set props\n    for (let i = 0; i < this.length; i += 1) {\n      if (arguments.length === 2) {\n        // String\n        this[i][props] = value;\n      } else {\n        // Object\n        for (const propName in props) {\n          this[i][propName] = props[propName];\n        }\n      }\n    }\n\n    return this;\n  }\n\n  return this;\n}\n\nfunction data(key, value) {\n  let el;\n\n  if (typeof value === 'undefined') {\n    el = this[0];\n    if (!el) return undefined; // Get value\n\n    if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {\n      return el.dom7ElementDataStorage[key];\n    }\n\n    const dataKey = el.getAttribute(`data-${key}`);\n\n    if (dataKey) {\n      return dataKey;\n    }\n\n    return undefined;\n  } // Set value\n\n\n  for (let i = 0; i < this.length; i += 1) {\n    el = this[i];\n    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};\n    el.dom7ElementDataStorage[key] = value;\n  }\n\n  return this;\n}\n\nfunction removeData(key) {\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n\n    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {\n      el.dom7ElementDataStorage[key] = null;\n      delete el.dom7ElementDataStorage[key];\n    }\n  }\n}\n\nfunction dataset() {\n  const el = this[0];\n  if (!el) return undefined;\n  const dataset = {}; // eslint-disable-line\n\n  if (el.dataset) {\n    for (const dataKey in el.dataset) {\n      dataset[dataKey] = el.dataset[dataKey];\n    }\n  } else {\n    for (let i = 0; i < el.attributes.length; i += 1) {\n      const attr = el.attributes[i];\n\n      if (attr.name.indexOf('data-') >= 0) {\n        dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;\n      }\n    }\n  }\n\n  for (const key in dataset) {\n    if (dataset[key] === 'false') dataset[key] = false;else if (dataset[key] === 'true') dataset[key] = true;else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;\n  }\n\n  return dataset;\n}\n\nfunction val(value) {\n  if (typeof value === 'undefined') {\n    // get value\n    const el = this[0];\n    if (!el) return undefined;\n\n    if (el.multiple && el.nodeName.toLowerCase() === 'select') {\n      const values = [];\n\n      for (let i = 0; i < el.selectedOptions.length; i += 1) {\n        values.push(el.selectedOptions[i].value);\n      }\n\n      return values;\n    }\n\n    return el.value;\n  } // set value\n\n\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n\n    if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {\n      for (let j = 0; j < el.options.length; j += 1) {\n        el.options[j].selected = value.indexOf(el.options[j].value) >= 0;\n      }\n    } else {\n      el.value = value;\n    }\n  }\n\n  return this;\n}\n\nfunction value(value) {\n  return this.val(value);\n}\n\nfunction transform(transform) {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].style.transform = transform;\n  }\n\n  return this;\n}\n\nfunction transition(duration) {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;\n  }\n\n  return this;\n}\n\nfunction on(...args) {\n  let [eventType, targetSelector, listener, capture] = args;\n\n  if (typeof args[1] === 'function') {\n    [eventType, listener, capture] = args;\n    targetSelector = undefined;\n  }\n\n  if (!capture) capture = false;\n\n  function handleLiveEvent(e) {\n    const target = e.target;\n    if (!target) return;\n    const eventData = e.target.dom7EventData || [];\n\n    if (eventData.indexOf(e) < 0) {\n      eventData.unshift(e);\n    }\n\n    if ($(target).is(targetSelector)) listener.apply(target, eventData);else {\n      const parents = $(target).parents(); // eslint-disable-line\n\n      for (let k = 0; k < parents.length; k += 1) {\n        if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);\n      }\n    }\n  }\n\n  function handleEvent(e) {\n    const eventData = e && e.target ? e.target.dom7EventData || [] : [];\n\n    if (eventData.indexOf(e) < 0) {\n      eventData.unshift(e);\n    }\n\n    listener.apply(this, eventData);\n  }\n\n  const events = eventType.split(' ');\n  let j;\n\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n\n    if (!targetSelector) {\n      for (j = 0; j < events.length; j += 1) {\n        const event = events[j];\n        if (!el.dom7Listeners) el.dom7Listeners = {};\n        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];\n        el.dom7Listeners[event].push({\n          listener,\n          proxyListener: handleEvent\n        });\n        el.addEventListener(event, handleEvent, capture);\n      }\n    } else {\n      // Live events\n      for (j = 0; j < events.length; j += 1) {\n        const event = events[j];\n        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};\n        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];\n        el.dom7LiveListeners[event].push({\n          listener,\n          proxyListener: handleLiveEvent\n        });\n        el.addEventListener(event, handleLiveEvent, capture);\n      }\n    }\n  }\n\n  return this;\n}\n\nfunction off(...args) {\n  let [eventType, targetSelector, listener, capture] = args;\n\n  if (typeof args[1] === 'function') {\n    [eventType, listener, capture] = args;\n    targetSelector = undefined;\n  }\n\n  if (!capture) capture = false;\n  const events = eventType.split(' ');\n\n  for (let i = 0; i < events.length; i += 1) {\n    const event = events[i];\n\n    for (let j = 0; j < this.length; j += 1) {\n      const el = this[j];\n      let handlers;\n\n      if (!targetSelector && el.dom7Listeners) {\n        handlers = el.dom7Listeners[event];\n      } else if (targetSelector && el.dom7LiveListeners) {\n        handlers = el.dom7LiveListeners[event];\n      }\n\n      if (handlers && handlers.length) {\n        for (let k = handlers.length - 1; k >= 0; k -= 1) {\n          const handler = handlers[k];\n\n          if (listener && handler.listener === listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          } else if (!listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          }\n        }\n      }\n    }\n  }\n\n  return this;\n}\n\nfunction once(...args) {\n  const dom = this;\n  let [eventName, targetSelector, listener, capture] = args;\n\n  if (typeof args[1] === 'function') {\n    [eventName, listener, capture] = args;\n    targetSelector = undefined;\n  }\n\n  function onceHandler(...eventArgs) {\n    listener.apply(this, eventArgs);\n    dom.off(eventName, targetSelector, onceHandler, capture);\n\n    if (onceHandler.dom7proxy) {\n      delete onceHandler.dom7proxy;\n    }\n  }\n\n  onceHandler.dom7proxy = listener;\n  return dom.on(eventName, targetSelector, onceHandler, capture);\n}\n\nfunction trigger(...args) {\n  const window = getWindow();\n  const events = args[0].split(' ');\n  const eventData = args[1];\n\n  for (let i = 0; i < events.length; i += 1) {\n    const event = events[i];\n\n    for (let j = 0; j < this.length; j += 1) {\n      const el = this[j];\n\n      if (window.CustomEvent) {\n        const evt = new window.CustomEvent(event, {\n          detail: eventData,\n          bubbles: true,\n          cancelable: true\n        });\n        el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);\n        el.dispatchEvent(evt);\n        el.dom7EventData = [];\n        delete el.dom7EventData;\n      }\n    }\n  }\n\n  return this;\n}\n\nfunction transitionEnd(callback) {\n  const dom = this;\n\n  function fireCallBack(e) {\n    if (e.target !== this) return;\n    callback.call(this, e);\n    dom.off('transitionend', fireCallBack);\n  }\n\n  if (callback) {\n    dom.on('transitionend', fireCallBack);\n  }\n\n  return this;\n}\n\nfunction animationEnd(callback) {\n  const dom = this;\n\n  function fireCallBack(e) {\n    if (e.target !== this) return;\n    callback.call(this, e);\n    dom.off('animationend', fireCallBack);\n  }\n\n  if (callback) {\n    dom.on('animationend', fireCallBack);\n  }\n\n  return this;\n}\n\nfunction width() {\n  const window = getWindow();\n\n  if (this[0] === window) {\n    return window.innerWidth;\n  }\n\n  if (this.length > 0) {\n    return parseFloat(this.css('width'));\n  }\n\n  return null;\n}\n\nfunction outerWidth(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      const styles = this.styles();\n      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));\n    }\n\n    return this[0].offsetWidth;\n  }\n\n  return null;\n}\n\nfunction height() {\n  const window = getWindow();\n\n  if (this[0] === window) {\n    return window.innerHeight;\n  }\n\n  if (this.length > 0) {\n    return parseFloat(this.css('height'));\n  }\n\n  return null;\n}\n\nfunction outerHeight(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      const styles = this.styles();\n      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));\n    }\n\n    return this[0].offsetHeight;\n  }\n\n  return null;\n}\n\nfunction offset() {\n  if (this.length > 0) {\n    const window = getWindow();\n    const document = getDocument();\n    const el = this[0];\n    const box = el.getBoundingClientRect();\n    const body = document.body;\n    const clientTop = el.clientTop || body.clientTop || 0;\n    const clientLeft = el.clientLeft || body.clientLeft || 0;\n    const scrollTop = el === window ? window.scrollY : el.scrollTop;\n    const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n    return {\n      top: box.top + scrollTop - clientTop,\n      left: box.left + scrollLeft - clientLeft\n    };\n  }\n\n  return null;\n}\n\nfunction hide() {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].style.display = 'none';\n  }\n\n  return this;\n}\n\nfunction show() {\n  const window = getWindow();\n\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n\n    if (el.style.display === 'none') {\n      el.style.display = '';\n    }\n\n    if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {\n      // Still not visible\n      el.style.display = 'block';\n    }\n  }\n\n  return this;\n}\n\nfunction styles() {\n  const window = getWindow();\n  if (this[0]) return window.getComputedStyle(this[0], null);\n  return {};\n}\n\nfunction css(props, value) {\n  const window = getWindow();\n  let i;\n\n  if (arguments.length === 1) {\n    if (typeof props === 'string') {\n      // .css('width')\n      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);\n    } else {\n      // .css({ width: '100px' })\n      for (i = 0; i < this.length; i += 1) {\n        for (const prop in props) {\n          this[i].style[prop] = props[prop];\n        }\n      }\n\n      return this;\n    }\n  }\n\n  if (arguments.length === 2 && typeof props === 'string') {\n    // .css('width', '100px')\n    for (i = 0; i < this.length; i += 1) {\n      this[i].style[props] = value;\n    }\n\n    return this;\n  }\n\n  return this;\n}\n\nfunction each(callback) {\n  if (!callback) return this;\n  this.forEach((el, index) => {\n    callback.apply(el, [el, index]);\n  });\n  return this;\n}\n\nfunction filter(callback) {\n  const result = arrayFilter(this, callback);\n  return $(result);\n}\n\nfunction html(html) {\n  if (typeof html === 'undefined') {\n    return this[0] ? this[0].innerHTML : null;\n  }\n\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].innerHTML = html;\n  }\n\n  return this;\n}\n\nfunction text(text) {\n  if (typeof text === 'undefined') {\n    return this[0] ? this[0].textContent.trim() : null;\n  }\n\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].textContent = text;\n  }\n\n  return this;\n}\n\nfunction is(selector) {\n  const window = getWindow();\n  const document = getDocument();\n  const el = this[0];\n  let compareWith;\n  let i;\n  if (!el || typeof selector === 'undefined') return false;\n\n  if (typeof selector === 'string') {\n    if (el.matches) return el.matches(selector);\n    if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);\n    if (el.msMatchesSelector) return el.msMatchesSelector(selector);\n    compareWith = $(selector);\n\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el) return true;\n    }\n\n    return false;\n  }\n\n  if (selector === document) {\n    return el === document;\n  }\n\n  if (selector === window) {\n    return el === window;\n  }\n\n  if (selector.nodeType || selector instanceof Dom7) {\n    compareWith = selector.nodeType ? [selector] : selector;\n\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el) return true;\n    }\n\n    return false;\n  }\n\n  return false;\n}\n\nfunction index() {\n  let child = this[0];\n  let i;\n\n  if (child) {\n    i = 0; // eslint-disable-next-line\n\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1) i += 1;\n    }\n\n    return i;\n  }\n\n  return undefined;\n}\n\nfunction eq(index) {\n  if (typeof index === 'undefined') return this;\n  const length = this.length;\n\n  if (index > length - 1) {\n    return $([]);\n  }\n\n  if (index < 0) {\n    const returnIndex = length + index;\n    if (returnIndex < 0) return $([]);\n    return $([this[returnIndex]]);\n  }\n\n  return $([this[index]]);\n}\n\nfunction append(...els) {\n  let newChild;\n  const document = getDocument();\n\n  for (let k = 0; k < els.length; k += 1) {\n    newChild = els[k];\n\n    for (let i = 0; i < this.length; i += 1) {\n      if (typeof newChild === 'string') {\n        const tempDiv = document.createElement('div');\n        tempDiv.innerHTML = newChild;\n\n        while (tempDiv.firstChild) {\n          this[i].appendChild(tempDiv.firstChild);\n        }\n      } else if (newChild instanceof Dom7) {\n        for (let j = 0; j < newChild.length; j += 1) {\n          this[i].appendChild(newChild[j]);\n        }\n      } else {\n        this[i].appendChild(newChild);\n      }\n    }\n  }\n\n  return this;\n}\n\nfunction appendTo(parent) {\n  $(parent).append(this);\n  return this;\n}\n\nfunction prepend(newChild) {\n  const document = getDocument();\n  let i;\n  let j;\n\n  for (i = 0; i < this.length; i += 1) {\n    if (typeof newChild === 'string') {\n      const tempDiv = document.createElement('div');\n      tempDiv.innerHTML = newChild;\n\n      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {\n        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);\n      }\n    } else if (newChild instanceof Dom7) {\n      for (j = 0; j < newChild.length; j += 1) {\n        this[i].insertBefore(newChild[j], this[i].childNodes[0]);\n      }\n    } else {\n      this[i].insertBefore(newChild, this[i].childNodes[0]);\n    }\n  }\n\n  return this;\n}\n\nfunction prependTo(parent) {\n  $(parent).prepend(this);\n  return this;\n}\n\nfunction insertBefore(selector) {\n  const before = $(selector);\n\n  for (let i = 0; i < this.length; i += 1) {\n    if (before.length === 1) {\n      before[0].parentNode.insertBefore(this[i], before[0]);\n    } else if (before.length > 1) {\n      for (let j = 0; j < before.length; j += 1) {\n        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);\n      }\n    }\n  }\n}\n\nfunction insertAfter(selector) {\n  const after = $(selector);\n\n  for (let i = 0; i < this.length; i += 1) {\n    if (after.length === 1) {\n      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);\n    } else if (after.length > 1) {\n      for (let j = 0; j < after.length; j += 1) {\n        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);\n      }\n    }\n  }\n}\n\nfunction next(selector) {\n  if (this.length > 0) {\n    if (selector) {\n      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {\n        return $([this[0].nextElementSibling]);\n      }\n\n      return $([]);\n    }\n\n    if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);\n    return $([]);\n  }\n\n  return $([]);\n}\n\nfunction nextAll(selector) {\n  const nextEls = [];\n  let el = this[0];\n  if (!el) return $([]);\n\n  while (el.nextElementSibling) {\n    const next = el.nextElementSibling; // eslint-disable-line\n\n    if (selector) {\n      if ($(next).is(selector)) nextEls.push(next);\n    } else nextEls.push(next);\n\n    el = next;\n  }\n\n  return $(nextEls);\n}\n\nfunction prev(selector) {\n  if (this.length > 0) {\n    const el = this[0];\n\n    if (selector) {\n      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {\n        return $([el.previousElementSibling]);\n      }\n\n      return $([]);\n    }\n\n    if (el.previousElementSibling) return $([el.previousElementSibling]);\n    return $([]);\n  }\n\n  return $([]);\n}\n\nfunction prevAll(selector) {\n  const prevEls = [];\n  let el = this[0];\n  if (!el) return $([]);\n\n  while (el.previousElementSibling) {\n    const prev = el.previousElementSibling; // eslint-disable-line\n\n    if (selector) {\n      if ($(prev).is(selector)) prevEls.push(prev);\n    } else prevEls.push(prev);\n\n    el = prev;\n  }\n\n  return $(prevEls);\n}\n\nfunction siblings(selector) {\n  return this.nextAll(selector).add(this.prevAll(selector));\n}\n\nfunction parent(selector) {\n  const parents = []; // eslint-disable-line\n\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i].parentNode !== null) {\n      if (selector) {\n        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);\n      } else {\n        parents.push(this[i].parentNode);\n      }\n    }\n  }\n\n  return $(parents);\n}\n\nfunction parents(selector) {\n  const parents = []; // eslint-disable-line\n\n  for (let i = 0; i < this.length; i += 1) {\n    let parent = this[i].parentNode; // eslint-disable-line\n\n    while (parent) {\n      if (selector) {\n        if ($(parent).is(selector)) parents.push(parent);\n      } else {\n        parents.push(parent);\n      }\n\n      parent = parent.parentNode;\n    }\n  }\n\n  return $(parents);\n}\n\nfunction closest(selector) {\n  let closest = this; // eslint-disable-line\n\n  if (typeof selector === 'undefined') {\n    return $([]);\n  }\n\n  if (!closest.is(selector)) {\n    closest = closest.parents(selector).eq(0);\n  }\n\n  return closest;\n}\n\nfunction find(selector) {\n  const foundElements = [];\n\n  for (let i = 0; i < this.length; i += 1) {\n    const found = this[i].querySelectorAll(selector);\n\n    for (let j = 0; j < found.length; j += 1) {\n      foundElements.push(found[j]);\n    }\n  }\n\n  return $(foundElements);\n}\n\nfunction children(selector) {\n  const children = []; // eslint-disable-line\n\n  for (let i = 0; i < this.length; i += 1) {\n    const childNodes = this[i].children;\n\n    for (let j = 0; j < childNodes.length; j += 1) {\n      if (!selector || $(childNodes[j]).is(selector)) {\n        children.push(childNodes[j]);\n      }\n    }\n  }\n\n  return $(children);\n}\n\nfunction remove() {\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);\n  }\n\n  return this;\n}\n\nfunction detach() {\n  return this.remove();\n}\n\nfunction add(...els) {\n  const dom = this;\n  let i;\n  let j;\n\n  for (i = 0; i < els.length; i += 1) {\n    const toAdd = $(els[i]);\n\n    for (j = 0; j < toAdd.length; j += 1) {\n      dom.push(toAdd[j]);\n    }\n  }\n\n  return dom;\n}\n\nfunction empty() {\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n\n    if (el.nodeType === 1) {\n      for (let j = 0; j < el.childNodes.length; j += 1) {\n        if (el.childNodes[j].parentNode) {\n          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);\n        }\n      }\n\n      el.textContent = '';\n    }\n  }\n\n  return this;\n}\n\n// eslint-disable-next-line\n\nfunction scrollTo(...args) {\n  const window = getWindow();\n  let [left, top, duration, easing, callback] = args;\n\n  if (args.length === 4 && typeof easing === 'function') {\n    callback = easing;\n    [left, top, duration, callback, easing] = args;\n  }\n\n  if (typeof easing === 'undefined') easing = 'swing';\n  return this.each(function animate() {\n    const el = this;\n    let currentTop;\n    let currentLeft;\n    let maxTop;\n    let maxLeft;\n    let newTop;\n    let newLeft;\n    let scrollTop; // eslint-disable-line\n\n    let scrollLeft; // eslint-disable-line\n\n    let animateTop = top > 0 || top === 0;\n    let animateLeft = left > 0 || left === 0;\n\n    if (typeof easing === 'undefined') {\n      easing = 'swing';\n    }\n\n    if (animateTop) {\n      currentTop = el.scrollTop;\n\n      if (!duration) {\n        el.scrollTop = top;\n      }\n    }\n\n    if (animateLeft) {\n      currentLeft = el.scrollLeft;\n\n      if (!duration) {\n        el.scrollLeft = left;\n      }\n    }\n\n    if (!duration) return;\n\n    if (animateTop) {\n      maxTop = el.scrollHeight - el.offsetHeight;\n      newTop = Math.max(Math.min(top, maxTop), 0);\n    }\n\n    if (animateLeft) {\n      maxLeft = el.scrollWidth - el.offsetWidth;\n      newLeft = Math.max(Math.min(left, maxLeft), 0);\n    }\n\n    let startTime = null;\n    if (animateTop && newTop === currentTop) animateTop = false;\n    if (animateLeft && newLeft === currentLeft) animateLeft = false;\n\n    function render(time = new Date().getTime()) {\n      if (startTime === null) {\n        startTime = time;\n      }\n\n      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n      const easeProgress = easing === 'linear' ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;\n      let done;\n      if (animateTop) scrollTop = currentTop + easeProgress * (newTop - currentTop);\n      if (animateLeft) scrollLeft = currentLeft + easeProgress * (newLeft - currentLeft);\n\n      if (animateTop && newTop > currentTop && scrollTop >= newTop) {\n        el.scrollTop = newTop;\n        done = true;\n      }\n\n      if (animateTop && newTop < currentTop && scrollTop <= newTop) {\n        el.scrollTop = newTop;\n        done = true;\n      }\n\n      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {\n        el.scrollLeft = newLeft;\n        done = true;\n      }\n\n      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {\n        el.scrollLeft = newLeft;\n        done = true;\n      }\n\n      if (done) {\n        if (callback) callback();\n        return;\n      }\n\n      if (animateTop) el.scrollTop = scrollTop;\n      if (animateLeft) el.scrollLeft = scrollLeft;\n      window.requestAnimationFrame(render);\n    }\n\n    window.requestAnimationFrame(render);\n  });\n} // scrollTop(top, duration, easing, callback) {\n\n\nfunction scrollTop(...args) {\n  let [top, duration, easing, callback] = args;\n\n  if (args.length === 3 && typeof easing === 'function') {\n    [top, duration, callback, easing] = args;\n  }\n\n  const dom = this;\n\n  if (typeof top === 'undefined') {\n    if (dom.length > 0) return dom[0].scrollTop;\n    return null;\n  }\n\n  return dom.scrollTo(undefined, top, duration, easing, callback);\n}\n\nfunction scrollLeft(...args) {\n  let [left, duration, easing, callback] = args;\n\n  if (args.length === 3 && typeof easing === 'function') {\n    [left, duration, callback, easing] = args;\n  }\n\n  const dom = this;\n\n  if (typeof left === 'undefined') {\n    if (dom.length > 0) return dom[0].scrollLeft;\n    return null;\n  }\n\n  return dom.scrollTo(left, undefined, duration, easing, callback);\n}\n\n// eslint-disable-next-line\n\nfunction animate(initialProps, initialParams) {\n  const window = getWindow();\n  const els = this;\n  const a = {\n    props: Object.assign({}, initialProps),\n    params: Object.assign({\n      duration: 300,\n      easing: 'swing' // or 'linear'\n\n      /* Callbacks\n      begin(elements)\n      complete(elements)\n      progress(elements, complete, remaining, start, tweenValue)\n      */\n\n    }, initialParams),\n    elements: els,\n    animating: false,\n    que: [],\n\n    easingProgress(easing, progress) {\n      if (easing === 'swing') {\n        return 0.5 - Math.cos(progress * Math.PI) / 2;\n      }\n\n      if (typeof easing === 'function') {\n        return easing(progress);\n      }\n\n      return progress;\n    },\n\n    stop() {\n      if (a.frameId) {\n        window.cancelAnimationFrame(a.frameId);\n      }\n\n      a.animating = false;\n      a.elements.each(el => {\n        const element = el;\n        delete element.dom7AnimateInstance;\n      });\n      a.que = [];\n    },\n\n    done(complete) {\n      a.animating = false;\n      a.elements.each(el => {\n        const element = el;\n        delete element.dom7AnimateInstance;\n      });\n      if (complete) complete(els);\n\n      if (a.que.length > 0) {\n        const que = a.que.shift();\n        a.animate(que[0], que[1]);\n      }\n    },\n\n    animate(props, params) {\n      if (a.animating) {\n        a.que.push([props, params]);\n        return a;\n      }\n\n      const elements = []; // Define & Cache Initials & Units\n\n      a.elements.each((el, index) => {\n        let initialFullValue;\n        let initialValue;\n        let unit;\n        let finalValue;\n        let finalFullValue;\n        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;\n        elements[index] = {\n          container: el\n        };\n        Object.keys(props).forEach(prop => {\n          initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');\n          initialValue = parseFloat(initialFullValue);\n          unit = initialFullValue.replace(initialValue, '');\n          finalValue = parseFloat(props[prop]);\n          finalFullValue = props[prop] + unit;\n          elements[index][prop] = {\n            initialFullValue,\n            initialValue,\n            unit,\n            finalValue,\n            finalFullValue,\n            currentValue: initialValue\n          };\n        });\n      });\n      let startTime = null;\n      let time;\n      let elementsDone = 0;\n      let propsDone = 0;\n      let done;\n      let began = false;\n      a.animating = true;\n\n      function render() {\n        time = new Date().getTime();\n        let progress;\n        let easeProgress; // let el;\n\n        if (!began) {\n          began = true;\n          if (params.begin) params.begin(els);\n        }\n\n        if (startTime === null) {\n          startTime = time;\n        }\n\n        if (params.progress) {\n          // eslint-disable-next-line\n          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);\n        }\n\n        elements.forEach(element => {\n          const el = element;\n          if (done || el.done) return;\n          Object.keys(props).forEach(prop => {\n            if (done || el.done) return;\n            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);\n            easeProgress = a.easingProgress(params.easing, progress);\n            const {\n              initialValue,\n              finalValue,\n              unit\n            } = el[prop];\n            el[prop].currentValue = initialValue + easeProgress * (finalValue - initialValue);\n            const currentValue = el[prop].currentValue;\n\n            if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {\n              el.container.style[prop] = finalValue + unit;\n              propsDone += 1;\n\n              if (propsDone === Object.keys(props).length) {\n                el.done = true;\n                elementsDone += 1;\n              }\n\n              if (elementsDone === elements.length) {\n                done = true;\n              }\n            }\n\n            if (done) {\n              a.done(params.complete);\n              return;\n            }\n\n            el.container.style[prop] = currentValue + unit;\n          });\n        });\n        if (done) return; // Then call\n\n        a.frameId = window.requestAnimationFrame(render);\n      }\n\n      a.frameId = window.requestAnimationFrame(render);\n      return a;\n    }\n\n  };\n\n  if (a.elements.length === 0) {\n    return els;\n  }\n\n  let animateInstance;\n\n  for (let i = 0; i < a.elements.length; i += 1) {\n    if (a.elements[i].dom7AnimateInstance) {\n      animateInstance = a.elements[i].dom7AnimateInstance;\n    } else a.elements[i].dom7AnimateInstance = a;\n  }\n\n  if (!animateInstance) {\n    animateInstance = a;\n  }\n\n  if (initialProps === 'stop') {\n    animateInstance.stop();\n  } else {\n    animateInstance.animate(a.props, a.params);\n  }\n\n  return els;\n}\n\nfunction stop() {\n  const els = this;\n\n  for (let i = 0; i < els.length; i += 1) {\n    if (els[i].dom7AnimateInstance) {\n      els[i].dom7AnimateInstance.stop();\n    }\n  }\n}\n\nconst noTrigger = 'resize scroll'.split(' ');\n\nfunction shortcut(name) {\n  function eventHandler(...args) {\n    if (typeof args[0] === 'undefined') {\n      for (let i = 0; i < this.length; i += 1) {\n        if (noTrigger.indexOf(name) < 0) {\n          if (name in this[i]) this[i][name]();else {\n            $(this[i]).trigger(name);\n          }\n        }\n      }\n\n      return this;\n    }\n\n    return this.on(name, ...args);\n  }\n\n  return eventHandler;\n}\n\nconst click = shortcut('click');\nconst blur = shortcut('blur');\nconst focus = shortcut('focus');\nconst focusin = shortcut('focusin');\nconst focusout = shortcut('focusout');\nconst keyup = shortcut('keyup');\nconst keydown = shortcut('keydown');\nconst keypress = shortcut('keypress');\nconst submit = shortcut('submit');\nconst change = shortcut('change');\nconst mousedown = shortcut('mousedown');\nconst mousemove = shortcut('mousemove');\nconst mouseup = shortcut('mouseup');\nconst mouseenter = shortcut('mouseenter');\nconst mouseleave = shortcut('mouseleave');\nconst mouseout = shortcut('mouseout');\nconst mouseover = shortcut('mouseover');\nconst touchstart = shortcut('touchstart');\nconst touchend = shortcut('touchend');\nconst touchmove = shortcut('touchmove');\nconst resize = shortcut('resize');\nconst scroll = shortcut('scroll');\n\nexport default $;\nexport { $, add, addClass, animate, animationEnd, append, appendTo, attr, blur, change, children, click, closest, css, data, dataset, detach, each, empty, eq, filter, find, focus, focusin, focusout, hasClass, height, hide, html, index, insertAfter, insertBefore, is, keydown, keypress, keyup, mousedown, mouseenter, mouseleave, mousemove, mouseout, mouseover, mouseup, next, nextAll, off, offset, on, once, outerHeight, outerWidth, parent, parents, prepend, prependTo, prev, prevAll, prop, remove, removeAttr, removeClass, removeData, resize, scroll, scrollLeft, scrollTo, scrollTop, show, siblings, stop, styles, submit, text, toggleClass, touchend, touchmove, touchstart, transform, transition, transitionEnd, trigger, val, value, width };\n","import {\n  $,\n  addClass,\n  removeClass,\n  hasClass,\n  toggleClass,\n  attr,\n  removeAttr,\n  transform,\n  transition,\n  on,\n  off,\n  trigger,\n  transitionEnd,\n  outerWidth,\n  outerHeight,\n  styles,\n  offset,\n  css,\n  each,\n  html,\n  text,\n  is,\n  index,\n  eq,\n  append,\n  prepend,\n  next,\n  nextAll,\n  prev,\n  prevAll,\n  parent,\n  parents,\n  closest,\n  find,\n  children,\n  filter,\n  remove,\n} from 'dom7';\n\nconst Methods = {\n  addClass,\n  removeClass,\n  hasClass,\n  toggleClass,\n  attr,\n  removeAttr,\n  transform,\n  transition,\n  on,\n  off,\n  trigger,\n  transitionEnd,\n  outerWidth,\n  outerHeight,\n  styles,\n  offset,\n  css,\n  each,\n  html,\n  text,\n  is,\n  index,\n  eq,\n  append,\n  prepend,\n  next,\n  nextAll,\n  prev,\n  prevAll,\n  parent,\n  parents,\n  closest,\n  find,\n  children,\n  filter,\n  remove,\n};\n\nObject.keys(Methods).forEach((methodName) => {\n  Object.defineProperty($.fn, methodName, { value: Methods[methodName], writable: true });\n});\n\nexport default $;\n","import { getWindow } from 'ssr-window';\n\nfunction deleteProps(obj) {\n  const object = obj;\n  Object.keys(object).forEach((key) => {\n    try {\n      object[key] = null;\n    } catch (e) {\n      // no getter for object\n    }\n    try {\n      delete object[key];\n    } catch (e) {\n      // something got wrong\n    }\n  });\n}\nfunction nextTick(callback, delay = 0) {\n  return setTimeout(callback, delay);\n}\nfunction now() {\n  return Date.now();\n}\nfunction getComputedStyle(el) {\n  const window = getWindow();\n  let style;\n  if (window.getComputedStyle) {\n    style = window.getComputedStyle(el, null);\n  }\n  if (!style && el.currentStyle) {\n    style = el.currentStyle;\n  }\n  if (!style) {\n    style = el.style;\n  }\n\n  return style;\n}\nfunction getTranslate(el, axis = 'x') {\n  const window = getWindow();\n  let matrix;\n  let curTransform;\n  let transformMatrix;\n\n  const curStyle = getComputedStyle(el, null);\n\n  if (window.WebKitCSSMatrix) {\n    curTransform = curStyle.transform || curStyle.webkitTransform;\n    if (curTransform.split(',').length > 6) {\n      curTransform = curTransform\n        .split(', ')\n        .map((a) => a.replace(',', '.'))\n        .join(', ');\n    }\n    // Some old versions of Webkit choke when 'none' is passed; pass\n    // empty string instead in this case\n    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n  } else {\n    transformMatrix =\n      curStyle.MozTransform ||\n      curStyle.OTransform ||\n      curStyle.MsTransform ||\n      curStyle.msTransform ||\n      curStyle.transform ||\n      curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n    matrix = transformMatrix.toString().split(',');\n  }\n\n  if (axis === 'x') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[4]);\n  }\n  if (axis === 'y') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[5]);\n  }\n  return curTransform || 0;\n}\nfunction isObject(o) {\n  return (\n    typeof o === 'object' &&\n    o !== null &&\n    o.constructor &&\n    Object.prototype.toString.call(o).slice(8, -1) === 'Object'\n  );\n}\nfunction isNode(node) {\n  // eslint-disable-next-line\n  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n    return node instanceof HTMLElement;\n  }\n  return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction extend(...args) {\n  const to = Object(args[0]);\n  const noExtend = ['__proto__', 'constructor', 'prototype'];\n  for (let i = 1; i < args.length; i += 1) {\n    const nextSource = args[i];\n    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);\n      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n        const nextKey = keysArray[nextIndex];\n        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n        if (desc !== undefined && desc.enumerable) {\n          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            to[nextKey] = {};\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n  }\n  return to;\n}\n\nfunction setCSSProperty(el, varName, varValue) {\n  el.style.setProperty(varName, varValue);\n}\n\nfunction animateCSSModeScroll({ swiper, targetPosition, side }) {\n  const window = getWindow();\n  const startPosition = -swiper.translate;\n  let startTime = null;\n  let time;\n  const duration = swiper.params.speed;\n\n  swiper.wrapperEl.style.scrollSnapType = 'none';\n  window.cancelAnimationFrame(swiper.cssModeFrameID);\n\n  const dir = targetPosition > startPosition ? 'next' : 'prev';\n\n  const isOutOfBound = (current, target) => {\n    return (dir === 'next' && current >= target) || (dir === 'prev' && current <= target);\n  };\n\n  const animate = () => {\n    time = new Date().getTime();\n    if (startTime === null) {\n      startTime = time;\n    }\n\n    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      currentPosition = targetPosition;\n    }\n    swiper.wrapperEl.scrollTo({\n      [side]: currentPosition,\n    });\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.scrollSnapType = '';\n      setTimeout(() => {\n        swiper.wrapperEl.style.overflow = '';\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition,\n        });\n      });\n      window.cancelAnimationFrame(swiper.cssModeFrameID);\n      return;\n    }\n    swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n  };\n  animate();\n}\n\nexport {\n  animateCSSModeScroll,\n  deleteProps,\n  nextTick,\n  now,\n  getTranslate,\n  isObject,\n  extend,\n  getComputedStyle,\n  setCSSProperty,\n};\n","import { getWindow, getDocument } from 'ssr-window';\n\nlet support;\n\nfunction calcSupport() {\n  const window = getWindow();\n  const document = getDocument();\n\n  return {\n    smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,\n\n    touch: !!(\n      'ontouchstart' in window ||\n      (window.DocumentTouch && document instanceof window.DocumentTouch)\n    ),\n\n    passiveListener: (function checkPassiveListener() {\n      let supportsPassive = false;\n      try {\n        const opts = Object.defineProperty({}, 'passive', {\n          // eslint-disable-next-line\n          get() {\n            supportsPassive = true;\n          },\n        });\n        window.addEventListener('testPassiveListener', null, opts);\n      } catch (e) {\n        // No support\n      }\n      return supportsPassive;\n    })(),\n\n    gestures: (function checkGestures() {\n      return 'ongesturestart' in window;\n    })(),\n  };\n}\n\nfunction getSupport() {\n  if (!support) {\n    support = calcSupport();\n  }\n  return support;\n}\n\nexport { getSupport };\n","import { getWindow } from 'ssr-window';\nimport { getSupport } from './get-support.js';\n\nlet deviceCached;\n\nfunction calcDevice({ userAgent } = {}) {\n  const support = getSupport();\n  const window = getWindow();\n  const platform = window.navigator.platform;\n  const ua = userAgent || window.navigator.userAgent;\n\n  const device = {\n    ios: false,\n    android: false,\n  };\n\n  const screenWidth = window.screen.width;\n  const screenHeight = window.screen.height;\n\n  const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n  const windows = platform === 'Win32';\n  let macos = platform === 'MacIntel';\n\n  // iPadOs 13 fix\n  const iPadScreens = [\n    '1024x1366',\n    '1366x1024',\n    '834x1194',\n    '1194x834',\n    '834x1112',\n    '1112x834',\n    '768x1024',\n    '1024x768',\n    '820x1180',\n    '1180x820',\n    '810x1080',\n    '1080x810',\n  ];\n  if (\n    !ipad &&\n    macos &&\n    support.touch &&\n    iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0\n  ) {\n    ipad = ua.match(/(Version)\\/([\\d.]+)/);\n    if (!ipad) ipad = [0, 1, '13_0_0'];\n    macos = false;\n  }\n\n  // Android\n  if (android && !windows) {\n    device.os = 'android';\n    device.android = true;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = 'ios';\n    device.ios = true;\n  }\n\n  // Export object\n  return device;\n}\n\nfunction getDevice(overrides = {}) {\n  if (!deviceCached) {\n    deviceCached = calcDevice(overrides);\n  }\n  return deviceCached;\n}\n\nexport { getDevice };\n","import { getWindow } from 'ssr-window';\n\nlet browser;\n\nfunction calcBrowser() {\n  const window = getWindow();\n  function isSafari() {\n    const ua = window.navigator.userAgent.toLowerCase();\n    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n  }\n  return {\n    isSafari: isSafari(),\n    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),\n  };\n}\n\nfunction getBrowser() {\n  if (!browser) {\n    browser = calcBrowser();\n  }\n  return browser;\n}\n\nexport { getBrowser };\n","/* eslint-disable no-underscore-dangle */\n\nexport default {\n  on(events, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    events.split(' ').forEach((event) => {\n      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n      self.eventsListeners[event][method](handler);\n    });\n    return self;\n  },\n\n  once(events, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    function onceHandler(...args) {\n      self.off(events, onceHandler);\n      if (onceHandler.__emitterProxy) {\n        delete onceHandler.__emitterProxy;\n      }\n      handler.apply(self, args);\n    }\n    onceHandler.__emitterProxy = handler;\n    return self.on(events, onceHandler, priority);\n  },\n\n  onAny(handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    if (self.eventsAnyListeners.indexOf(handler) < 0) {\n      self.eventsAnyListeners[method](handler);\n    }\n    return self;\n  },\n\n  offAny(handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsAnyListeners) return self;\n    const index = self.eventsAnyListeners.indexOf(handler);\n    if (index >= 0) {\n      self.eventsAnyListeners.splice(index, 1);\n    }\n    return self;\n  },\n\n  off(events, handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsListeners) return self;\n    events.split(' ').forEach((event) => {\n      if (typeof handler === 'undefined') {\n        self.eventsListeners[event] = [];\n      } else if (self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler, index) => {\n          if (\n            eventHandler === handler ||\n            (eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler)\n          ) {\n            self.eventsListeners[event].splice(index, 1);\n          }\n        });\n      }\n    });\n    return self;\n  },\n\n  emit(...args) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsListeners) return self;\n    let events;\n    let data;\n    let context;\n    if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n      events = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n    data.unshift(context);\n    const eventsArray = Array.isArray(events) ? events : events.split(' ');\n\n    eventsArray.forEach((event) => {\n      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n        self.eventsAnyListeners.forEach((eventHandler) => {\n          eventHandler.apply(context, [event, ...data]);\n        });\n      }\n      if (self.eventsListeners && self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler) => {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  },\n};\n","import updateSize from './updateSize.js';\nimport updateSlides from './updateSlides.js';\nimport updateAutoHeight from './updateAutoHeight.js';\nimport updateSlidesOffset from './updateSlidesOffset.js';\nimport updateSlidesProgress from './updateSlidesProgress.js';\nimport updateProgress from './updateProgress.js';\nimport updateSlidesClasses from './updateSlidesClasses.js';\nimport updateActiveIndex from './updateActiveIndex.js';\nimport updateClickedSlide from './updateClickedSlide.js';\n\nexport default {\n  updateSize,\n  updateSlides,\n  updateAutoHeight,\n  updateSlidesOffset,\n  updateSlidesProgress,\n  updateProgress,\n  updateSlidesClasses,\n  updateActiveIndex,\n  updateClickedSlide,\n};\n","export default function updateSize() {\n  const swiper = this;\n  let width;\n  let height;\n  const $el = swiper.$el;\n  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n    width = swiper.params.width;\n  } else {\n    width = $el[0].clientWidth;\n  }\n  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n    height = swiper.params.height;\n  } else {\n    height = $el[0].clientHeight;\n  }\n  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {\n    return;\n  }\n\n  // Subtract paddings\n  width =\n    width -\n    parseInt($el.css('padding-left') || 0, 10) -\n    parseInt($el.css('padding-right') || 0, 10);\n  height =\n    height -\n    parseInt($el.css('padding-top') || 0, 10) -\n    parseInt($el.css('padding-bottom') || 0, 10);\n\n  if (Number.isNaN(width)) width = 0;\n  if (Number.isNaN(height)) height = 0;\n\n  Object.assign(swiper, {\n    width,\n    height,\n    size: swiper.isHorizontal() ? width : height,\n  });\n}\n","import { setCSSProperty } from '../../shared/utils.js';\n\nexport default function updateSlides() {\n  const swiper = this;\n  function getDirectionLabel(property) {\n    if (swiper.isHorizontal()) {\n      return property;\n    }\n    // prettier-ignore\n    return {\n      'width': 'height',\n      'margin-top': 'margin-left',\n      'margin-bottom ': 'margin-right',\n      'margin-left': 'margin-top',\n      'margin-right': 'margin-bottom',\n      'padding-left': 'padding-top',\n      'padding-right': 'padding-bottom',\n      'marginRight': 'marginBottom',\n    }[property];\n  }\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n  }\n\n  const params = swiper.params;\n\n  const { $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;\n  }\n\n  swiper.virtualSize = -spaceBetween;\n\n  // reset margins\n  if (rtl) slides.css({ marginLeft: '', marginBottom: '', marginTop: '' });\n  else slides.css({ marginRight: '', marginBottom: '', marginTop: '' });\n\n  // reset cssMode offsets\n  if (params.centeredSlides && params.cssMode) {\n    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');\n    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');\n  }\n\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n  if (gridEnabled) {\n    swiper.grid.initSlides(slidesLength);\n  }\n\n  // Calc slides\n  let slideSize;\n\n  const shouldResetSlideSize =\n    params.slidesPerView === 'auto' &&\n    params.breakpoints &&\n    Object.keys(params.breakpoints).filter((key) => {\n      return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n    }).length > 0;\n\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    const slide = slides.eq(i);\n    if (gridEnabled) {\n      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n    }\n    if (slide.css('display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      if (shouldResetSlideSize) {\n        slides[i].style[getDirectionLabel('width')] = ``;\n      }\n      const slideStyles = getComputedStyle(slide[0]);\n      const currentTransform = slide[0].style.transform;\n      const currentWebKitTransform = slide[0].style.webkitTransform;\n      if (currentTransform) {\n        slide[0].style.transform = 'none';\n      }\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = 'none';\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);\n      } else {\n        // eslint-disable-next-line\n        const width = getDirectionPropertyValue(slideStyles, 'width');\n        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n        const boxSizing = slideStyles.getPropertyValue('box-sizing');\n        if (boxSizing && boxSizing === 'border-box') {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const { clientWidth, offsetWidth } = slide[0];\n          slideSize =\n            width +\n            paddingLeft +\n            paddingRight +\n            marginLeft +\n            marginRight +\n            (offsetWidth - clientWidth);\n        }\n      }\n      if (currentTransform) {\n        slide[0].style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n\n      if (slides[i]) {\n        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0)\n        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (\n        (index - Math.min(swiper.params.slidesPerGroupSkip, index)) %\n          swiper.params.slidesPerGroup ===\n        0\n      )\n        snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n\n    swiper.virtualSize += slideSize + spaceBetween;\n\n    prevSlideSize = slideSize;\n\n    index += 1;\n  }\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n\n  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });\n  }\n  if (params.setWrapperSize) {\n    $wrapperEl.css({\n      [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`,\n    });\n  }\n\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n  }\n\n  // Remove last grid elements depending on width\n  if (!params.centeredSlides) {\n    const newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n\n    if (\n      Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) >\n      1\n    ) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (snapGrid.length === 0) snapGrid = [0];\n\n  if (params.spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n    slides\n      .filter((_, slideIndex) => {\n        if (!params.cssMode) return true;\n        if (slideIndex === slides.length - 1) {\n          return false;\n        }\n        return true;\n      })\n      .css({ [key]: `${spaceBetween}px` });\n  }\n\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map((snap) => {\n      if (snap < 0) return -offsetBefore;\n      if (snap > maxSnap) return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid,\n  });\n\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n    setCSSProperty(\n      swiper.wrapperEl,\n      '--swiper-centered-offset-after',\n      `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`,\n    );\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);\n  }\n\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n\n  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.$el.removeClass(backFaceHiddenClass);\n    }\n  }\n}\n","import $ from '../../shared/dom.js';\n\nexport default function updateAutoHeight(speed) {\n  const swiper = this;\n  const activeSlides = [];\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  let newHeight = 0;\n  let i;\n  if (typeof speed === 'number') {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n\n  const getSlideByIndex = (index) => {\n    if (isVirtual) {\n      return swiper.slides.filter(\n        (el) => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index,\n      )[0];\n    }\n    return swiper.slides.eq(index)[0];\n  };\n  // Find slides currently in view\n  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n    if (swiper.params.centeredSlides) {\n      (swiper.visibleSlides || $([])).each((slide) => {\n        activeSlides.push(slide);\n      });\n    } else {\n      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n        const index = swiper.activeIndex + i;\n        if (index > swiper.slides.length && !isVirtual) break;\n        activeSlides.push(getSlideByIndex(index));\n      }\n    }\n  } else {\n    activeSlides.push(getSlideByIndex(swiper.activeIndex));\n  }\n\n  // Find new height from highest slide in view\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== 'undefined') {\n      const height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n\n  // Update Height\n  if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);\n}\n","export default function updateSlidesOffset() {\n  const swiper = this;\n  const slides = swiper.slides;\n  for (let i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset = swiper.isHorizontal()\n      ? slides[i].offsetLeft\n      : slides[i].offsetTop;\n  }\n}\n","import $ from '../../shared/dom.js';\n\nexport default function updateSlidesProgress(translate = (this && this.translate) || 0) {\n  const swiper = this;\n  const params = swiper.params;\n\n  const { slides, rtlTranslate: rtl, snapGrid } = swiper;\n\n  if (slides.length === 0) return;\n  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n\n  let offsetCenter = -translate;\n  if (rtl) offsetCenter = translate;\n\n  // Visible Slides\n  slides.removeClass(params.slideVisibleClass);\n\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n\n  for (let i = 0; i < slides.length; i += 1) {\n    const slide = slides[i];\n    let slideOffset = slide.swiperSlideOffset;\n    if (params.cssMode && params.centeredSlides) {\n      slideOffset -= slides[0].swiperSlideOffset;\n    }\n\n    const slideProgress =\n      (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) /\n      (slide.swiperSlideSize + params.spaceBetween);\n    const originalSlideProgress =\n      (offsetCenter -\n        snapGrid[0] +\n        (params.centeredSlides ? swiper.minTranslate() : 0) -\n        slideOffset) /\n      (slide.swiperSlideSize + params.spaceBetween);\n    const slideBefore = -(offsetCenter - slideOffset);\n    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n    const isVisible =\n      (slideBefore >= 0 && slideBefore < swiper.size - 1) ||\n      (slideAfter > 1 && slideAfter <= swiper.size) ||\n      (slideBefore <= 0 && slideAfter >= swiper.size);\n    if (isVisible) {\n      swiper.visibleSlides.push(slide);\n      swiper.visibleSlidesIndexes.push(i);\n      slides.eq(i).addClass(params.slideVisibleClass);\n    }\n    slide.progress = rtl ? -slideProgress : slideProgress;\n    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n  }\n  swiper.visibleSlides = $(swiper.visibleSlides);\n}\n","export default function updateProgress(translate) {\n  const swiper = this;\n  if (typeof translate === 'undefined') {\n    const multiplier = swiper.rtlTranslate ? -1 : 1;\n    // eslint-disable-next-line\n    translate = (swiper && swiper.translate && swiper.translate * multiplier) || 0;\n  }\n  const params = swiper.params;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  let { progress, isBeginning, isEnd } = swiper;\n  const wasBeginning = isBeginning;\n  const wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate - swiper.minTranslate()) / translatesDiff;\n    isBeginning = progress <= 0;\n    isEnd = progress >= 1;\n  }\n  Object.assign(swiper, {\n    progress,\n    isBeginning,\n    isEnd,\n  });\n\n  if (params.watchSlidesProgress || (params.centeredSlides && params.autoHeight))\n    swiper.updateSlidesProgress(translate);\n\n  if (isBeginning && !wasBeginning) {\n    swiper.emit('reachBeginning toEdge');\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit('reachEnd toEdge');\n  }\n  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {\n    swiper.emit('fromEdge');\n  }\n\n  swiper.emit('progress', progress);\n}\n","export default function updateSlidesClasses() {\n  const swiper = this;\n\n  const { slides, params, $wrapperEl, activeIndex, realIndex } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n\n  slides.removeClass(\n    `${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`,\n  );\n\n  let activeSlide;\n  if (isVirtual) {\n    activeSlide = swiper.$wrapperEl.find(\n      `.${params.slideClass}[data-swiper-slide-index=\"${activeIndex}\"]`,\n    );\n  } else {\n    activeSlide = slides.eq(activeIndex);\n  }\n\n  // Active classes\n  activeSlide.addClass(params.slideActiveClass);\n\n  if (params.loop) {\n    // Duplicate to all looped slides\n    if (activeSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children(\n          `.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${realIndex}\"]`,\n        )\n        .addClass(params.slideDuplicateActiveClass);\n    } else {\n      $wrapperEl\n        .children(\n          `.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${realIndex}\"]`,\n        )\n        .addClass(params.slideDuplicateActiveClass);\n    }\n  }\n  // Next Slide\n  let nextSlide = activeSlide\n    .nextAll(`.${params.slideClass}`)\n    .eq(0)\n    .addClass(params.slideNextClass);\n  if (params.loop && nextSlide.length === 0) {\n    nextSlide = slides.eq(0);\n    nextSlide.addClass(params.slideNextClass);\n  }\n  // Prev Slide\n  let prevSlide = activeSlide\n    .prevAll(`.${params.slideClass}`)\n    .eq(0)\n    .addClass(params.slidePrevClass);\n  if (params.loop && prevSlide.length === 0) {\n    prevSlide = slides.eq(-1);\n    prevSlide.addClass(params.slidePrevClass);\n  }\n  if (params.loop) {\n    // Duplicate to all looped slides\n    if (nextSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children(\n          `.${params.slideClass}:not(.${\n            params.slideDuplicateClass\n          })[data-swiper-slide-index=\"${nextSlide.attr('data-swiper-slide-index')}\"]`,\n        )\n        .addClass(params.slideDuplicateNextClass);\n    } else {\n      $wrapperEl\n        .children(\n          `.${params.slideClass}.${\n            params.slideDuplicateClass\n          }[data-swiper-slide-index=\"${nextSlide.attr('data-swiper-slide-index')}\"]`,\n        )\n        .addClass(params.slideDuplicateNextClass);\n    }\n    if (prevSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children(\n          `.${params.slideClass}:not(.${\n            params.slideDuplicateClass\n          })[data-swiper-slide-index=\"${prevSlide.attr('data-swiper-slide-index')}\"]`,\n        )\n        .addClass(params.slideDuplicatePrevClass);\n    } else {\n      $wrapperEl\n        .children(\n          `.${params.slideClass}.${\n            params.slideDuplicateClass\n          }[data-swiper-slide-index=\"${prevSlide.attr('data-swiper-slide-index')}\"]`,\n        )\n        .addClass(params.slideDuplicatePrevClass);\n    }\n  }\n  swiper.emitSlidesClasses();\n}\n","export default function updateActiveIndex(newActiveIndex) {\n  const swiper = this;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  const {\n    slidesGrid,\n    snapGrid,\n    params,\n    activeIndex: previousIndex,\n    realIndex: previousRealIndex,\n    snapIndex: previousSnapIndex,\n  } = swiper;\n  let activeIndex = newActiveIndex;\n  let snapIndex;\n  if (typeof activeIndex === 'undefined') {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (\n          translate >= slidesGrid[i] &&\n          translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2\n        ) {\n          activeIndex = i;\n        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n          activeIndex = i + 1;\n        }\n      } else if (translate >= slidesGrid[i]) {\n        activeIndex = i;\n      }\n    }\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n    }\n  }\n  if (snapGrid.indexOf(translate) >= 0) {\n    snapIndex = snapGrid.indexOf(translate);\n  } else {\n    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  if (activeIndex === previousIndex) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit('snapIndexChange');\n    }\n    return;\n  }\n\n  // Get real index\n  const realIndex = parseInt(\n    swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex,\n    10,\n  );\n\n  Object.assign(swiper, {\n    snapIndex,\n    realIndex,\n    previousIndex,\n    activeIndex,\n  });\n  swiper.emit('activeIndexChange');\n  swiper.emit('snapIndexChange');\n  if (previousRealIndex !== realIndex) {\n    swiper.emit('realIndexChange');\n  }\n  if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n    swiper.emit('slideChange');\n  }\n}\n","import $ from '../../shared/dom.js';\n\nexport default function updateClickedSlide(e) {\n  const swiper = this;\n  const params = swiper.params;\n  const slide = $(e).closest(`.${params.slideClass}`)[0];\n  let slideFound = false;\n  let slideIndex;\n\n  if (slide) {\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide) {\n        slideFound = true;\n        slideIndex = i;\n        break;\n      }\n    }\n  }\n\n  if (slide && slideFound) {\n    swiper.clickedSlide = slide;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);\n    } else {\n      swiper.clickedIndex = slideIndex;\n    }\n  } else {\n    swiper.clickedSlide = undefined;\n    swiper.clickedIndex = undefined;\n    return;\n  }\n  if (\n    params.slideToClickedSlide &&\n    swiper.clickedIndex !== undefined &&\n    swiper.clickedIndex !== swiper.activeIndex\n  ) {\n    swiper.slideToClickedSlide();\n  }\n}\n","import getTranslate from './getTranslate.js';\nimport setTranslate from './setTranslate.js';\nimport minTranslate from './minTranslate.js';\nimport maxTranslate from './maxTranslate.js';\nimport translateTo from './translateTo.js';\n\nexport default {\n  getTranslate,\n  setTranslate,\n  minTranslate,\n  maxTranslate,\n  translateTo,\n};\n","import { getTranslate } from '../../shared/utils.js';\n\nexport default function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {\n  const swiper = this;\n\n  const { params, rtlTranslate: rtl, translate, $wrapperEl } = swiper;\n\n  if (params.virtualTranslate) {\n    return rtl ? -translate : translate;\n  }\n  if (params.cssMode) {\n    return translate;\n  }\n\n  let currentTranslate = getTranslate($wrapperEl[0], axis);\n  if (rtl) currentTranslate = -currentTranslate;\n\n  return currentTranslate || 0;\n}\n","export default function setTranslate(translate, byController) {\n  const swiper = this;\n  const { rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress } = swiper;\n  let x = 0;\n  let y = 0;\n  const z = 0;\n\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate : translate;\n  } else {\n    y = translate;\n  }\n\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n\n  if (params.cssMode) {\n    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n  } else if (!params.virtualTranslate) {\n    $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);\n  }\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y;\n\n  // Check if we need to update progress\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, byController);\n}\n","export default function minTranslate() {\n  return -this.snapGrid[0];\n}\n","export default function maxTranslate() {\n  return -this.snapGrid[this.snapGrid.length - 1];\n}\n","import { animateCSSModeScroll } from '../../shared/utils.js';\n\nexport default function translateTo(\n  translate = 0,\n  speed = this.params.speed,\n  runCallbacks = true,\n  translateBounds = true,\n  internal,\n) {\n  const swiper = this;\n\n  const { params, wrapperEl } = swiper;\n\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n\n  const minTranslate = swiper.minTranslate();\n  const maxTranslate = swiper.maxTranslate();\n  let newTranslate;\n  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;\n  else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;\n  else newTranslate = translate;\n\n  // Update progress\n  swiper.updateProgress(newTranslate);\n\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({ swiper, targetPosition: -newTranslate, side: isH ? 'left' : 'top' });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: -newTranslate,\n        behavior: 'smooth',\n      });\n    }\n    return true;\n  }\n\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionEnd');\n    }\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionStart');\n    }\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onTranslateToWrapperTransitionEnd) {\n        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener(\n            'transitionend',\n            swiper.onTranslateToWrapperTransitionEnd,\n          );\n          swiper.$wrapperEl[0].removeEventListener(\n            'webkitTransitionEnd',\n            swiper.onTranslateToWrapperTransitionEnd,\n          );\n          swiper.onTranslateToWrapperTransitionEnd = null;\n          delete swiper.onTranslateToWrapperTransitionEnd;\n          if (runCallbacks) {\n            swiper.emit('transitionEnd');\n          }\n        };\n      }\n      swiper.$wrapperEl[0].addEventListener(\n        'transitionend',\n        swiper.onTranslateToWrapperTransitionEnd,\n      );\n      swiper.$wrapperEl[0].addEventListener(\n        'webkitTransitionEnd',\n        swiper.onTranslateToWrapperTransitionEnd,\n      );\n    }\n  }\n\n  return true;\n}\n","export default function transitionEmit({ swiper, runCallbacks, direction, step }) {\n  const { activeIndex, previousIndex } = swiper;\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';\n    else if (activeIndex < previousIndex) dir = 'prev';\n    else dir = 'reset';\n  }\n\n  swiper.emit(`transition${step}`);\n\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit(`slideResetTransition${step}`);\n      return;\n    }\n    swiper.emit(`slideChangeTransition${step}`);\n    if (dir === 'next') {\n      swiper.emit(`slideNextTransition${step}`);\n    } else {\n      swiper.emit(`slidePrevTransition${step}`);\n    }\n  }\n}\n","import slideTo from './slideTo.js';\nimport slideToLoop from './slideToLoop.js';\nimport slideNext from './slideNext.js';\nimport slidePrev from './slidePrev.js';\nimport slideReset from './slideReset.js';\nimport slideToClosest from './slideToClosest.js';\nimport slideToClickedSlide from './slideToClickedSlide.js';\n\nexport default {\n  slideTo,\n  slideToLoop,\n  slideNext,\n  slidePrev,\n  slideReset,\n  slideToClosest,\n  slideToClickedSlide,\n};\n","import { animateCSSModeScroll } from '../../shared/utils.js';\n\nexport default function slideTo(\n  index = 0,\n  speed = this.params.speed,\n  runCallbacks = true,\n  internal,\n  initial,\n) {\n  if (typeof index !== 'number' && typeof index !== 'string') {\n    throw new Error(\n      `The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`,\n    );\n  }\n\n  if (typeof index === 'string') {\n    /**\n     * The `index` argument converted from `string` to `number`.\n     * @type {number}\n     */\n    const indexAsNumber = parseInt(index, 10);\n\n    /**\n     * Determines whether the `index` argument is a valid `number`\n     * after being converted from the `string` type.\n     * @type {boolean}\n     */\n    const isValidNumber = isFinite(indexAsNumber);\n\n    if (!isValidNumber) {\n      throw new Error(\n        `The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`,\n      );\n    }\n\n    // Knowing that the converted `index` is a valid number,\n    // we can update the original argument's value.\n    index = indexAsNumber;\n  }\n\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl,\n    enabled,\n  } = swiper;\n\n  if (\n    (swiper.animating && params.preventInteractionOnTransition) ||\n    (!enabled && !internal && !initial)\n  ) {\n    return false;\n  }\n\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n  const translate = -snapGrid[snapIndex];\n\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      const normalizedTranslate = -Math.floor(translate * 100);\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (\n          normalizedTranslate >= normalizedGrid &&\n          normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2\n        ) {\n          slideIndex = i;\n        } else if (\n          normalizedTranslate >= normalizedGrid &&\n          normalizedTranslate < normalizedGridNext\n        ) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  }\n  // Directions locks\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (\n      !swiper.allowSlideNext &&\n      translate < swiper.translate &&\n      translate < swiper.minTranslate()\n    ) {\n      return false;\n    }\n    if (\n      !swiper.allowSlidePrev &&\n      translate > swiper.translate &&\n      translate > swiper.maxTranslate()\n    ) {\n      if ((activeIndex || 0) !== slideIndex) return false;\n    }\n  }\n\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  // Update progress\n  swiper.updateProgress(translate);\n\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';\n  else if (slideIndex < activeIndex) direction = 'prev';\n  else direction = 'reset';\n\n  // Update Index\n  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {\n    swiper.updateActiveIndex(slideIndex);\n    // Update Height\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    const t = rtl ? translate : -translate;\n    if (speed === 0) {\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = 'none';\n        swiper._immediateVirtual = true;\n      }\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n      if (isVirtual) {\n        requestAnimationFrame(() => {\n          swiper.wrapperEl.style.scrollSnapType = '';\n          swiper._swiperImmediateVirtual = false;\n        });\n      }\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({ swiper, targetPosition: t, side: isH ? 'left' : 'top' });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: t,\n        behavior: 'smooth',\n      });\n    }\n    return true;\n  }\n\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit('beforeTransitionStart', speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n        if (!swiper || swiper.destroyed) return;\n        if (e.target !== this) return;\n        swiper.$wrapperEl[0].removeEventListener(\n          'transitionend',\n          swiper.onSlideToWrapperTransitionEnd,\n        );\n        swiper.$wrapperEl[0].removeEventListener(\n          'webkitTransitionEnd',\n          swiper.onSlideToWrapperTransitionEnd,\n        );\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n    swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n    swiper.$wrapperEl[0].addEventListener(\n      'webkitTransitionEnd',\n      swiper.onSlideToWrapperTransitionEnd,\n    );\n  }\n\n  return true;\n}\n","export default function slideToLoop(\n  index = 0,\n  speed = this.params.speed,\n  runCallbacks = true,\n  internal,\n) {\n  if (typeof index === 'string') {\n    /**\n     * The `index` argument converted from `string` to `number`.\n     * @type {number}\n     */\n    const indexAsNumber = parseInt(index, 10);\n\n    /**\n     * Determines whether the `index` argument is a valid `number`\n     * after being converted from the `string` type.\n     * @type {boolean}\n     */\n    const isValidNumber = isFinite(indexAsNumber);\n\n    if (!isValidNumber) {\n      throw new Error(\n        `The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`,\n      );\n    }\n\n    // Knowing that the converted `index` is a valid number,\n    // we can update the original argument's value.\n    index = indexAsNumber;\n  }\n\n  const swiper = this;\n  let newIndex = index;\n  if (swiper.params.loop) {\n    newIndex += swiper.loopedSlides;\n  }\n\n  return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n}\n","/* eslint no-unused-vars: \"off\" */\nexport default function slideNext(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const { animating, enabled, params } = swiper;\n  if (!enabled) return swiper;\n  let perGroup = params.slidesPerGroup;\n  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n  }\n  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n  if (params.loop) {\n    if (animating && params.loopPreventsSlide) return false;\n    swiper.loopFix();\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n  }\n  if (params.rewind && swiper.isEnd) {\n    return swiper.slideTo(0, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\n","/* eslint no-unused-vars: \"off\" */\nexport default function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const { params, animating, snapGrid, slidesGrid, rtlTranslate, enabled } = swiper;\n  if (!enabled) return swiper;\n\n  if (params.loop) {\n    if (animating && params.loopPreventsSlide) return false;\n    swiper.loopFix();\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n  }\n  const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n\n  function normalize(val) {\n    if (val < 0) return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n  const normalizedTranslate = normalize(translate);\n  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));\n\n  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n  if (typeof prevSnap === 'undefined' && params.cssMode) {\n    let prevSnapIndex;\n    snapGrid.forEach((snap, snapIndex) => {\n      if (normalizedTranslate >= snap) {\n        // prevSnap = snap;\n        prevSnapIndex = snapIndex;\n      }\n    });\n    if (typeof prevSnapIndex !== 'undefined') {\n      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n    }\n  }\n  let prevIndex = 0;\n  if (typeof prevSnap !== 'undefined') {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n    if (\n      params.slidesPerView === 'auto' &&\n      params.slidesPerGroup === 1 &&\n      params.slidesPerGroupAuto\n    ) {\n      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n      prevIndex = Math.max(prevIndex, 0);\n    }\n  }\n  if (params.rewind && swiper.isBeginning) {\n    const lastIndex =\n      swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual\n        ? swiper.virtual.slides.length - 1\n        : swiper.slides.length - 1;\n    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n","/* eslint no-unused-vars: \"off\" */\nexport default function slideReset(speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n","/* eslint no-unused-vars: \"off\" */\nexport default function slideToClosest(\n  speed = this.params.speed,\n  runCallbacks = true,\n  internal,\n  threshold = 0.5,\n) {\n  const swiper = this;\n  let index = swiper.activeIndex;\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\n  if (translate >= swiper.snapGrid[snapIndex]) {\n    // The current translate is on or after the current snap index, so the choice\n    // is between the current index and the one after it.\n    const currentSnap = swiper.snapGrid[snapIndex];\n    const nextSnap = swiper.snapGrid[snapIndex + 1];\n    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n      index += swiper.params.slidesPerGroup;\n    }\n  } else {\n    // The current translate is before the current snap index, so the choice\n    // is between the current index and the one before it.\n    const prevSnap = swiper.snapGrid[snapIndex - 1];\n    const currentSnap = swiper.snapGrid[snapIndex];\n    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n      index -= swiper.params.slidesPerGroup;\n    }\n  }\n  index = Math.max(index, 0);\n  index = Math.min(index, swiper.slidesGrid.length - 1);\n\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}\n","import $ from '../../shared/dom.js';\nimport { nextTick } from '../../shared/utils.js';\n\nexport default function slideToClickedSlide() {\n  const swiper = this;\n  const { params, $wrapperEl } = swiper;\n\n  const slidesPerView =\n    params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  let slideToIndex = swiper.clickedIndex;\n  let realIndex;\n  if (params.loop) {\n    if (swiper.animating) return;\n    realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n    if (params.centeredSlides) {\n      if (\n        slideToIndex < swiper.loopedSlides - slidesPerView / 2 ||\n        slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2\n      ) {\n        swiper.loopFix();\n        slideToIndex = $wrapperEl\n          .children(\n            `.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`,\n          )\n          .eq(0)\n          .index();\n\n        nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = $wrapperEl\n        .children(\n          `.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`,\n        )\n        .eq(0)\n        .index();\n\n      nextTick(() => {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\n","import loopCreate from './loopCreate.js';\nimport loopFix from './loopFix.js';\nimport loopDestroy from './loopDestroy.js';\n\nexport default {\n  loopCreate,\n  loopFix,\n  loopDestroy,\n};\n","import { getDocument } from 'ssr-window';\nimport $ from '../../shared/dom.js';\n\nexport default function loopCreate() {\n  const swiper = this;\n  const document = getDocument();\n  const { params, $wrapperEl } = swiper;\n  // Remove duplicated slides\n  const $selector =\n    $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;\n  $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();\n\n  let slides = $selector.children(`.${params.slideClass}`);\n\n  if (params.loopFillGroupWithBlank) {\n    const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);\n    if (blankSlidesNum !== params.slidesPerGroup) {\n      for (let i = 0; i < blankSlidesNum; i += 1) {\n        const blankNode = $(document.createElement('div')).addClass(\n          `${params.slideClass} ${params.slideBlankClass}`,\n        );\n        $selector.append(blankNode);\n      }\n      slides = $selector.children(`.${params.slideClass}`);\n    }\n  }\n\n  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;\n\n  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));\n  swiper.loopedSlides += params.loopAdditionalSlides;\n  if (swiper.loopedSlides > slides.length && swiper.params.loopedSlidesLimit) {\n    swiper.loopedSlides = slides.length;\n  }\n\n  const prependSlides = [];\n  const appendSlides = [];\n\n  slides.each((el, index) => {\n    const slide = $(el);\n    slide.attr('data-swiper-slide-index', index);\n  });\n\n  for (let i = 0; i < swiper.loopedSlides; i += 1) {\n    const index = i - Math.floor(i / slides.length) * slides.length;\n    appendSlides.push(slides.eq(index)[0]);\n    prependSlides.unshift(slides.eq(slides.length - index - 1)[0]);\n  }\n\n  for (let i = 0; i < appendSlides.length; i += 1) {\n    $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {\n    $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n}\n","export default function loopFix() {\n  const swiper = this;\n\n  swiper.emit('beforeLoopFix');\n\n  const {\n    activeIndex,\n    slides,\n    loopedSlides,\n    allowSlidePrev,\n    allowSlideNext,\n    snapGrid,\n    rtlTranslate: rtl,\n  } = swiper;\n  let newIndex;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n\n  const snapTranslate = -snapGrid[activeIndex];\n  const diff = snapTranslate - swiper.getTranslate();\n\n  // Fix For Negative Oversliding\n  if (activeIndex < loopedSlides) {\n    newIndex = slides.length - loopedSlides * 3 + activeIndex;\n    newIndex += loopedSlides;\n    const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n    if (slideChanged && diff !== 0) {\n      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n    }\n  } else if (activeIndex >= slides.length - loopedSlides) {\n    // Fix For Positive Oversliding\n    newIndex = -slides.length + activeIndex + loopedSlides;\n    newIndex += loopedSlides;\n    const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n    if (slideChanged && diff !== 0) {\n      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n    }\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n\n  swiper.emit('loopFix');\n}\n","export default function loopDestroy() {\n  const swiper = this;\n  const { $wrapperEl, params, slides } = swiper;\n  $wrapperEl\n    .children(\n      `.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`,\n    )\n    .remove();\n  slides.removeAttr('data-swiper-slide-index');\n}\n","import { getWindow, getDocument } from 'ssr-window';\nimport $ from '../../shared/dom.js';\nimport { now } from '../../shared/utils.js';\n\n// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\nfunction closestElement(selector, base = this) {\n  function __closestFrom(el) {\n    if (!el || el === getDocument() || el === getWindow()) return null;\n    if (el.assignedSlot) el = el.assignedSlot;\n    const found = el.closest(selector);\n    if (!found && !el.getRootNode) {\n      return null;\n    }\n    return found || __closestFrom(el.getRootNode().host);\n  }\n  return __closestFrom(base);\n}\n\nexport default function onTouchStart(event) {\n  const swiper = this;\n  const document = getDocument();\n  const window = getWindow();\n\n  const data = swiper.touchEventsData;\n  const { params, touches, enabled } = swiper;\n  if (!enabled) return;\n\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n  if (!swiper.animating && params.cssMode && params.loop) {\n    swiper.loopFix();\n  }\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  let $targetEl = $(e.target);\n\n  if (params.touchEventsTarget === 'wrapper') {\n    if (!$targetEl.closest(swiper.wrapperEl).length) return;\n  }\n  data.isTouchEvent = e.type === 'touchstart';\n  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;\n  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;\n  if (data.isTouched && data.isMoved) return;\n\n  // change target el for shadow root component\n  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n  // eslint-disable-next-line\n  const eventPath = event.composedPath ? event.composedPath() : event.path;\n  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n    $targetEl = $(eventPath[0]);\n  }\n\n  const noSwipingSelector = params.noSwipingSelector\n    ? params.noSwipingSelector\n    : `.${params.noSwipingClass}`;\n  const isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n  // use closestElement for shadow root element to get the actual closest for nested shadow root element\n  if (\n    params.noSwiping &&\n    (isTargetShadow\n      ? closestElement(noSwipingSelector, $targetEl[0])\n      : $targetEl.closest(noSwipingSelector)[0])\n  ) {\n    swiper.allowClick = true;\n    return;\n  }\n\n  if (params.swipeHandler) {\n    if (!$targetEl.closest(params.swipeHandler)[0]) return;\n  }\n\n  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n  const startX = touches.currentX;\n  const startY = touches.currentY;\n\n  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n  if (\n    edgeSwipeDetection &&\n    (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)\n  ) {\n    if (edgeSwipeDetection === 'prevent') {\n      event.preventDefault();\n    } else {\n      return;\n    }\n  }\n\n  Object.assign(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: undefined,\n    startMoving: undefined,\n  });\n\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = now();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = undefined;\n  if (params.threshold > 0) data.allowThresholdMove = false;\n  if (e.type !== 'touchstart') {\n    let preventDefault = true;\n    if ($targetEl.is(data.focusableElements)) {\n      preventDefault = false;\n      if ($targetEl[0].nodeName === 'SELECT') {\n        data.isTouched = false;\n      }\n    }\n    if (\n      document.activeElement &&\n      $(document.activeElement).is(data.focusableElements) &&\n      document.activeElement !== $targetEl[0]\n    ) {\n      document.activeElement.blur();\n    }\n\n    const shouldPreventDefault =\n      preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n    if (\n      (params.touchStartForcePreventDefault || shouldPreventDefault) &&\n      !$targetEl[0].isContentEditable\n    ) {\n      e.preventDefault();\n    }\n  }\n  if (\n    swiper.params.freeMode &&\n    swiper.params.freeMode.enabled &&\n    swiper.freeMode &&\n    swiper.animating &&\n    !params.cssMode\n  ) {\n    swiper.freeMode.onTouchStart();\n  }\n  swiper.emit('touchStart', e);\n}\n","import { getDocument } from 'ssr-window';\nimport $ from '../../shared/dom.js';\nimport { now } from '../../shared/utils.js';\n\nexport default function onTouchMove(event) {\n  const document = getDocument();\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const { params, touches, rtlTranslate: rtl, enabled } = swiper;\n  if (!enabled) return;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n    return;\n  }\n  if (data.isTouchEvent && e.type !== 'touchmove') return;\n  const targetTouch =\n    e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);\n  const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;\n  const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    if (!$(e.target).is(data.focusableElements)) {\n      swiper.allowClick = false;\n    }\n    if (data.isTouched) {\n      Object.assign(touches, {\n        startX: pageX,\n        startY: pageY,\n        currentX: pageX,\n        currentY: pageY,\n      });\n      data.touchStartTime = now();\n    }\n    return;\n  }\n  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      // Vertical\n      if (\n        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) ||\n        (pageY > touches.startY && swiper.translate >= swiper.minTranslate())\n      ) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (\n      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) ||\n      (pageX > touches.startX && swiper.translate >= swiper.minTranslate())\n    ) {\n      return;\n    }\n  }\n  if (data.isTouchEvent && document.activeElement) {\n    if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchMove', e);\n  }\n  if (e.targetTouches && e.targetTouches.length > 1) return;\n\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n\n  const diffX = touches.currentX - touches.startX;\n  const diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)\n    return;\n\n  if (typeof data.isScrolling === 'undefined') {\n    let touchAngle;\n    if (\n      (swiper.isHorizontal() && touches.currentY === touches.startY) ||\n      (swiper.isVertical() && touches.currentX === touches.startX)\n    ) {\n      data.isScrolling = false;\n    } else {\n      // eslint-disable-next-line\n      if (diffX * diffX + diffY * diffY >= 25) {\n        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;\n        data.isScrolling = swiper.isHorizontal()\n          ? touchAngle > params.touchAngle\n          : 90 - touchAngle > params.touchAngle;\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit('touchMoveOpposite', e);\n  }\n  if (typeof data.startMoving === 'undefined') {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (data.isScrolling) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  if (!params.cssMode && e.cancelable) {\n    e.preventDefault();\n  }\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n\n  if (!data.isMoved) {\n    if (params.loop && !params.cssMode) {\n      swiper.loopFix();\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');\n    }\n    data.allowMomentumBounce = false;\n    // Grab Cursor\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit('sliderFirstMove', e);\n  }\n  swiper.emit('sliderMove', e);\n  data.isMoved = true;\n\n  let diff = swiper.isHorizontal() ? diffX : diffY;\n  touches.diff = diff;\n\n  diff *= params.touchRatio;\n  if (rtl) diff = -diff;\n\n  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n  data.currentTranslate = diff + data.startTranslate;\n\n  let disableParentSwiper = true;\n  let resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {\n    disableParentSwiper = false;\n    if (params.resistance)\n      data.currentTranslate =\n        swiper.minTranslate() -\n        1 +\n        (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {\n    disableParentSwiper = false;\n    if (params.resistance)\n      data.currentTranslate =\n        swiper.maxTranslate() +\n        1 -\n        (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n  }\n\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n\n  // Directions locks\n  if (\n    !swiper.allowSlideNext &&\n    swiper.swipeDirection === 'next' &&\n    data.currentTranslate < data.startTranslate\n  ) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (\n    !swiper.allowSlidePrev &&\n    swiper.swipeDirection === 'prev' &&\n    data.currentTranslate > data.startTranslate\n  ) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n    data.currentTranslate = data.startTranslate;\n  }\n\n  // Threshold\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal()\n          ? touches.currentX - touches.startX\n          : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n\n  if (!params.followFinger || params.cssMode) return;\n\n  // Update active index in free mode\n  if (\n    (params.freeMode && params.freeMode.enabled && swiper.freeMode) ||\n    params.watchSlidesProgress\n  ) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n    swiper.freeMode.onTouchMove();\n  }\n  // Update progress\n  swiper.updateProgress(data.currentTranslate);\n  // Update translate\n  swiper.setTranslate(data.currentTranslate);\n}\n","import { now, nextTick } from '../../shared/utils.js';\n\nexport default function onTouchEnd(event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n\n  const { params, touches, rtlTranslate: rtl, slidesGrid, enabled } = swiper;\n  if (!enabled) return;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  // Return Grab Cursor\n  if (\n    params.grabCursor &&\n    data.isMoved &&\n    data.isTouched &&\n    (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)\n  ) {\n    swiper.setGrabCursor(false);\n  }\n\n  // Time diff\n  const touchEndTime = now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n\n  // Tap, doubleTap, Click\n  if (swiper.allowClick) {\n    const pathTree = e.path || (e.composedPath && e.composedPath());\n    swiper.updateClickedSlide((pathTree && pathTree[0]) || e.target);\n    swiper.emit('tap click', e);\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = now();\n  nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (\n    !data.isTouched ||\n    !data.isMoved ||\n    !swiper.swipeDirection ||\n    touches.diff === 0 ||\n    data.currentTranslate === data.startTranslate\n  ) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (swiper.params.freeMode && params.freeMode.enabled) {\n    swiper.freeMode.onTouchEnd({ currentPos });\n    return;\n  }\n\n  // Find current slide\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (\n    let i = 0;\n    i < slidesGrid.length;\n    i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup\n  ) {\n    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (typeof slidesGrid[i + increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n\n  let rewindFirstIndex = null;\n  let rewindLastIndex = null;\n  if (params.rewind) {\n    if (swiper.isBeginning) {\n      rewindLastIndex =\n        swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual\n          ? swiper.virtual.slides.length - 1\n          : swiper.slides.length - 1;\n    } else if (swiper.isEnd) {\n      rewindFirstIndex = 0;\n    }\n  }\n  // Find current slide size\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio)\n        swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n      else swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) {\n        swiper.slideTo(stopIndex + increment);\n      } else if (\n        rewindLastIndex !== null &&\n        ratio < 0 &&\n        Math.abs(ratio) > params.longSwipesRatio\n      ) {\n        swiper.slideTo(rewindLastIndex);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    const isNavButtonTarget =\n      swiper.navigation &&\n      (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n      }\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\n","export default function onResize() {\n  const swiper = this;\n\n  const { params, el } = swiper;\n\n  if (el && el.offsetWidth === 0) return;\n\n  // Breakpoints\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n\n  // Save locks\n  const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;\n\n  // Disable locks on resize\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n\n  swiper.updateSize();\n  swiper.updateSlides();\n\n  swiper.updateSlidesClasses();\n  if (\n    (params.slidesPerView === 'auto' || params.slidesPerView > 1) &&\n    swiper.isEnd &&\n    !swiper.isBeginning &&\n    !swiper.params.centeredSlides\n  ) {\n    swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n  } else {\n    swiper.slideTo(swiper.activeIndex, 0, false, true);\n  }\n\n  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n    swiper.autoplay.run();\n  }\n  // Return locks after resize\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\n","export default function onClick(e) {\n  const swiper = this;\n  if (!swiper.enabled) return;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks) e.preventDefault();\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\n","export default function onScroll() {\n  const swiper = this;\n  const { wrapperEl, rtlTranslate, enabled } = swiper;\n  if (!enabled) return;\n  swiper.previousTranslate = swiper.translate;\n  if (swiper.isHorizontal()) {\n    swiper.translate = -wrapperEl.scrollLeft;\n  } else {\n    swiper.translate = -wrapperEl.scrollTop;\n  }\n  // eslint-disable-next-line\n  if (swiper.translate === 0) swiper.translate = 0;\n\n  swiper.updateActiveIndex();\n  swiper.updateSlidesClasses();\n\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== swiper.progress) {\n    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, false);\n}\n","import { getDocument } from 'ssr-window';\n\nimport onTouchStart from './onTouchStart.js';\nimport onTouchMove from './onTouchMove.js';\nimport onTouchEnd from './onTouchEnd.js';\nimport onResize from './onResize.js';\nimport onClick from './onClick.js';\nimport onScroll from './onScroll.js';\n\nlet dummyEventAttached = false;\nfunction dummyEventListener() {}\n\nconst events = (swiper, method) => {\n  const document = getDocument();\n  const { params, touchEvents, el, wrapperEl, device, support } = swiper;\n  const capture = !!params.nested;\n  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n  const swiperMethod = method;\n\n  // Touch Events\n  if (!support.touch) {\n    el[domMethod](touchEvents.start, swiper.onTouchStart, false);\n    document[domMethod](touchEvents.move, swiper.onTouchMove, capture);\n    document[domMethod](touchEvents.end, swiper.onTouchEnd, false);\n  } else {\n    const passiveListener =\n      touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners\n        ? { passive: true, capture: false }\n        : false;\n    el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);\n    el[domMethod](\n      touchEvents.move,\n      swiper.onTouchMove,\n      support.passiveListener ? { passive: false, capture } : capture,\n    );\n    el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);\n    if (touchEvents.cancel) {\n      el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);\n    }\n  }\n  // Prevent Links Clicks\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el[domMethod]('click', swiper.onClick, true);\n  }\n  if (params.cssMode) {\n    wrapperEl[domMethod]('scroll', swiper.onScroll);\n  }\n\n  // Resize handler\n  if (params.updateOnWindowResize) {\n    swiper[swiperMethod](\n      device.ios || device.android\n        ? 'resize orientationchange observerUpdate'\n        : 'resize observerUpdate',\n      onResize,\n      true,\n    );\n  } else {\n    swiper[swiperMethod]('observerUpdate', onResize, true);\n  }\n};\n\nfunction attachEvents() {\n  const swiper = this;\n  const document = getDocument();\n  const { params, support } = swiper;\n\n  swiper.onTouchStart = onTouchStart.bind(swiper);\n  swiper.onTouchMove = onTouchMove.bind(swiper);\n  swiper.onTouchEnd = onTouchEnd.bind(swiper);\n\n  if (params.cssMode) {\n    swiper.onScroll = onScroll.bind(swiper);\n  }\n\n  swiper.onClick = onClick.bind(swiper);\n\n  if (support.touch && !dummyEventAttached) {\n    document.addEventListener('touchstart', dummyEventListener);\n    dummyEventAttached = true;\n  }\n\n  events(swiper, 'on');\n}\n\nfunction detachEvents() {\n  const swiper = this;\n  events(swiper, 'off');\n}\n\nexport default {\n  attachEvents,\n  detachEvents,\n};\n","import { extend } from '../../shared/utils.js';\n\nconst isGridEnabled = (swiper, params) => {\n  return swiper.grid && params.grid && params.grid.rows > 1;\n};\n\nexport default function setBreakpoint() {\n  const swiper = this;\n  const { activeIndex, initialized, loopedSlides = 0, params, $el } = swiper;\n  const breakpoints = params.breakpoints;\n  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;\n\n  // Get breakpoint for window width and update parameters\n  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n\n  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n\n  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n  const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n  const wasMultiRow = isGridEnabled(swiper, params);\n  const isMultiRow = isGridEnabled(swiper, breakpointParams);\n\n  const wasEnabled = params.enabled;\n\n  if (wasMultiRow && !isMultiRow) {\n    $el.removeClass(\n      `${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`,\n    );\n    swiper.emitContainerClasses();\n  } else if (!wasMultiRow && isMultiRow) {\n    $el.addClass(`${params.containerModifierClass}grid`);\n    if (\n      (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column') ||\n      (!breakpointParams.grid.fill && params.grid.fill === 'column')\n    ) {\n      $el.addClass(`${params.containerModifierClass}grid-column`);\n    }\n    swiper.emitContainerClasses();\n  }\n\n  // Toggle navigation, pagination, scrollbar\n  ['navigation', 'pagination', 'scrollbar'].forEach((prop) => {\n    const wasModuleEnabled = params[prop] && params[prop].enabled;\n    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n    if (wasModuleEnabled && !isModuleEnabled) {\n      swiper[prop].disable();\n    }\n    if (!wasModuleEnabled && isModuleEnabled) {\n      swiper[prop].enable();\n    }\n  });\n\n  const directionChanged =\n    breakpointParams.direction && breakpointParams.direction !== params.direction;\n  const needsReLoop =\n    params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n\n  if (directionChanged && initialized) {\n    swiper.changeDirection();\n  }\n  extend(swiper.params, breakpointParams);\n\n  const isEnabled = swiper.params.enabled;\n\n  Object.assign(swiper, {\n    allowTouchMove: swiper.params.allowTouchMove,\n    allowSlideNext: swiper.params.allowSlideNext,\n    allowSlidePrev: swiper.params.allowSlidePrev,\n  });\n\n  if (wasEnabled && !isEnabled) {\n    swiper.disable();\n  } else if (!wasEnabled && isEnabled) {\n    swiper.enable();\n  }\n\n  swiper.currentBreakpoint = breakpoint;\n\n  swiper.emit('_beforeBreakpoint', breakpointParams);\n\n  if (needsReLoop && initialized) {\n    swiper.loopDestroy();\n    swiper.loopCreate();\n    swiper.updateSlides();\n    swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);\n  }\n\n  swiper.emit('breakpoint', breakpointParams);\n}\n","import addClasses from './addClasses.js';\nimport removeClasses from './removeClasses.js';\n\nexport default { addClasses, removeClasses };\n","function prepareClasses(entries, prefix) {\n  const resultClasses = [];\n  entries.forEach((item) => {\n    if (typeof item === 'object') {\n      Object.keys(item).forEach((classNames) => {\n        if (item[classNames]) {\n          resultClasses.push(prefix + classNames);\n        }\n      });\n    } else if (typeof item === 'string') {\n      resultClasses.push(prefix + item);\n    }\n  });\n  return resultClasses;\n}\n\nexport default function addClasses() {\n  const swiper = this;\n  const { classNames, params, rtl, $el, device, support } = swiper;\n  // prettier-ignore\n  const suffixes = prepareClasses([\n    'initialized',\n    params.direction,\n    { 'pointer-events': !support.touch },\n    { 'free-mode': swiper.params.freeMode && params.freeMode.enabled },\n    { 'autoheight': params.autoHeight },\n    { 'rtl': rtl },\n    { 'grid': params.grid && params.grid.rows > 1 },\n    { 'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column' },\n    { 'android': device.android },\n    { 'ios': device.ios },\n    { 'css-mode': params.cssMode },\n    { 'centered': params.cssMode && params.centeredSlides },\n    { 'watch-progress': params.watchSlidesProgress },\n  ], params.containerModifierClass);\n  classNames.push(...suffixes);\n  $el.addClass([...classNames].join(' '));\n  swiper.emitContainerClasses();\n}\n","export default function removeClasses() {\n  const swiper = this;\n  const { $el, classNames } = swiper;\n\n  $el.removeClass(classNames.join(' '));\n  swiper.emitContainerClasses();\n}\n","function checkOverflow() {\n  const swiper = this;\n  const { isLocked: wasLocked, params } = swiper;\n  const { slidesOffsetBefore } = params;\n\n  if (slidesOffsetBefore) {\n    const lastSlideIndex = swiper.slides.length - 1;\n    const lastSlideRightEdge =\n      swiper.slidesGrid[lastSlideIndex] +\n      swiper.slidesSizesGrid[lastSlideIndex] +\n      slidesOffsetBefore * 2;\n    swiper.isLocked = swiper.size > lastSlideRightEdge;\n  } else {\n    swiper.isLocked = swiper.snapGrid.length === 1;\n  }\n  if (params.allowSlideNext === true) {\n    swiper.allowSlideNext = !swiper.isLocked;\n  }\n  if (params.allowSlidePrev === true) {\n    swiper.allowSlidePrev = !swiper.isLocked;\n  }\n\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n  }\n  if (wasLocked !== swiper.isLocked) {\n    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n  }\n}\n\nexport default { checkOverflow };\n","export default {\n  init: true,\n  direction: 'horizontal',\n  touchEventsTarget: 'wrapper',\n  initialSlide: 0,\n  speed: 300,\n  cssMode: false,\n  updateOnWindowResize: true,\n  resizeObserver: true,\n  nested: false,\n  createElements: false,\n  enabled: true,\n  focusableElements: 'input, select, option, textarea, button, video, label',\n\n  // Overrides\n  width: null,\n  height: null,\n\n  //\n  preventInteractionOnTransition: false,\n\n  // ssr\n  userAgent: null,\n  url: null,\n\n  // To support iOS's swipe-to-go-back gesture (when being used in-app).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n\n  // Autoheight\n  autoHeight: false,\n\n  // Set wrapper width\n  setWrapperSize: false,\n\n  // Virtual Translate\n  virtualTranslate: false,\n\n  // Effects\n  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n  // Breakpoints\n  breakpoints: undefined,\n  breakpointsBase: 'window',\n\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerGroup: 1,\n  slidesPerGroupSkip: 0,\n  slidesPerGroupAuto: false,\n  centeredSlides: false,\n  centeredSlidesBounds: false,\n  slidesOffsetBefore: 0, // in px\n  slidesOffsetAfter: 0, // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: true,\n\n  // Round length\n  roundLengths: false,\n\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 0,\n  touchMoveStopPropagation: false,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n\n  // Progress\n  watchSlidesProgress: false,\n\n  // Cursor\n  grabCursor: false,\n\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n\n  // Images\n  preloadImages: true,\n  updateOnImagesReady: true,\n\n  // loop\n  loop: false,\n  loopAdditionalSlides: 0,\n  loopedSlides: null,\n  loopedSlidesLimit: true,\n  loopFillGroupWithBlank: false,\n  loopPreventsSlide: true,\n\n  // rewind\n  rewind: false,\n\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null, // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: 'swiper-no-swiping',\n  noSwipingSelector: null,\n\n  // Passive Listeners\n  passiveListeners: true,\n\n  maxBackfaceHiddenSlides: 10,\n\n  // NS\n  containerModifierClass: 'swiper-', // NEW\n  slideClass: 'swiper-slide',\n  slideBlankClass: 'swiper-slide-invisible-blank',\n  slideActiveClass: 'swiper-slide-active',\n  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',\n  slideVisibleClass: 'swiper-slide-visible',\n  slideDuplicateClass: 'swiper-slide-duplicate',\n  slideNextClass: 'swiper-slide-next',\n  slideDuplicateNextClass: 'swiper-slide-duplicate-next',\n  slidePrevClass: 'swiper-slide-prev',\n  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',\n  wrapperClass: 'swiper-wrapper',\n\n  // Callbacks\n  runCallbacksOnInit: true,\n\n  // Internals\n  _emitClasses: false,\n};\n","import { extend } from '../shared/utils.js';\n\nexport default function moduleExtendParams(params, allModulesParams) {\n  return function extendParams(obj = {}) {\n    const moduleParamName = Object.keys(obj)[0];\n    const moduleParams = obj[moduleParamName];\n    if (typeof moduleParams !== 'object' || moduleParams === null) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if (\n      ['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 &&\n      params[moduleParamName] === true\n    ) {\n      params[moduleParamName] = { auto: true };\n    }\n    if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if (params[moduleParamName] === true) {\n      params[moduleParamName] = { enabled: true };\n    }\n    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n      params[moduleParamName].enabled = true;\n    }\n    if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };\n    extend(allModulesParams, obj);\n  };\n}\n","/* eslint no-param-reassign: \"off\" */\nimport { getDocument } from 'ssr-window';\nimport $ from '../shared/dom.js';\nimport { extend, now, deleteProps } from '../shared/utils.js';\nimport { getSupport } from '../shared/get-support.js';\nimport { getDevice } from '../shared/get-device.js';\nimport { getBrowser } from '../shared/get-browser.js';\n\nimport Resize from './modules/resize/resize.js';\nimport Observer from './modules/observer/observer.js';\n\nimport eventsEmitter from './events-emitter.js';\n\nimport update from './update/index.js';\nimport translate from './translate/index.js';\nimport transition from './transition/index.js';\nimport slide from './slide/index.js';\nimport loop from './loop/index.js';\nimport grabCursor from './grab-cursor/index.js';\nimport events from './events/index.js';\nimport breakpoints from './breakpoints/index.js';\nimport classes from './classes/index.js';\nimport images from './images/index.js';\nimport checkOverflow from './check-overflow/index.js';\n\nimport defaults from './defaults.js';\nimport moduleExtendParams from './moduleExtendParams.js';\n\nconst prototypes = {\n  eventsEmitter,\n  update,\n  translate,\n  transition,\n  slide,\n  loop,\n  grabCursor,\n  events,\n  breakpoints,\n  checkOverflow,\n  classes,\n  images,\n};\n\nconst extendedDefaults = {};\n\nclass Swiper {\n  constructor(...args) {\n    let el;\n    let params;\n    if (\n      args.length === 1 &&\n      args[0].constructor &&\n      Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object'\n    ) {\n      params = args[0];\n    } else {\n      [el, params] = args;\n    }\n    if (!params) params = {};\n\n    params = extend({}, params);\n    if (el && !params.el) params.el = el;\n\n    if (params.el && $(params.el).length > 1) {\n      const swipers = [];\n      $(params.el).each((containerEl) => {\n        const newParams = extend({}, params, { el: containerEl });\n        swipers.push(new Swiper(newParams));\n      });\n      // eslint-disable-next-line no-constructor-return\n      return swipers;\n    }\n\n    // Swiper Instance\n    const swiper = this;\n    swiper.__swiper__ = true;\n    swiper.support = getSupport();\n    swiper.device = getDevice({ userAgent: params.userAgent });\n    swiper.browser = getBrowser();\n\n    swiper.eventsListeners = {};\n    swiper.eventsAnyListeners = [];\n    swiper.modules = [...swiper.__modules__];\n    if (params.modules && Array.isArray(params.modules)) {\n      swiper.modules.push(...params.modules);\n    }\n\n    const allModulesParams = {};\n\n    swiper.modules.forEach((mod) => {\n      mod({\n        swiper,\n        extendParams: moduleExtendParams(params, allModulesParams),\n        on: swiper.on.bind(swiper),\n        once: swiper.once.bind(swiper),\n        off: swiper.off.bind(swiper),\n        emit: swiper.emit.bind(swiper),\n      });\n    });\n\n    // Extend defaults with modules params\n    const swiperParams = extend({}, defaults, allModulesParams);\n\n    // Extend defaults with passed params\n    swiper.params = extend({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = extend({}, swiper.params);\n    swiper.passedParams = extend({}, params);\n\n    // add event listeners\n    if (swiper.params && swiper.params.on) {\n      Object.keys(swiper.params.on).forEach((eventName) => {\n        swiper.on(eventName, swiper.params.on[eventName]);\n      });\n    }\n    if (swiper.params && swiper.params.onAny) {\n      swiper.onAny(swiper.params.onAny);\n    }\n\n    // Save Dom lib\n    swiper.$ = $;\n\n    // Extend Swiper\n    Object.assign(swiper, {\n      enabled: swiper.params.enabled,\n      el,\n\n      // Classes\n      classNames: [],\n\n      // Slides\n      slides: $(),\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n\n      // isDirection\n      isHorizontal() {\n        return swiper.params.direction === 'horizontal';\n      },\n      isVertical() {\n        return swiper.params.direction === 'vertical';\n      },\n\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n\n      //\n      isBeginning: true,\n      isEnd: false,\n\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n\n      // Touch Events\n      touchEvents: (function touchEvents() {\n        const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\n        const desktop = ['pointerdown', 'pointermove', 'pointerup'];\n\n        swiper.touchEventsTouch = {\n          start: touch[0],\n          move: touch[1],\n          end: touch[2],\n          cancel: touch[3],\n        };\n        swiper.touchEventsDesktop = {\n          start: desktop[0],\n          move: desktop[1],\n          end: desktop[2],\n        };\n        return swiper.support.touch || !swiper.params.simulateTouch\n          ? swiper.touchEventsTouch\n          : swiper.touchEventsDesktop;\n      })(),\n      touchEventsData: {\n        isTouched: undefined,\n        isMoved: undefined,\n        allowTouchCallbacks: undefined,\n        touchStartTime: undefined,\n        isScrolling: undefined,\n        currentTranslate: undefined,\n        startTranslate: undefined,\n        allowThresholdMove: undefined,\n        // Form elements to match\n        focusableElements: swiper.params.focusableElements,\n        // Last click time\n        lastClickTime: now(),\n        clickTimeout: undefined,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: undefined,\n        isTouchEvent: undefined,\n        startMoving: undefined,\n      },\n\n      // Clicks\n      allowClick: true,\n\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0,\n      },\n\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0,\n    });\n\n    swiper.emit('_swiper');\n\n    // Init\n    if (swiper.params.init) {\n      swiper.init();\n    }\n\n    // Return app instance\n    // eslint-disable-next-line no-constructor-return\n    return swiper;\n  }\n\n  enable() {\n    const swiper = this;\n    if (swiper.enabled) return;\n    swiper.enabled = true;\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n    swiper.emit('enable');\n  }\n\n  disable() {\n    const swiper = this;\n    if (!swiper.enabled) return;\n    swiper.enabled = false;\n    if (swiper.params.grabCursor) {\n      swiper.unsetGrabCursor();\n    }\n    swiper.emit('disable');\n  }\n\n  setProgress(progress, speed) {\n    const swiper = this;\n    progress = Math.min(Math.max(progress, 0), 1);\n    const min = swiper.minTranslate();\n    const max = swiper.maxTranslate();\n    const current = (max - min) * progress + min;\n    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n\n  emitContainerClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    const cls = swiper.el.className.split(' ').filter((className) => {\n      return (\n        className.indexOf('swiper') === 0 ||\n        className.indexOf(swiper.params.containerModifierClass) === 0\n      );\n    });\n    swiper.emit('_containerClasses', cls.join(' '));\n  }\n\n  getSlideClasses(slideEl) {\n    const swiper = this;\n    if (swiper.destroyed) return '';\n\n    return slideEl.className\n      .split(' ')\n      .filter((className) => {\n        return (\n          className.indexOf('swiper-slide') === 0 ||\n          className.indexOf(swiper.params.slideClass) === 0\n        );\n      })\n      .join(' ');\n  }\n\n  emitSlidesClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    const updates = [];\n    swiper.slides.each((slideEl) => {\n      const classNames = swiper.getSlideClasses(slideEl);\n      updates.push({ slideEl, classNames });\n      swiper.emit('_slideClass', slideEl, classNames);\n    });\n    swiper.emit('_slideClasses', updates);\n  }\n\n  slidesPerViewDynamic(view = 'current', exact = false) {\n    const swiper = this;\n    const { params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex } = swiper;\n    let spv = 1;\n    if (params.centeredSlides) {\n      let slideSize = slides[activeIndex].swiperSlideSize;\n      let breakLoop;\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n      for (let i = activeIndex - 1; i >= 0; i -= 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n    } else {\n      // eslint-disable-next-line\n      if (view === 'current') {\n        for (let i = activeIndex + 1; i < slides.length; i += 1) {\n          const slideInView = exact\n            ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize\n            : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      } else {\n        // previous\n        for (let i = activeIndex - 1; i >= 0; i -= 1) {\n          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      }\n    }\n    return spv;\n  }\n\n  update() {\n    const swiper = this;\n    if (!swiper || swiper.destroyed) return;\n    const { snapGrid, params } = swiper;\n    // Breakpoints\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n\n    function setTranslate() {\n      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      const newTranslate = Math.min(\n        Math.max(translateValue, swiper.maxTranslate()),\n        swiper.minTranslate(),\n      );\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    let translated;\n    if (swiper.params.freeMode && swiper.params.freeMode.enabled) {\n      setTranslate();\n      if (swiper.params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if (\n        (swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) &&\n        swiper.isEnd &&\n        !swiper.params.centeredSlides\n      ) {\n        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate();\n      }\n    }\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n    swiper.emit('update');\n  }\n\n  changeDirection(newDirection, needUpdate = true) {\n    const swiper = this;\n    const currentDirection = swiper.params.direction;\n    if (!newDirection) {\n      // eslint-disable-next-line\n      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n    }\n    if (\n      newDirection === currentDirection ||\n      (newDirection !== 'horizontal' && newDirection !== 'vertical')\n    ) {\n      return swiper;\n    }\n\n    swiper.$el\n      .removeClass(`${swiper.params.containerModifierClass}${currentDirection}`)\n      .addClass(`${swiper.params.containerModifierClass}${newDirection}`);\n    swiper.emitContainerClasses();\n\n    swiper.params.direction = newDirection;\n\n    swiper.slides.each((slideEl) => {\n      if (newDirection === 'vertical') {\n        slideEl.style.width = '';\n      } else {\n        slideEl.style.height = '';\n      }\n    });\n\n    swiper.emit('changeDirection');\n    if (needUpdate) swiper.update();\n\n    return swiper;\n  }\n\n  changeLanguageDirection(direction) {\n    const swiper = this;\n    if ((swiper.rtl && direction === 'rtl') || (!swiper.rtl && direction === 'ltr')) return;\n    swiper.rtl = direction === 'rtl';\n    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n    if (swiper.rtl) {\n      swiper.$el.addClass(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = 'rtl';\n    } else {\n      swiper.$el.removeClass(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = 'ltr';\n    }\n    swiper.update();\n  }\n\n  mount(el) {\n    const swiper = this;\n    if (swiper.mounted) return true;\n\n    // Find el\n    const $el = $(el || swiper.params.el);\n    el = $el[0];\n\n    if (!el) {\n      return false;\n    }\n\n    el.swiper = swiper;\n\n    const getWrapperSelector = () => {\n      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n    };\n\n    const getWrapper = () => {\n      if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n        const res = $(el.shadowRoot.querySelector(getWrapperSelector()));\n        // Children needs to return slot items\n        res.children = (options) => $el.children(options);\n        return res;\n      }\n      if (!$el.children) {\n        return $($el).children(getWrapperSelector());\n      }\n      return $el.children(getWrapperSelector());\n    };\n    // Find Wrapper\n    let $wrapperEl = getWrapper();\n    if ($wrapperEl.length === 0 && swiper.params.createElements) {\n      const document = getDocument();\n      const wrapper = document.createElement('div');\n      $wrapperEl = $(wrapper);\n      wrapper.className = swiper.params.wrapperClass;\n      $el.append(wrapper);\n      $el.children(`.${swiper.params.slideClass}`).each((slideEl) => {\n        $wrapperEl.append(slideEl);\n      });\n    }\n\n    Object.assign(swiper, {\n      $el,\n      el,\n      $wrapperEl,\n      wrapperEl: $wrapperEl[0],\n      mounted: true,\n\n      // RTL\n      rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',\n      rtlTranslate:\n        swiper.params.direction === 'horizontal' &&\n        (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\n      wrongRTL: $wrapperEl.css('display') === '-webkit-box',\n    });\n\n    return true;\n  }\n\n  init(el) {\n    const swiper = this;\n    if (swiper.initialized) return swiper;\n\n    const mounted = swiper.mount(el);\n    if (mounted === false) return swiper;\n\n    swiper.emit('beforeInit');\n\n    // Set breakpoint\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    // Add Classes\n    swiper.addClasses();\n\n    // Create loop\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    }\n\n    // Update size\n    swiper.updateSize();\n\n    // Update slides\n    swiper.updateSlides();\n\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    }\n\n    // Set Grab Cursor\n    if (swiper.params.grabCursor && swiper.enabled) {\n      swiper.setGrabCursor();\n    }\n\n    if (swiper.params.preloadImages) {\n      swiper.preloadImages();\n    }\n\n    // Slide To Initial Slide\n    if (swiper.params.loop) {\n      swiper.slideTo(\n        swiper.params.initialSlide + swiper.loopedSlides,\n        0,\n        swiper.params.runCallbacksOnInit,\n        false,\n        true,\n      );\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n    }\n\n    // Attach events\n    swiper.attachEvents();\n\n    // Init Flag\n    swiper.initialized = true;\n\n    // Emit\n    swiper.emit('init');\n    swiper.emit('afterInit');\n\n    return swiper;\n  }\n\n  destroy(deleteInstance = true, cleanStyles = true) {\n    const swiper = this;\n    const { params, $el, $wrapperEl, slides } = swiper;\n\n    if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n      return null;\n    }\n\n    swiper.emit('beforeDestroy');\n\n    // Init Flag\n    swiper.initialized = false;\n\n    // Detach events\n    swiper.detachEvents();\n\n    // Destroy loop\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n\n    // Cleanup styles\n    if (cleanStyles) {\n      swiper.removeClasses();\n      $el.removeAttr('style');\n      $wrapperEl.removeAttr('style');\n      if (slides && slides.length) {\n        slides\n          .removeClass(\n            [\n              params.slideVisibleClass,\n              params.slideActiveClass,\n              params.slideNextClass,\n              params.slidePrevClass,\n            ].join(' '),\n          )\n          .removeAttr('style')\n          .removeAttr('data-swiper-slide-index');\n      }\n    }\n\n    swiper.emit('destroy');\n\n    // Detach emitter events\n    Object.keys(swiper.eventsListeners).forEach((eventName) => {\n      swiper.off(eventName);\n    });\n\n    if (deleteInstance !== false) {\n      swiper.$el[0].swiper = null;\n      deleteProps(swiper);\n    }\n    swiper.destroyed = true;\n\n    return null;\n  }\n\n  static extendDefaults(newDefaults) {\n    extend(extendedDefaults, newDefaults);\n  }\n\n  static get extendedDefaults() {\n    return extendedDefaults;\n  }\n\n  static get defaults() {\n    return defaults;\n  }\n\n  static installModule(mod) {\n    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n    const modules = Swiper.prototype.__modules__;\n\n    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n      modules.push(mod);\n    }\n  }\n\n  static use(module) {\n    if (Array.isArray(module)) {\n      module.forEach((m) => Swiper.installModule(m));\n      return Swiper;\n    }\n    Swiper.installModule(module);\n    return Swiper;\n  }\n}\n\nObject.keys(prototypes).forEach((prototypeGroup) => {\n  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n  });\n});\n\nSwiper.use([Resize, Observer]);\n\nexport default Swiper;\n","import setTransition from './setTransition.js';\nimport transitionStart from './transitionStart.js';\nimport transitionEnd from './transitionEnd.js';\n\nexport default {\n  setTransition,\n  transitionStart,\n  transitionEnd,\n};\n","export default function setTransition(duration, byController) {\n  const swiper = this;\n\n  if (!swiper.params.cssMode) {\n    swiper.$wrapperEl.transition(duration);\n  }\n\n  swiper.emit('setTransition', duration, byController);\n}\n","import transitionEmit from './transitionEmit.js';\n\nexport default function transitionStart(runCallbacks = true, direction) {\n  const swiper = this;\n  const { params } = swiper;\n  if (params.cssMode) return;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n\n  transitionEmit({ swiper, runCallbacks, direction, step: 'Start' });\n}\n","import transitionEmit from './transitionEmit.js';\n\nexport default function transitionEnd(runCallbacks = true, direction) {\n  const swiper = this;\n  const { params } = swiper;\n  swiper.animating = false;\n  if (params.cssMode) return;\n  swiper.setTransition(0);\n\n  transitionEmit({ swiper, runCallbacks, direction, step: 'End' });\n}\n","import setGrabCursor from './setGrabCursor.js';\nimport unsetGrabCursor from './unsetGrabCursor.js';\n\nexport default {\n  setGrabCursor,\n  unsetGrabCursor,\n};\n","export default function setGrabCursor(moving) {\n  const swiper = this;\n  if (\n    swiper.support.touch ||\n    !swiper.params.simulateTouch ||\n    (swiper.params.watchOverflow && swiper.isLocked) ||\n    swiper.params.cssMode\n  )\n    return;\n  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n  el.style.cursor = 'move';\n  el.style.cursor = moving ? 'grabbing' : 'grab';\n}\n","export default function unsetGrabCursor() {\n  const swiper = this;\n  if (\n    swiper.support.touch ||\n    (swiper.params.watchOverflow && swiper.isLocked) ||\n    swiper.params.cssMode\n  ) {\n    return;\n  }\n  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n}\n","import setBreakpoint from './setBreakpoint.js';\nimport getBreakpoint from './getBreakpoint.js';\n\nexport default { setBreakpoint, getBreakpoint };\n","import { getWindow } from 'ssr-window';\n\nexport default function getBreakpoint(breakpoints, base = 'window', containerEl) {\n  if (!breakpoints || (base === 'container' && !containerEl)) return undefined;\n  let breakpoint = false;\n\n  const window = getWindow();\n  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n\n  const points = Object.keys(breakpoints).map((point) => {\n    if (typeof point === 'string' && point.indexOf('@') === 0) {\n      const minRatio = parseFloat(point.substr(1));\n      const value = currentHeight * minRatio;\n      return { value, point };\n    }\n    return { value: point, point };\n  });\n\n  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n  for (let i = 0; i < points.length; i += 1) {\n    const { point, value } = points[i];\n    if (base === 'window') {\n      if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n        breakpoint = point;\n      }\n    } else if (value <= containerEl.clientWidth) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || 'max';\n}\n","import loadImage from './loadImage.js';\nimport preloadImages from './preloadImages.js';\n\nexport default {\n  loadImage,\n  preloadImages,\n};\n","import { getWindow } from 'ssr-window';\nimport $ from '../../shared/dom.js';\n\nexport default function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {\n  const window = getWindow();\n  let image;\n  function onReady() {\n    if (callback) callback();\n  }\n  const isPicture = $(imageEl).parent('picture')[0];\n\n  if (!isPicture && (!imageEl.complete || !checkForComplete)) {\n    if (src) {\n      image = new window.Image();\n      image.onload = onReady;\n      image.onerror = onReady;\n      if (sizes) {\n        image.sizes = sizes;\n      }\n      if (srcset) {\n        image.srcset = srcset;\n      }\n      if (src) {\n        image.src = src;\n      }\n    } else {\n      onReady();\n    }\n  } else {\n    // image already loaded...\n    onReady();\n  }\n}\n","export default function preloadImages() {\n  const swiper = this;\n  swiper.imagesToLoad = swiper.$el.find('img');\n  function onReady() {\n    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;\n    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;\n    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {\n      if (swiper.params.updateOnImagesReady) swiper.update();\n      swiper.emit('imagesReady');\n    }\n  }\n  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {\n    const imageEl = swiper.imagesToLoad[i];\n    swiper.loadImage(\n      imageEl,\n      imageEl.currentSrc || imageEl.getAttribute('src'),\n      imageEl.srcset || imageEl.getAttribute('srcset'),\n      imageEl.sizes || imageEl.getAttribute('sizes'),\n      true,\n      onReady,\n    );\n  }\n}\n","import { getDocument } from 'ssr-window';\n\nexport default function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n  const document = getDocument();\n  if (swiper.params.createElements) {\n    Object.keys(checkProps).forEach((key) => {\n      if (!params[key] && params.auto === true) {\n        let element = swiper.$el.children(`.${checkProps[key]}`)[0];\n        if (!element) {\n          element = document.createElement('div');\n          element.className = checkProps[key];\n          swiper.$el.append(element);\n        }\n        params[key] = element;\n        originalParams[key] = element;\n      }\n    });\n  }\n  return params;\n}\n","export default function classesToSelector(classes = '') {\n  return `.${classes\n    .trim()\n    .replace(/([\\.:!\\/])/g, '\\\\$1') // eslint-disable-line\n    .replace(/ /g, '.')}`;\n}\n","export default function appendSlide(slides) {\n  const swiper = this;\n  const { $wrapperEl, params } = swiper;\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.append(slides[i]);\n    }\n  } else {\n    $wrapperEl.append(slides);\n  }\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer) {\n    swiper.update();\n  }\n}\n","export default function prependSlide(slides) {\n  const swiper = this;\n  const { params, $wrapperEl, activeIndex } = swiper;\n\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndex + 1;\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.prepend(slides[i]);\n    }\n    newActiveIndex = activeIndex + slides.length;\n  } else {\n    $wrapperEl.prepend(slides);\n  }\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer) {\n    swiper.update();\n  }\n  swiper.slideTo(newActiveIndex, 0, false);\n}\n","export default function addSlide(index, slides) {\n  const swiper = this;\n  const { $wrapperEl, params, activeIndex } = swiper;\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);\n  }\n  const baseLength = swiper.slides.length;\n  if (index <= 0) {\n    swiper.prependSlide(slides);\n    return;\n  }\n  if (index >= baseLength) {\n    swiper.appendSlide(slides);\n    return;\n  }\n  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n\n  const slidesBuffer = [];\n  for (let i = baseLength - 1; i >= index; i -= 1) {\n    const currentSlide = swiper.slides.eq(i);\n    currentSlide.remove();\n    slidesBuffer.unshift(currentSlide);\n  }\n\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.append(slides[i]);\n    }\n    newActiveIndex =\n      activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n  } else {\n    $wrapperEl.append(slides);\n  }\n\n  for (let i = 0; i < slidesBuffer.length; i += 1) {\n    $wrapperEl.append(slidesBuffer[i]);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n","export default function removeSlide(slidesIndexes) {\n  const swiper = this;\n  const { params, $wrapperEl, activeIndex } = swiper;\n\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);\n  }\n  let newActiveIndex = activeIndexBuffer;\n  let indexToRemove;\n\n  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n    for (let i = 0; i < slidesIndexes.length; i += 1) {\n      indexToRemove = slidesIndexes[i];\n      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    }\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  } else {\n    indexToRemove = slidesIndexes;\n    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n\n  if (!params.observer) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n","export default function removeAllSlides() {\n  const swiper = this;\n\n  const slidesIndexes = [];\n  for (let i = 0; i < swiper.slides.length; i += 1) {\n    slidesIndexes.push(i);\n  }\n  swiper.removeSlide(slidesIndexes);\n}\n","export default function effectInit(params) {\n  const {\n    effect,\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams,\n    perspective,\n    recreateShadows,\n    getEffectParams,\n  } = params;\n\n  on('beforeInit', () => {\n    if (swiper.params.effect !== effect) return;\n    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n    if (perspective && perspective()) {\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n    }\n\n    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n\n    Object.assign(swiper.params, overwriteParamsResult);\n    Object.assign(swiper.originalParams, overwriteParamsResult);\n  });\n  on('setTranslate', () => {\n    if (swiper.params.effect !== effect) return;\n    setTranslate();\n  });\n  on('setTransition', (_s, duration) => {\n    if (swiper.params.effect !== effect) return;\n    setTransition(duration);\n  });\n\n  on('transitionEnd', () => {\n    if (swiper.params.effect !== effect) return;\n    if (recreateShadows) {\n      if (!getEffectParams || !getEffectParams().slideShadows) return;\n      // remove shadows\n      swiper.slides.each((slideEl) => {\n        const $slideEl = swiper.$(slideEl);\n        $slideEl\n          .find(\n            '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n          )\n          .remove();\n      });\n      // create new one\n      recreateShadows();\n    }\n  });\n\n  let requireUpdateOnVirtual;\n  on('virtualUpdate', () => {\n    if (swiper.params.effect !== effect) return;\n    if (!swiper.slides.length) {\n      requireUpdateOnVirtual = true;\n    }\n    requestAnimationFrame(() => {\n      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n        setTranslate();\n        requireUpdateOnVirtual = false;\n      }\n    });\n  });\n}\n","export default function effectTarget(effectParams, $slideEl) {\n  if (effectParams.transformEl) {\n    return $slideEl.find(effectParams.transformEl).css({\n      'backface-visibility': 'hidden',\n      '-webkit-backface-visibility': 'hidden',\n    });\n  }\n  return $slideEl;\n}\n","export default function effectVirtualTransitionEnd({ swiper, duration, transformEl, allSlides }) {\n  const { slides, activeIndex, $wrapperEl } = swiper;\n  if (swiper.params.virtualTranslate && duration !== 0) {\n    let eventTriggered = false;\n    let $transitionEndTarget;\n    if (allSlides) {\n      $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;\n    } else {\n      $transitionEndTarget = transformEl\n        ? slides.eq(activeIndex).find(transformEl)\n        : slides.eq(activeIndex);\n    }\n    $transitionEndTarget.transitionEnd(() => {\n      if (eventTriggered) return;\n      if (!swiper || swiper.destroyed) return;\n      eventTriggered = true;\n      swiper.animating = false;\n      const triggerEvents = ['webkitTransitionEnd', 'transitionend'];\n      for (let i = 0; i < triggerEvents.length; i += 1) {\n        $wrapperEl.trigger(triggerEvents[i]);\n      }\n    });\n  }\n}\n","import $ from './dom.js';\n\nexport default function createShadow(params, $slideEl, side) {\n  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;\n  const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;\n  let $shadowEl = $shadowContainer.children(`.${shadowClass}`);\n\n  if (!$shadowEl.length) {\n    $shadowEl = $(`<div class=\"swiper-slide-shadow${side ? `-${side}` : ''}\"></div>`);\n    $shadowContainer.append($shadowEl);\n  }\n  return $shadowEl;\n}\n","import { getWindow } from 'ssr-window';\n\nexport default function Resize({ swiper, on, emit }) {\n  const window = getWindow();\n  let observer = null;\n  let animationFrame = null;\n\n  const resizeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    emit('beforeResize');\n    emit('resize');\n  };\n\n  const createObserver = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    observer = new ResizeObserver((entries) => {\n      animationFrame = window.requestAnimationFrame(() => {\n        const { width, height } = swiper;\n        let newWidth = width;\n        let newHeight = height;\n        entries.forEach(({ contentBoxSize, contentRect, target }) => {\n          if (target && target !== swiper.el) return;\n          newWidth = contentRect\n            ? contentRect.width\n            : (contentBoxSize[0] || contentBoxSize).inlineSize;\n          newHeight = contentRect\n            ? contentRect.height\n            : (contentBoxSize[0] || contentBoxSize).blockSize;\n        });\n        if (newWidth !== width || newHeight !== height) {\n          resizeHandler();\n        }\n      });\n    });\n    observer.observe(swiper.el);\n  };\n\n  const removeObserver = () => {\n    if (animationFrame) {\n      window.cancelAnimationFrame(animationFrame);\n    }\n    if (observer && observer.unobserve && swiper.el) {\n      observer.unobserve(swiper.el);\n      observer = null;\n    }\n  };\n\n  const orientationChangeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    emit('orientationchange');\n  };\n\n  on('init', () => {\n    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n      createObserver();\n      return;\n    }\n    window.addEventListener('resize', resizeHandler);\n    window.addEventListener('orientationchange', orientationChangeHandler);\n  });\n\n  on('destroy', () => {\n    removeObserver();\n    window.removeEventListener('resize', resizeHandler);\n    window.removeEventListener('orientationchange', orientationChangeHandler);\n  });\n}\n","import { getWindow } from 'ssr-window';\n\nexport default function Observer({ swiper, extendParams, on, emit }) {\n  const observers = [];\n  const window = getWindow();\n  const attach = (target, options = {}) => {\n    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n    const observer = new ObserverFunc((mutations) => {\n      // The observerUpdate event should only be triggered\n      // once despite the number of mutations.  Additional\n      // triggers are redundant and are very costly\n      if (mutations.length === 1) {\n        emit('observerUpdate', mutations[0]);\n        return;\n      }\n      const observerUpdate = function observerUpdate() {\n        emit('observerUpdate', mutations[0]);\n      };\n\n      if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(observerUpdate);\n      } else {\n        window.setTimeout(observerUpdate, 0);\n      }\n    });\n\n    observer.observe(target, {\n      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n      childList: typeof options.childList === 'undefined' ? true : options.childList,\n      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,\n    });\n\n    observers.push(observer);\n  };\n  const init = () => {\n    if (!swiper.params.observer) return;\n    if (swiper.params.observeParents) {\n      const containerParents = swiper.$el.parents();\n      for (let i = 0; i < containerParents.length; i += 1) {\n        attach(containerParents[i]);\n      }\n    }\n    // Observe container\n    attach(swiper.$el[0], {\n      childList: swiper.params.observeSlideChildren,\n    });\n\n    // Observe wrapper\n    attach(swiper.$wrapperEl[0], { attributes: false });\n  };\n  const destroy = () => {\n    observers.forEach((observer) => {\n      observer.disconnect();\n    });\n    observers.splice(0, observers.length);\n  };\n\n  extendParams({\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false,\n  });\n  on('init', init);\n  on('destroy', destroy);\n}\n","// Swiper Class\nimport Swiper from './core/core.js';\n\n//IMPORT_MODULES\n\nconst modules = [\n  //INSTALL_MODULES\n];\n\nSwiper.use(modules);\n\n//EXPORT\n","import $ from '../../shared/dom.js';\nimport { setCSSProperty } from '../../shared/utils.js';\n\nexport default function Virtual({ swiper, extendParams, on, emit }) {\n  extendParams({\n    virtual: {\n      enabled: false,\n      slides: [],\n      cache: true,\n      renderSlide: null,\n      renderExternal: null,\n      renderExternalUpdate: true,\n      addSlidesBefore: 0,\n      addSlidesAfter: 0,\n    },\n  });\n\n  let cssModeTimeout;\n\n  swiper.virtual = {\n    cache: {},\n    from: undefined,\n    to: undefined,\n    slides: [],\n    offset: 0,\n    slidesGrid: [],\n  };\n\n  function renderSlide(slide, index) {\n    const params = swiper.params.virtual;\n    if (params.cache && swiper.virtual.cache[index]) {\n      return swiper.virtual.cache[index];\n    }\n    const $slideEl = params.renderSlide\n      ? $(params.renderSlide.call(swiper, slide, index))\n      : $(\n          `<div class=\"${swiper.params.slideClass}\" data-swiper-slide-index=\"${index}\">${slide}</div>`,\n        );\n    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);\n    if (params.cache) swiper.virtual.cache[index] = $slideEl;\n    return $slideEl;\n  }\n\n  function update(force) {\n    const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;\n    const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;\n    const {\n      from: previousFrom,\n      to: previousTo,\n      slides,\n      slidesGrid: previousSlidesGrid,\n      offset: previousOffset,\n    } = swiper.virtual;\n    if (!swiper.params.cssMode) {\n      swiper.updateActiveIndex();\n    }\n\n    const activeIndex = swiper.activeIndex || 0;\n\n    let offsetProp;\n    if (swiper.rtlTranslate) offsetProp = 'right';\n    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n\n    let slidesAfter;\n    let slidesBefore;\n    if (centeredSlides) {\n      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n    } else {\n      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n      slidesBefore = slidesPerGroup + addSlidesBefore;\n    }\n    const from = Math.max((activeIndex || 0) - slidesBefore, 0);\n    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);\n    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n\n    Object.assign(swiper.virtual, {\n      from,\n      to,\n      offset,\n      slidesGrid: swiper.slidesGrid,\n    });\n\n    function onRendered() {\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n      if (swiper.lazy && swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n      emit('virtualUpdate');\n    }\n\n    if (previousFrom === from && previousTo === to && !force) {\n      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n        swiper.slides.css(offsetProp, `${offset}px`);\n      }\n      swiper.updateProgress();\n      emit('virtualUpdate');\n      return;\n    }\n    if (swiper.params.virtual.renderExternal) {\n      swiper.params.virtual.renderExternal.call(swiper, {\n        offset,\n        from,\n        to,\n        slides: (function getSlides() {\n          const slidesToRender = [];\n          for (let i = from; i <= to; i += 1) {\n            slidesToRender.push(slides[i]);\n          }\n          return slidesToRender;\n        })(),\n      });\n      if (swiper.params.virtual.renderExternalUpdate) {\n        onRendered();\n      } else {\n        emit('virtualUpdate');\n      }\n      return;\n    }\n    const prependIndexes = [];\n    const appendIndexes = [];\n    if (force) {\n      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();\n    } else {\n      for (let i = previousFrom; i <= previousTo; i += 1) {\n        if (i < from || i > to) {\n          swiper.$wrapperEl\n            .find(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${i}\"]`)\n            .remove();\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      if (i >= from && i <= to) {\n        if (typeof previousTo === 'undefined' || force) {\n          appendIndexes.push(i);\n        } else {\n          if (i > previousTo) appendIndexes.push(i);\n          if (i < previousFrom) prependIndexes.push(i);\n        }\n      }\n    }\n    appendIndexes.forEach((index) => {\n      swiper.$wrapperEl.append(renderSlide(slides[index], index));\n    });\n    prependIndexes\n      .sort((a, b) => b - a)\n      .forEach((index) => {\n        swiper.$wrapperEl.prepend(renderSlide(slides[index], index));\n      });\n    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);\n    onRendered();\n  }\n\n  function appendSlide(slides) {\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.push(slides[i]);\n      }\n    } else {\n      swiper.virtual.slides.push(slides);\n    }\n    update(true);\n  }\n  function prependSlide(slides) {\n    const activeIndex = swiper.activeIndex;\n    let newActiveIndex = activeIndex + 1;\n    let numberOfNewSlides = 1;\n\n    if (Array.isArray(slides)) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n      }\n      newActiveIndex = activeIndex + slides.length;\n      numberOfNewSlides = slides.length;\n    } else {\n      swiper.virtual.slides.unshift(slides);\n    }\n    if (swiper.params.virtual.cache) {\n      const cache = swiper.virtual.cache;\n      const newCache = {};\n      Object.keys(cache).forEach((cachedIndex) => {\n        const $cachedEl = cache[cachedIndex];\n        const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');\n        if (cachedElIndex) {\n          $cachedEl.attr(\n            'data-swiper-slide-index',\n            parseInt(cachedElIndex, 10) + numberOfNewSlides,\n          );\n        }\n        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;\n      });\n      swiper.virtual.cache = newCache;\n    }\n    update(true);\n    swiper.slideTo(newActiveIndex, 0);\n  }\n  function removeSlide(slidesIndexes) {\n    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n    let activeIndex = swiper.activeIndex;\n    if (Array.isArray(slidesIndexes)) {\n      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n        swiper.virtual.slides.splice(slidesIndexes[i], 1);\n        if (swiper.params.virtual.cache) {\n          delete swiper.virtual.cache[slidesIndexes[i]];\n        }\n        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n        activeIndex = Math.max(activeIndex, 0);\n      }\n    } else {\n      swiper.virtual.slides.splice(slidesIndexes, 1);\n      if (swiper.params.virtual.cache) {\n        delete swiper.virtual.cache[slidesIndexes];\n      }\n      if (slidesIndexes < activeIndex) activeIndex -= 1;\n      activeIndex = Math.max(activeIndex, 0);\n    }\n    update(true);\n    swiper.slideTo(activeIndex, 0);\n  }\n  function removeAllSlides() {\n    swiper.virtual.slides = [];\n    if (swiper.params.virtual.cache) {\n      swiper.virtual.cache = {};\n    }\n    update(true);\n    swiper.slideTo(0, 0);\n  }\n\n  on('beforeInit', () => {\n    if (!swiper.params.virtual.enabled) return;\n    swiper.virtual.slides = swiper.params.virtual.slides;\n    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n\n    swiper.params.watchSlidesProgress = true;\n    swiper.originalParams.watchSlidesProgress = true;\n\n    if (!swiper.params.initialSlide) {\n      update();\n    }\n  });\n  on('setTranslate', () => {\n    if (!swiper.params.virtual.enabled) return;\n    if (swiper.params.cssMode && !swiper._immediateVirtual) {\n      clearTimeout(cssModeTimeout);\n      cssModeTimeout = setTimeout(() => {\n        update();\n      }, 100);\n    } else {\n      update();\n    }\n  });\n  on('init update resize', () => {\n    if (!swiper.params.virtual.enabled) return;\n    if (swiper.params.cssMode) {\n      setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n    }\n  });\n\n  Object.assign(swiper.virtual, {\n    appendSlide,\n    prependSlide,\n    removeSlide,\n    removeAllSlides,\n    update,\n  });\n}\n","/* eslint-disable consistent-return */\nimport { getWindow, getDocument } from 'ssr-window';\nimport $ from '../../shared/dom.js';\n\nexport default function Keyboard({ swiper, extendParams, on, emit }) {\n  const document = getDocument();\n  const window = getWindow();\n  swiper.keyboard = {\n    enabled: false,\n  };\n  extendParams({\n    keyboard: {\n      enabled: false,\n      onlyInViewport: true,\n      pageUpDown: true,\n    },\n  });\n\n  function handle(event) {\n    if (!swiper.enabled) return;\n\n    const { rtlTranslate: rtl } = swiper;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    const kc = e.keyCode || e.charCode;\n    const pageUpDown = swiper.params.keyboard.pageUpDown;\n    const isPageUp = pageUpDown && kc === 33;\n    const isPageDown = pageUpDown && kc === 34;\n    const isArrowLeft = kc === 37;\n    const isArrowRight = kc === 39;\n    const isArrowUp = kc === 38;\n    const isArrowDown = kc === 40;\n    // Directions locks\n    if (\n      !swiper.allowSlideNext &&\n      ((swiper.isHorizontal() && isArrowRight) ||\n        (swiper.isVertical() && isArrowDown) ||\n        isPageDown)\n    ) {\n      return false;\n    }\n    if (\n      !swiper.allowSlidePrev &&\n      ((swiper.isHorizontal() && isArrowLeft) || (swiper.isVertical() && isArrowUp) || isPageUp)\n    ) {\n      return false;\n    }\n    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n      return undefined;\n    }\n    if (\n      document.activeElement &&\n      document.activeElement.nodeName &&\n      (document.activeElement.nodeName.toLowerCase() === 'input' ||\n        document.activeElement.nodeName.toLowerCase() === 'textarea')\n    ) {\n      return undefined;\n    }\n    if (\n      swiper.params.keyboard.onlyInViewport &&\n      (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)\n    ) {\n      let inView = false;\n      // Check that swiper should be inside of visible area of window\n      if (\n        swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 &&\n        swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0\n      ) {\n        return undefined;\n      }\n\n      const $el = swiper.$el;\n      const swiperWidth = $el[0].clientWidth;\n      const swiperHeight = $el[0].clientHeight;\n      const windowWidth = window.innerWidth;\n      const windowHeight = window.innerHeight;\n      const swiperOffset = swiper.$el.offset();\n      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;\n      const swiperCoord = [\n        [swiperOffset.left, swiperOffset.top],\n        [swiperOffset.left + swiperWidth, swiperOffset.top],\n        [swiperOffset.left, swiperOffset.top + swiperHeight],\n        [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight],\n      ];\n      for (let i = 0; i < swiperCoord.length; i += 1) {\n        const point = swiperCoord[i];\n        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n          inView = true;\n        }\n      }\n      if (!inView) return undefined;\n    }\n    if (swiper.isHorizontal()) {\n      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n      }\n      if (((isPageDown || isArrowRight) && !rtl) || ((isPageUp || isArrowLeft) && rtl))\n        swiper.slideNext();\n      if (((isPageUp || isArrowLeft) && !rtl) || ((isPageDown || isArrowRight) && rtl))\n        swiper.slidePrev();\n    } else {\n      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n      }\n      if (isPageDown || isArrowDown) swiper.slideNext();\n      if (isPageUp || isArrowUp) swiper.slidePrev();\n    }\n    emit('keyPress', kc);\n    return undefined;\n  }\n  function enable() {\n    if (swiper.keyboard.enabled) return;\n    $(document).on('keydown', handle);\n    swiper.keyboard.enabled = true;\n  }\n  function disable() {\n    if (!swiper.keyboard.enabled) return;\n    $(document).off('keydown', handle);\n    swiper.keyboard.enabled = false;\n  }\n\n  on('init', () => {\n    if (swiper.params.keyboard.enabled) {\n      enable();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.keyboard.enabled) {\n      disable();\n    }\n  });\n\n  Object.assign(swiper.keyboard, {\n    enable,\n    disable,\n  });\n}\n","/* eslint-disable consistent-return */\nimport { getWindow } from 'ssr-window';\nimport $ from '../../shared/dom.js';\nimport { now, nextTick } from '../../shared/utils.js';\n\nexport default function Mousewheel({ swiper, extendParams, on, emit }) {\n  const window = getWindow();\n\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null,\n    },\n  });\n\n  swiper.mousewheel = {\n    enabled: false,\n  };\n\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY,\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (\n      swiper.params.mousewheel.thresholdDelta &&\n      newEvent.delta < swiper.params.mousewheel.thresholdDelta\n    ) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n\n    if (\n      swiper.params.mousewheel.thresholdTime &&\n      now() - lastScrollTime < swiper.params.mousewheel.thresholdTime\n    ) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    }\n\n    // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    }\n    // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    }\n    // If you got here is because an animation has been triggered so store the current time\n    lastScrollTime = new window.Date().getTime();\n    // Return false as a default\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  }\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return;\n    const params = swiper.params.mousewheel;\n\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n\n    let target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges)\n      return true;\n\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n\n    const data = normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;\n        else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;\n      else return true;\n    } else {\n      delta =\n        Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n\n    if (params.invert) delta = -delta;\n\n    // Get the scroll positions\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n    // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n    disableParentSwiper = swiper.params.loop\n      ? true\n      : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event,\n      };\n\n      // Keep the most recent events\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n      const prevEvent = recentWheelEvents.length\n        ? recentWheelEvents[recentWheelEvents.length - 1]\n        : undefined;\n      recentWheelEvents.push(newEvent);\n\n      // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n      if (prevEvent) {\n        if (\n          newEvent.direction !== prevEvent.direction ||\n          newEvent.delta > prevEvent.delta ||\n          newEvent.time > prevEvent.time + 150\n        ) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n\n      // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n      };\n      const ignoreWheelEvents =\n        lastEventBeforeSnap &&\n        newEvent.time < lastEventBeforeSnap.time + 500 &&\n        newEvent.delta <= lastEventBeforeSnap.delta &&\n        newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n\n        if (swiper.params.loop) {\n          swiper.loopFix();\n        }\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n\n        if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {\n          swiper.updateSlidesClasses();\n        }\n\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n          const prevEvent = recentWheelEvents.length\n            ? recentWheelEvents[recentWheelEvents.length - 1]\n            : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (\n            prevEvent &&\n            (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)\n          ) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (\n            recentWheelEvents.length >= 15 &&\n            newEvent.time - firstEvent.time < 500 &&\n            firstEvent.delta - newEvent.delta >= 1 &&\n            newEvent.delta <= 6\n          ) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        }\n\n        // Emit event\n        if (!ignoreWheelEvents) emit('scroll', e);\n\n        // Stop autoplay\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction)\n          swiper.autoplay.stop();\n        // Return page scroll on edge positions\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n    return false;\n  }\n\n  function events(method) {\n    let target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n    target[method]('mouseenter', handleMouseEnter);\n    target[method]('mouseleave', handleMouseLeave);\n    target[method]('wheel', handle);\n  }\n\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled) return false;\n    events('on');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled) return false;\n    events('off');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled) disable();\n  });\n\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable,\n  });\n}\n","import createElementIfNotDefined from '../../shared/create-element-if-not-defined.js';\nimport $ from '../../shared/dom.js';\n\nexport default function Navigation({ swiper, extendParams, on, emit }) {\n  extendParams({\n    navigation: {\n      nextEl: null,\n      prevEl: null,\n\n      hideOnClick: false,\n      disabledClass: 'swiper-button-disabled',\n      hiddenClass: 'swiper-button-hidden',\n      lockClass: 'swiper-button-lock',\n      navigationDisabledClass: 'swiper-navigation-disabled',\n    },\n  });\n\n  swiper.navigation = {\n    nextEl: null,\n    $nextEl: null,\n    prevEl: null,\n    $prevEl: null,\n  };\n\n  function getEl(el) {\n    let $el;\n    if (el) {\n      $el = $(el);\n      if (\n        swiper.params.uniqueNavElements &&\n        typeof el === 'string' &&\n        $el.length > 1 &&\n        swiper.$el.find(el).length === 1\n      ) {\n        $el = swiper.$el.find(el);\n      }\n    }\n    return $el;\n  }\n\n  function toggleEl($el, disabled) {\n    const params = swiper.params.navigation;\n    if ($el && $el.length > 0) {\n      $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);\n      if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n      }\n    }\n  }\n  function update() {\n    // Update Navigation Buttons\n    if (swiper.params.loop) return;\n    const { $nextEl, $prevEl } = swiper.navigation;\n\n    toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);\n    toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);\n  }\n  function onPrevClick(e) {\n    e.preventDefault();\n    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n    swiper.slidePrev();\n    emit('navigationPrev');\n  }\n  function onNextClick(e) {\n    e.preventDefault();\n    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n    swiper.slideNext();\n    emit('navigationNext');\n  }\n  function init() {\n    const params = swiper.params.navigation;\n\n    swiper.params.navigation = createElementIfNotDefined(\n      swiper,\n      swiper.originalParams.navigation,\n      swiper.params.navigation,\n      {\n        nextEl: 'swiper-button-next',\n        prevEl: 'swiper-button-prev',\n      },\n    );\n    if (!(params.nextEl || params.prevEl)) return;\n\n    const $nextEl = getEl(params.nextEl);\n    const $prevEl = getEl(params.prevEl);\n\n    if ($nextEl && $nextEl.length > 0) {\n      $nextEl.on('click', onNextClick);\n    }\n    if ($prevEl && $prevEl.length > 0) {\n      $prevEl.on('click', onPrevClick);\n    }\n\n    Object.assign(swiper.navigation, {\n      $nextEl,\n      nextEl: $nextEl && $nextEl[0],\n      $prevEl,\n      prevEl: $prevEl && $prevEl[0],\n    });\n\n    if (!swiper.enabled) {\n      if ($nextEl) $nextEl.addClass(params.lockClass);\n      if ($prevEl) $prevEl.addClass(params.lockClass);\n    }\n  }\n  function destroy() {\n    const { $nextEl, $prevEl } = swiper.navigation;\n    if ($nextEl && $nextEl.length) {\n      $nextEl.off('click', onNextClick);\n      $nextEl.removeClass(swiper.params.navigation.disabledClass);\n    }\n    if ($prevEl && $prevEl.length) {\n      $prevEl.off('click', onPrevClick);\n      $prevEl.removeClass(swiper.params.navigation.disabledClass);\n    }\n  }\n\n  on('init', () => {\n    if (swiper.params.navigation.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      update();\n    }\n  });\n  on('toEdge fromEdge lock unlock', () => {\n    update();\n  });\n  on('destroy', () => {\n    destroy();\n  });\n  on('enable disable', () => {\n    const { $nextEl, $prevEl } = swiper.navigation;\n    if ($nextEl) {\n      $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);\n    }\n    if ($prevEl) {\n      $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);\n    }\n  });\n  on('click', (_s, e) => {\n    const { $nextEl, $prevEl } = swiper.navigation;\n    const targetEl = e.target;\n    if (\n      swiper.params.navigation.hideOnClick &&\n      !$(targetEl).is($prevEl) &&\n      !$(targetEl).is($nextEl)\n    ) {\n      if (\n        swiper.pagination &&\n        swiper.params.pagination &&\n        swiper.params.pagination.clickable &&\n        (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))\n      )\n        return;\n      let isHidden;\n      if ($nextEl) {\n        isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);\n      } else if ($prevEl) {\n        isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);\n      }\n      if (isHidden === true) {\n        emit('navigationShow');\n      } else {\n        emit('navigationHide');\n      }\n      if ($nextEl) {\n        $nextEl.toggleClass(swiper.params.navigation.hiddenClass);\n      }\n      if ($prevEl) {\n        $prevEl.toggleClass(swiper.params.navigation.hiddenClass);\n      }\n    }\n  });\n\n  const enable = () => {\n    swiper.$el.removeClass(swiper.params.navigation.navigationDisabledClass);\n    init();\n    update();\n  };\n\n  const disable = () => {\n    swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass);\n    destroy();\n  };\n\n  Object.assign(swiper.navigation, {\n    enable,\n    disable,\n    update,\n    init,\n    destroy,\n  });\n}\n","import $ from '../../shared/dom.js';\nimport classesToSelector from '../../shared/classes-to-selector.js';\nimport createElementIfNotDefined from '../../shared/create-element-if-not-defined.js';\n\nexport default function Pagination({ swiper, extendParams, on, emit }) {\n  const pfx = 'swiper-pagination';\n  extendParams({\n    pagination: {\n      el: null,\n      bulletElement: 'span',\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: (number) => number,\n      formatFractionTotal: (number) => number,\n      bulletClass: `${pfx}-bullet`,\n      bulletActiveClass: `${pfx}-bullet-active`,\n      modifierClass: `${pfx}-`,\n      currentClass: `${pfx}-current`,\n      totalClass: `${pfx}-total`,\n      hiddenClass: `${pfx}-hidden`,\n      progressbarFillClass: `${pfx}-progressbar-fill`,\n      progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n      clickableClass: `${pfx}-clickable`,\n      lockClass: `${pfx}-lock`,\n      horizontalClass: `${pfx}-horizontal`,\n      verticalClass: `${pfx}-vertical`,\n      paginationDisabledClass: `${pfx}-disabled`,\n    },\n  });\n\n  swiper.pagination = {\n    el: null,\n    $el: null,\n    bullets: [],\n  };\n\n  let bulletSize;\n  let dynamicBulletIndex = 0;\n\n  function isPaginationDisabled() {\n    return (\n      !swiper.params.pagination.el ||\n      !swiper.pagination.el ||\n      !swiper.pagination.$el ||\n      swiper.pagination.$el.length === 0\n    );\n  }\n\n  function setSideBullets($bulletEl, position) {\n    const { bulletActiveClass } = swiper.params.pagination;\n    $bulletEl[position]()\n      .addClass(`${bulletActiveClass}-${position}`)\n      [position]()\n      .addClass(`${bulletActiveClass}-${position}-${position}`);\n  }\n\n  function update() {\n    // Render || Update Pagination bullets/items\n    const rtl = swiper.rtl;\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    const slidesLength =\n      swiper.virtual && swiper.params.virtual.enabled\n        ? swiper.virtual.slides.length\n        : swiper.slides.length;\n    const $el = swiper.pagination.$el;\n    // Current/Total\n    let current;\n    const total = swiper.params.loop\n      ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup)\n      : swiper.snapGrid.length;\n    if (swiper.params.loop) {\n      current = Math.ceil(\n        (swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup,\n      );\n      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {\n        current -= slidesLength - swiper.loopedSlides * 2;\n      }\n      if (current > total - 1) current -= total;\n      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;\n    } else if (typeof swiper.snapIndex !== 'undefined') {\n      current = swiper.snapIndex;\n    } else {\n      current = swiper.activeIndex || 0;\n    }\n    // Types\n    if (\n      params.type === 'bullets' &&\n      swiper.pagination.bullets &&\n      swiper.pagination.bullets.length > 0\n    ) {\n      const bullets = swiper.pagination.bullets;\n      let firstIndex;\n      let lastIndex;\n      let midIndex;\n      if (params.dynamicBullets) {\n        bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);\n        $el.css(\n          swiper.isHorizontal() ? 'width' : 'height',\n          `${bulletSize * (params.dynamicMainBullets + 4)}px`,\n        );\n        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {\n          dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);\n          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n            dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (dynamicBulletIndex < 0) {\n            dynamicBulletIndex = 0;\n          }\n        }\n        firstIndex = Math.max(current - dynamicBulletIndex, 0);\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n      bullets.removeClass(\n        ['', '-next', '-next-next', '-prev', '-prev-prev', '-main']\n          .map((suffix) => `${params.bulletActiveClass}${suffix}`)\n          .join(' '),\n      );\n      if ($el.length > 1) {\n        bullets.each((bullet) => {\n          const $bullet = $(bullet);\n          const bulletIndex = $bullet.index();\n          if (bulletIndex === current) {\n            $bullet.addClass(params.bulletActiveClass);\n          }\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              $bullet.addClass(`${params.bulletActiveClass}-main`);\n            }\n            if (bulletIndex === firstIndex) {\n              setSideBullets($bullet, 'prev');\n            }\n            if (bulletIndex === lastIndex) {\n              setSideBullets($bullet, 'next');\n            }\n          }\n        });\n      } else {\n        const $bullet = bullets.eq(current);\n        const bulletIndex = $bullet.index();\n        $bullet.addClass(params.bulletActiveClass);\n        if (params.dynamicBullets) {\n          const $firstDisplayedBullet = bullets.eq(firstIndex);\n          const $lastDisplayedBullet = bullets.eq(lastIndex);\n          for (let i = firstIndex; i <= lastIndex; i += 1) {\n            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);\n          }\n          if (swiper.params.loop) {\n            if (bulletIndex >= bullets.length) {\n              for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {\n                bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);\n              }\n              bullets\n                .eq(bullets.length - params.dynamicMainBullets - 1)\n                .addClass(`${params.bulletActiveClass}-prev`);\n            } else {\n              setSideBullets($firstDisplayedBullet, 'prev');\n              setSideBullets($lastDisplayedBullet, 'next');\n            }\n          } else {\n            setSideBullets($firstDisplayedBullet, 'prev');\n            setSideBullets($lastDisplayedBullet, 'next');\n          }\n        }\n      }\n      if (params.dynamicBullets) {\n        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        const bulletsOffset =\n          (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n        const offsetProp = rtl ? 'right' : 'left';\n        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);\n      }\n    }\n    if (params.type === 'fraction') {\n      $el\n        .find(classesToSelector(params.currentClass))\n        .text(params.formatFractionCurrent(current + 1));\n      $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));\n    }\n    if (params.type === 'progressbar') {\n      let progressbarDirection;\n      if (params.progressbarOpposite) {\n        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n      } else {\n        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n      }\n      const scale = (current + 1) / total;\n      let scaleX = 1;\n      let scaleY = 1;\n      if (progressbarDirection === 'horizontal') {\n        scaleX = scale;\n      } else {\n        scaleY = scale;\n      }\n      $el\n        .find(classesToSelector(params.progressbarFillClass))\n        .transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`)\n        .transition(swiper.params.speed);\n    }\n    if (params.type === 'custom' && params.renderCustom) {\n      $el.html(params.renderCustom(swiper, current + 1, total));\n      emit('paginationRender', $el[0]);\n    } else {\n      emit('paginationUpdate', $el[0]);\n    }\n    if (swiper.params.watchOverflow && swiper.enabled) {\n      $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n    }\n  }\n  function render() {\n    // Render Container\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    const slidesLength =\n      swiper.virtual && swiper.params.virtual.enabled\n        ? swiper.virtual.slides.length\n        : swiper.slides.length;\n\n    const $el = swiper.pagination.$el;\n    let paginationHTML = '';\n    if (params.type === 'bullets') {\n      let numberOfBullets = swiper.params.loop\n        ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup)\n        : swiper.snapGrid.length;\n      if (\n        swiper.params.freeMode &&\n        swiper.params.freeMode.enabled &&\n        !swiper.params.loop &&\n        numberOfBullets > slidesLength\n      ) {\n        numberOfBullets = slidesLength;\n      }\n      for (let i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          paginationHTML += `<${params.bulletElement} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n        }\n      }\n      $el.html(paginationHTML);\n\n      swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));\n    }\n    if (params.type === 'fraction') {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML =\n          `<span class=\"${params.currentClass}\"></span>` +\n          ' / ' +\n          `<span class=\"${params.totalClass}\"></span>`;\n      }\n      $el.html(paginationHTML);\n    }\n    if (params.type === 'progressbar') {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n      }\n      $el.html(paginationHTML);\n    }\n    if (params.type !== 'custom') {\n      emit('paginationRender', swiper.pagination.$el[0]);\n    }\n  }\n  function init() {\n    swiper.params.pagination = createElementIfNotDefined(\n      swiper,\n      swiper.originalParams.pagination,\n      swiper.params.pagination,\n      { el: 'swiper-pagination' },\n    );\n    const params = swiper.params.pagination;\n    if (!params.el) return;\n\n    let $el = $(params.el);\n    if ($el.length === 0) return;\n\n    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {\n      $el = swiper.$el.find(params.el);\n      // check if it belongs to another nested Swiper\n      if ($el.length > 1) {\n        $el = $el.filter((el) => {\n          if ($(el).parents('.swiper')[0] !== swiper.el) return false;\n          return true;\n        });\n      }\n    }\n\n    if (params.type === 'bullets' && params.clickable) {\n      $el.addClass(params.clickableClass);\n    }\n\n    $el.addClass(params.modifierClass + params.type);\n    $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\n    if (params.type === 'bullets' && params.dynamicBullets) {\n      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);\n      dynamicBulletIndex = 0;\n      if (params.dynamicMainBullets < 1) {\n        params.dynamicMainBullets = 1;\n      }\n    }\n    if (params.type === 'progressbar' && params.progressbarOpposite) {\n      $el.addClass(params.progressbarOppositeClass);\n    }\n\n    if (params.clickable) {\n      $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {\n        e.preventDefault();\n        let index = $(this).index() * swiper.params.slidesPerGroup;\n        if (swiper.params.loop) index += swiper.loopedSlides;\n        swiper.slideTo(index);\n      });\n    }\n\n    Object.assign(swiper.pagination, {\n      $el,\n      el: $el[0],\n    });\n\n    if (!swiper.enabled) {\n      $el.addClass(params.lockClass);\n    }\n  }\n  function destroy() {\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    const $el = swiper.pagination.$el;\n\n    $el.removeClass(params.hiddenClass);\n    $el.removeClass(params.modifierClass + params.type);\n    $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass)\n      swiper.pagination.bullets.removeClass(params.bulletActiveClass);\n    if (params.clickable) {\n      $el.off('click', classesToSelector(params.bulletClass));\n    }\n  }\n\n  on('init', () => {\n    if (swiper.params.pagination.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      render();\n      update();\n    }\n  });\n  on('activeIndexChange', () => {\n    if (swiper.params.loop) {\n      update();\n    } else if (typeof swiper.snapIndex === 'undefined') {\n      update();\n    }\n  });\n  on('snapIndexChange', () => {\n    if (!swiper.params.loop) {\n      update();\n    }\n  });\n  on('slidesLengthChange', () => {\n    if (swiper.params.loop) {\n      render();\n      update();\n    }\n  });\n  on('snapGridLengthChange', () => {\n    if (!swiper.params.loop) {\n      render();\n      update();\n    }\n  });\n  on('destroy', () => {\n    destroy();\n  });\n  on('enable disable', () => {\n    const { $el } = swiper.pagination;\n    if ($el) {\n      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);\n    }\n  });\n  on('lock unlock', () => {\n    update();\n  });\n  on('click', (_s, e) => {\n    const targetEl = e.target;\n    const { $el } = swiper.pagination;\n    if (\n      swiper.params.pagination.el &&\n      swiper.params.pagination.hideOnClick &&\n      $el &&\n      $el.length > 0 &&\n      !$(targetEl).hasClass(swiper.params.pagination.bulletClass)\n    ) {\n      if (\n        swiper.navigation &&\n        ((swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) ||\n          (swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))\n      )\n        return;\n      const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);\n      if (isHidden === true) {\n        emit('paginationShow');\n      } else {\n        emit('paginationHide');\n      }\n      $el.toggleClass(swiper.params.pagination.hiddenClass);\n    }\n  });\n\n  const enable = () => {\n    swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass);\n    if (swiper.pagination.$el) {\n      swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass);\n    }\n    init();\n    render();\n    update();\n  };\n\n  const disable = () => {\n    swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass);\n    if (swiper.pagination.$el) {\n      swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass);\n    }\n    destroy();\n  };\n\n  Object.assign(swiper.pagination, {\n    enable,\n    disable,\n    render,\n    update,\n    init,\n    destroy,\n  });\n}\n","import { getDocument } from 'ssr-window';\nimport $ from '../../shared/dom.js';\nimport { nextTick } from '../../shared/utils.js';\nimport createElementIfNotDefined from '../../shared/create-element-if-not-defined.js';\n\nexport default function Scrollbar({ swiper, extendParams, on, emit }) {\n  const document = getDocument();\n\n  let isTouched = false;\n  let timeout = null;\n  let dragTimeout = null;\n  let dragStartPos;\n  let dragSize;\n  let trackSize;\n  let divider;\n\n  extendParams({\n    scrollbar: {\n      el: null,\n      dragSize: 'auto',\n      hide: false,\n      draggable: false,\n      snapOnRelease: true,\n      lockClass: 'swiper-scrollbar-lock',\n      dragClass: 'swiper-scrollbar-drag',\n      scrollbarDisabledClass: 'swiper-scrollbar-disabled',\n      horizontalClass: `swiper-scrollbar-horizontal`,\n      verticalClass: `swiper-scrollbar-vertical`,\n    },\n  });\n\n  swiper.scrollbar = {\n    el: null,\n    dragEl: null,\n    $el: null,\n    $dragEl: null,\n  };\n\n  function setTranslate() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    const { scrollbar, rtlTranslate: rtl, progress } = swiper;\n    const { $dragEl, $el } = scrollbar;\n    const params = swiper.params.scrollbar;\n\n    let newSize = dragSize;\n    let newPos = (trackSize - dragSize) * progress;\n    if (rtl) {\n      newPos = -newPos;\n      if (newPos > 0) {\n        newSize = dragSize - newPos;\n        newPos = 0;\n      } else if (-newPos + dragSize > trackSize) {\n        newSize = trackSize + newPos;\n      }\n    } else if (newPos < 0) {\n      newSize = dragSize + newPos;\n      newPos = 0;\n    } else if (newPos + dragSize > trackSize) {\n      newSize = trackSize - newPos;\n    }\n    if (swiper.isHorizontal()) {\n      $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);\n      $dragEl[0].style.width = `${newSize}px`;\n    } else {\n      $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);\n      $dragEl[0].style.height = `${newSize}px`;\n    }\n    if (params.hide) {\n      clearTimeout(timeout);\n      $el[0].style.opacity = 1;\n      timeout = setTimeout(() => {\n        $el[0].style.opacity = 0;\n        $el.transition(400);\n      }, 1000);\n    }\n  }\n  function setTransition(duration) {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    swiper.scrollbar.$dragEl.transition(duration);\n  }\n  function updateSize() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\n    const { scrollbar } = swiper;\n    const { $dragEl, $el } = scrollbar;\n\n    $dragEl[0].style.width = '';\n    $dragEl[0].style.height = '';\n    trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;\n\n    divider =\n      swiper.size /\n      (swiper.virtualSize +\n        swiper.params.slidesOffsetBefore -\n        (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n    if (swiper.params.scrollbar.dragSize === 'auto') {\n      dragSize = trackSize * divider;\n    } else {\n      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n    }\n\n    if (swiper.isHorizontal()) {\n      $dragEl[0].style.width = `${dragSize}px`;\n    } else {\n      $dragEl[0].style.height = `${dragSize}px`;\n    }\n\n    if (divider >= 1) {\n      $el[0].style.display = 'none';\n    } else {\n      $el[0].style.display = '';\n    }\n    if (swiper.params.scrollbar.hide) {\n      $el[0].style.opacity = 0;\n    }\n\n    if (swiper.params.watchOverflow && swiper.enabled) {\n      scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](\n        swiper.params.scrollbar.lockClass,\n      );\n    }\n  }\n  function getPointerPosition(e) {\n    if (swiper.isHorizontal()) {\n      return e.type === 'touchstart' || e.type === 'touchmove'\n        ? e.targetTouches[0].clientX\n        : e.clientX;\n    }\n    return e.type === 'touchstart' || e.type === 'touchmove'\n      ? e.targetTouches[0].clientY\n      : e.clientY;\n  }\n  function setDragPosition(e) {\n    const { scrollbar, rtlTranslate: rtl } = swiper;\n    const { $el } = scrollbar;\n\n    let positionRatio;\n    positionRatio =\n      (getPointerPosition(e) -\n        $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] -\n        (dragStartPos !== null ? dragStartPos : dragSize / 2)) /\n      (trackSize - dragSize);\n    positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n    if (rtl) {\n      positionRatio = 1 - positionRatio;\n    }\n\n    const position =\n      swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n\n    swiper.updateProgress(position);\n    swiper.setTranslate(position);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  function onDragStart(e) {\n    const params = swiper.params.scrollbar;\n    const { scrollbar, $wrapperEl } = swiper;\n    const { $el, $dragEl } = scrollbar;\n    isTouched = true;\n    dragStartPos =\n      e.target === $dragEl[0] || e.target === $dragEl\n        ? getPointerPosition(e) -\n          e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top']\n        : null;\n    e.preventDefault();\n    e.stopPropagation();\n\n    $wrapperEl.transition(100);\n    $dragEl.transition(100);\n    setDragPosition(e);\n\n    clearTimeout(dragTimeout);\n\n    $el.transition(0);\n    if (params.hide) {\n      $el.css('opacity', 1);\n    }\n    if (swiper.params.cssMode) {\n      swiper.$wrapperEl.css('scroll-snap-type', 'none');\n    }\n    emit('scrollbarDragStart', e);\n  }\n  function onDragMove(e) {\n    const { scrollbar, $wrapperEl } = swiper;\n    const { $el, $dragEl } = scrollbar;\n\n    if (!isTouched) return;\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n    setDragPosition(e);\n    $wrapperEl.transition(0);\n    $el.transition(0);\n    $dragEl.transition(0);\n    emit('scrollbarDragMove', e);\n  }\n  function onDragEnd(e) {\n    const params = swiper.params.scrollbar;\n    const { scrollbar, $wrapperEl } = swiper;\n    const { $el } = scrollbar;\n\n    if (!isTouched) return;\n    isTouched = false;\n    if (swiper.params.cssMode) {\n      swiper.$wrapperEl.css('scroll-snap-type', '');\n      $wrapperEl.transition('');\n    }\n    if (params.hide) {\n      clearTimeout(dragTimeout);\n      dragTimeout = nextTick(() => {\n        $el.css('opacity', 0);\n        $el.transition(400);\n      }, 1000);\n    }\n    emit('scrollbarDragEnd', e);\n    if (params.snapOnRelease) {\n      swiper.slideToClosest();\n    }\n  }\n\n  function events(method) {\n    const { scrollbar, touchEventsTouch, touchEventsDesktop, params, support } = swiper;\n    const $el = scrollbar.$el;\n    if (!$el) return;\n    const target = $el[0];\n    const activeListener =\n      support.passiveListener && params.passiveListeners\n        ? { passive: false, capture: false }\n        : false;\n    const passiveListener =\n      support.passiveListener && params.passiveListeners\n        ? { passive: true, capture: false }\n        : false;\n    if (!target) return;\n    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n    if (!support.touch) {\n      target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);\n      document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);\n      document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);\n    } else {\n      target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);\n      target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);\n      target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);\n    }\n  }\n\n  function enableDraggable() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    events('on');\n  }\n  function disableDraggable() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    events('off');\n  }\n  function init() {\n    const { scrollbar, $el: $swiperEl } = swiper;\n    swiper.params.scrollbar = createElementIfNotDefined(\n      swiper,\n      swiper.originalParams.scrollbar,\n      swiper.params.scrollbar,\n      { el: 'swiper-scrollbar' },\n    );\n    const params = swiper.params.scrollbar;\n    if (!params.el) return;\n\n    let $el = $(params.el);\n    if (\n      swiper.params.uniqueNavElements &&\n      typeof params.el === 'string' &&\n      $el.length > 1 &&\n      $swiperEl.find(params.el).length === 1\n    ) {\n      $el = $swiperEl.find(params.el);\n    }\n\n    $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\n    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);\n    if ($dragEl.length === 0) {\n      $dragEl = $(`<div class=\"${swiper.params.scrollbar.dragClass}\"></div>`);\n      $el.append($dragEl);\n    }\n\n    Object.assign(scrollbar, {\n      $el,\n      el: $el[0],\n      $dragEl,\n      dragEl: $dragEl[0],\n    });\n\n    if (params.draggable) {\n      enableDraggable();\n    }\n\n    if ($el) {\n      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);\n    }\n  }\n  function destroy() {\n    const params = swiper.params.scrollbar;\n    const $el = swiper.scrollbar.$el;\n    if ($el) {\n      $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    }\n\n    disableDraggable();\n  }\n\n  on('init', () => {\n    if (swiper.params.scrollbar.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      updateSize();\n      setTranslate();\n    }\n  });\n  on('update resize observerUpdate lock unlock', () => {\n    updateSize();\n  });\n  on('setTranslate', () => {\n    setTranslate();\n  });\n  on('setTransition', (_s, duration) => {\n    setTransition(duration);\n  });\n  on('enable disable', () => {\n    const { $el } = swiper.scrollbar;\n    if ($el) {\n      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);\n    }\n  });\n  on('destroy', () => {\n    destroy();\n  });\n\n  const enable = () => {\n    swiper.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);\n    if (swiper.scrollbar.$el) {\n      swiper.scrollbar.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);\n    }\n    init();\n    updateSize();\n    setTranslate();\n  };\n\n  const disable = () => {\n    swiper.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);\n    if (swiper.scrollbar.$el) {\n      swiper.scrollbar.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);\n    }\n    destroy();\n  };\n\n  Object.assign(swiper.scrollbar, {\n    enable,\n    disable,\n    updateSize,\n    setTranslate,\n    init,\n    destroy,\n  });\n}\n","import $ from '../../shared/dom.js';\n\nexport default function Parallax({ swiper, extendParams, on }) {\n  extendParams({\n    parallax: {\n      enabled: false,\n    },\n  });\n\n  const setTransform = (el, progress) => {\n    const { rtl } = swiper;\n\n    const $el = $(el);\n    const rtlFactor = rtl ? -1 : 1;\n\n    const p = $el.attr('data-swiper-parallax') || '0';\n    let x = $el.attr('data-swiper-parallax-x');\n    let y = $el.attr('data-swiper-parallax-y');\n    const scale = $el.attr('data-swiper-parallax-scale');\n    const opacity = $el.attr('data-swiper-parallax-opacity');\n\n    if (x || y) {\n      x = x || '0';\n      y = y || '0';\n    } else if (swiper.isHorizontal()) {\n      x = p;\n      y = '0';\n    } else {\n      y = p;\n      x = '0';\n    }\n\n    if (x.indexOf('%') >= 0) {\n      x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n    } else {\n      x = `${x * progress * rtlFactor}px`;\n    }\n    if (y.indexOf('%') >= 0) {\n      y = `${parseInt(y, 10) * progress}%`;\n    } else {\n      y = `${y * progress}px`;\n    }\n\n    if (typeof opacity !== 'undefined' && opacity !== null) {\n      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n      $el[0].style.opacity = currentOpacity;\n    }\n    if (typeof scale === 'undefined' || scale === null) {\n      $el.transform(`translate3d(${x}, ${y}, 0px)`);\n    } else {\n      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);\n    }\n  };\n\n  const setTranslate = () => {\n    const { $el, slides, progress, snapGrid } = swiper;\n    $el\n      .children(\n        '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',\n      )\n      .each((el) => {\n        setTransform(el, progress);\n      });\n    slides.each((slideEl, slideIndex) => {\n      let slideProgress = slideEl.progress;\n      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n      }\n      slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n      $(slideEl)\n        .find(\n          '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',\n        )\n        .each((el) => {\n          setTransform(el, slideProgress);\n        });\n    });\n  };\n\n  const setTransition = (duration = swiper.params.speed) => {\n    const { $el } = swiper;\n    $el\n      .find(\n        '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',\n      )\n      .each((parallaxEl) => {\n        const $parallaxEl = $(parallaxEl);\n        let parallaxDuration =\n          parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;\n        if (duration === 0) parallaxDuration = 0;\n        $parallaxEl.transition(parallaxDuration);\n      });\n  };\n\n  on('beforeInit', () => {\n    if (!swiper.params.parallax.enabled) return;\n    swiper.params.watchSlidesProgress = true;\n    swiper.originalParams.watchSlidesProgress = true;\n  });\n  on('init', () => {\n    if (!swiper.params.parallax.enabled) return;\n    setTranslate();\n  });\n  on('setTranslate', () => {\n    if (!swiper.params.parallax.enabled) return;\n    setTranslate();\n  });\n  on('setTransition', (_swiper, duration) => {\n    if (!swiper.params.parallax.enabled) return;\n    setTransition(duration);\n  });\n}\n","import { getWindow } from 'ssr-window';\nimport $ from '../../shared/dom.js';\nimport { getTranslate } from '../../shared/utils.js';\n\nexport default function Zoom({ swiper, extendParams, on, emit }) {\n  const window = getWindow();\n  extendParams({\n    zoom: {\n      enabled: false,\n      maxRatio: 3,\n      minRatio: 1,\n      toggle: true,\n      containerClass: 'swiper-zoom-container',\n      zoomedSlideClass: 'swiper-slide-zoomed',\n    },\n  });\n\n  swiper.zoom = {\n    enabled: false,\n  };\n\n  let currentScale = 1;\n  let isScaling = false;\n  let gesturesEnabled;\n  let fakeGestureTouched;\n  let fakeGestureMoved;\n  const gesture = {\n    $slideEl: undefined,\n    slideWidth: undefined,\n    slideHeight: undefined,\n    $imageEl: undefined,\n    $imageWrapEl: undefined,\n    maxRatio: 3,\n  };\n  const image = {\n    isTouched: undefined,\n    isMoved: undefined,\n    currentX: undefined,\n    currentY: undefined,\n    minX: undefined,\n    minY: undefined,\n    maxX: undefined,\n    maxY: undefined,\n    width: undefined,\n    height: undefined,\n    startX: undefined,\n    startY: undefined,\n    touchesStart: {},\n    touchesCurrent: {},\n  };\n  const velocity = {\n    x: undefined,\n    y: undefined,\n    prevPositionX: undefined,\n    prevPositionY: undefined,\n    prevTime: undefined,\n  };\n\n  let scale = 1;\n  Object.defineProperty(swiper.zoom, 'scale', {\n    get() {\n      return scale;\n    },\n    set(value) {\n      if (scale !== value) {\n        const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;\n        const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;\n        emit('zoomChange', value, imageEl, slideEl);\n      }\n      scale = value;\n    },\n  });\n\n  function getDistanceBetweenTouches(e) {\n    if (e.targetTouches.length < 2) return 1;\n    const x1 = e.targetTouches[0].pageX;\n    const y1 = e.targetTouches[0].pageY;\n    const x2 = e.targetTouches[1].pageX;\n    const y2 = e.targetTouches[1].pageY;\n    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n    return distance;\n  }\n\n  // Events\n  function onGestureStart(e) {\n    const support = swiper.support;\n    const params = swiper.params.zoom;\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    if (!support.gestures) {\n      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {\n        return;\n      }\n      fakeGestureTouched = true;\n      gesture.scaleStart = getDistanceBetweenTouches(e);\n    }\n    if (!gesture.$slideEl || !gesture.$slideEl.length) {\n      gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);\n      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n      gesture.$imageEl = gesture.$slideEl\n        .find(`.${params.containerClass}`)\n        .eq(0)\n        .find('picture, img, svg, canvas, .swiper-zoom-target')\n        .eq(0);\n      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n      if (gesture.$imageWrapEl.length === 0) {\n        gesture.$imageEl = undefined;\n        return;\n      }\n    }\n    if (gesture.$imageEl) {\n      gesture.$imageEl.transition(0);\n    }\n    isScaling = true;\n  }\n  function onGestureChange(e) {\n    const support = swiper.support;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    if (!support.gestures) {\n      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {\n        return;\n      }\n      fakeGestureMoved = true;\n      gesture.scaleMove = getDistanceBetweenTouches(e);\n    }\n\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) {\n      if (e.type === 'gesturechange') onGestureStart(e);\n      return;\n    }\n    if (support.gestures) {\n      zoom.scale = e.scale * currentScale;\n    } else {\n      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * currentScale;\n    }\n    if (zoom.scale > gesture.maxRatio) {\n      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n    }\n    if (zoom.scale < params.minRatio) {\n      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n    }\n    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n  }\n  function onGestureEnd(e) {\n    const device = swiper.device;\n    const support = swiper.support;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    if (!support.gestures) {\n      if (!fakeGestureTouched || !fakeGestureMoved) {\n        return;\n      }\n      if (\n        e.type !== 'touchend' ||\n        (e.type === 'touchend' && e.changedTouches.length < 2 && !device.android)\n      ) {\n        return;\n      }\n      fakeGestureTouched = false;\n      fakeGestureMoved = false;\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n    gesture.$imageEl\n      .transition(swiper.params.speed)\n      .transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n    currentScale = zoom.scale;\n    isScaling = false;\n    if (zoom.scale === 1) gesture.$slideEl = undefined;\n  }\n  function onTouchStart(e) {\n    const device = swiper.device;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    if (image.isTouched) return;\n    if (device.android && e.cancelable) e.preventDefault();\n    image.isTouched = true;\n    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n  }\n  function onTouchMove(e) {\n    const zoom = swiper.zoom;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    swiper.allowClick = false;\n    if (!image.isTouched || !gesture.$slideEl) return;\n\n    if (!image.isMoved) {\n      image.width = gesture.$imageEl[0].offsetWidth;\n      image.height = gesture.$imageEl[0].offsetHeight;\n      image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;\n      image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;\n      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;\n      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;\n      gesture.$imageWrapEl.transition(0);\n    }\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n\n    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n\n    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\n    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\n\n    if (!image.isMoved && !isScaling) {\n      if (\n        swiper.isHorizontal() &&\n        ((Math.floor(image.minX) === Math.floor(image.startX) &&\n          image.touchesCurrent.x < image.touchesStart.x) ||\n          (Math.floor(image.maxX) === Math.floor(image.startX) &&\n            image.touchesCurrent.x > image.touchesStart.x))\n      ) {\n        image.isTouched = false;\n        return;\n      }\n      if (\n        !swiper.isHorizontal() &&\n        ((Math.floor(image.minY) === Math.floor(image.startY) &&\n          image.touchesCurrent.y < image.touchesStart.y) ||\n          (Math.floor(image.maxY) === Math.floor(image.startY) &&\n            image.touchesCurrent.y > image.touchesStart.y))\n      ) {\n        image.isTouched = false;\n        return;\n      }\n    }\n    if (e.cancelable) {\n      e.preventDefault();\n    }\n    e.stopPropagation();\n\n    image.isMoved = true;\n    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;\n    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;\n\n    if (image.currentX < image.minX) {\n      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n    }\n    if (image.currentX > image.maxX) {\n      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n    }\n\n    if (image.currentY < image.minY) {\n      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n    }\n    if (image.currentY > image.maxY) {\n      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n    }\n\n    // Velocity\n    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n    if (!velocity.prevTime) velocity.prevTime = Date.now();\n    velocity.x =\n      (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n    velocity.y =\n      (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n    velocity.prevPositionX = image.touchesCurrent.x;\n    velocity.prevPositionY = image.touchesCurrent.y;\n    velocity.prevTime = Date.now();\n\n    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);\n  }\n  function onTouchEnd() {\n    const zoom = swiper.zoom;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    if (!image.isTouched || !image.isMoved) {\n      image.isTouched = false;\n      image.isMoved = false;\n      return;\n    }\n    image.isTouched = false;\n    image.isMoved = false;\n    let momentumDurationX = 300;\n    let momentumDurationY = 300;\n    const momentumDistanceX = velocity.x * momentumDurationX;\n    const newPositionX = image.currentX + momentumDistanceX;\n    const momentumDistanceY = velocity.y * momentumDurationY;\n    const newPositionY = image.currentY + momentumDistanceY;\n\n    // Fix duration\n    if (velocity.x !== 0)\n      momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n    if (velocity.y !== 0)\n      momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n\n    image.currentX = newPositionX;\n    image.currentY = newPositionY;\n\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n\n    gesture.$imageWrapEl\n      .transition(momentumDuration)\n      .transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);\n  }\n  function onTransitionEnd() {\n    const zoom = swiper.zoom;\n    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {\n      if (gesture.$imageEl) {\n        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');\n      }\n      if (gesture.$imageWrapEl) {\n        gesture.$imageWrapEl.transform('translate3d(0,0,0)');\n      }\n\n      zoom.scale = 1;\n      currentScale = 1;\n\n      gesture.$slideEl = undefined;\n      gesture.$imageEl = undefined;\n      gesture.$imageWrapEl = undefined;\n    }\n  }\n\n  function zoomIn(e) {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n\n    if (!gesture.$slideEl) {\n      if (e && e.target) {\n        gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);\n      }\n      if (!gesture.$slideEl) {\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n          gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);\n        } else {\n          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n        }\n      }\n\n      gesture.$imageEl = gesture.$slideEl\n        .find(`.${params.containerClass}`)\n        .eq(0)\n        .find('picture, img, svg, canvas, .swiper-zoom-target')\n        .eq(0);\n      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n    }\n    if (\n      !gesture.$imageEl ||\n      gesture.$imageEl.length === 0 ||\n      !gesture.$imageWrapEl ||\n      gesture.$imageWrapEl.length === 0\n    )\n      return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.touchAction = 'none';\n    }\n\n    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);\n\n    let touchX;\n    let touchY;\n    let offsetX;\n    let offsetY;\n    let diffX;\n    let diffY;\n    let translateX;\n    let translateY;\n    let imageWidth;\n    let imageHeight;\n    let scaledWidth;\n    let scaledHeight;\n    let translateMinX;\n    let translateMinY;\n    let translateMaxX;\n    let translateMaxY;\n    let slideWidth;\n    let slideHeight;\n\n    if (typeof image.touchesStart.x === 'undefined' && e) {\n      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;\n      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;\n    } else {\n      touchX = image.touchesStart.x;\n      touchY = image.touchesStart.y;\n    }\n\n    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n    currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n    if (e) {\n      slideWidth = gesture.$slideEl[0].offsetWidth;\n      slideHeight = gesture.$slideEl[0].offsetHeight;\n      offsetX = gesture.$slideEl.offset().left + window.scrollX;\n      offsetY = gesture.$slideEl.offset().top + window.scrollY;\n      diffX = offsetX + slideWidth / 2 - touchX;\n      diffY = offsetY + slideHeight / 2 - touchY;\n\n      imageWidth = gesture.$imageEl[0].offsetWidth;\n      imageHeight = gesture.$imageEl[0].offsetHeight;\n      scaledWidth = imageWidth * zoom.scale;\n      scaledHeight = imageHeight * zoom.scale;\n\n      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n      translateMaxX = -translateMinX;\n      translateMaxY = -translateMinY;\n\n      translateX = diffX * zoom.scale;\n      translateY = diffY * zoom.scale;\n\n      if (translateX < translateMinX) {\n        translateX = translateMinX;\n      }\n      if (translateX > translateMaxX) {\n        translateX = translateMaxX;\n      }\n\n      if (translateY < translateMinY) {\n        translateY = translateMinY;\n      }\n      if (translateY > translateMaxY) {\n        translateY = translateMaxY;\n      }\n    } else {\n      translateX = 0;\n      translateY = 0;\n    }\n    gesture.$imageWrapEl\n      .transition(300)\n      .transform(`translate3d(${translateX}px, ${translateY}px,0)`);\n    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n  }\n  function zoomOut() {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n\n    if (!gesture.$slideEl) {\n      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);\n      } else {\n        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n      }\n      gesture.$imageEl = gesture.$slideEl\n        .find(`.${params.containerClass}`)\n        .eq(0)\n        .find('picture, img, svg, canvas, .swiper-zoom-target')\n        .eq(0);\n      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n    }\n    if (\n      !gesture.$imageEl ||\n      gesture.$imageEl.length === 0 ||\n      !gesture.$imageWrapEl ||\n      gesture.$imageWrapEl.length === 0\n    )\n      return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = '';\n      swiper.wrapperEl.style.touchAction = '';\n    }\n    zoom.scale = 1;\n    currentScale = 1;\n    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');\n    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');\n    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);\n    gesture.$slideEl = undefined;\n  }\n\n  // Toggle Zoom\n  function zoomToggle(e) {\n    const zoom = swiper.zoom;\n\n    if (zoom.scale && zoom.scale !== 1) {\n      // Zoom Out\n      zoomOut();\n    } else {\n      // Zoom In\n      zoomIn(e);\n    }\n  }\n\n  function getListeners() {\n    const support = swiper.support;\n    const passiveListener =\n      swiper.touchEvents.start === 'touchstart' &&\n      support.passiveListener &&\n      swiper.params.passiveListeners\n        ? { passive: true, capture: false }\n        : false;\n    const activeListenerWithCapture = support.passiveListener\n      ? { passive: false, capture: true }\n      : true;\n    return { passiveListener, activeListenerWithCapture };\n  }\n\n  function getSlideSelector() {\n    return `.${swiper.params.slideClass}`;\n  }\n\n  function toggleGestures(method) {\n    const { passiveListener } = getListeners();\n    const slideSelector = getSlideSelector();\n    swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);\n    swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);\n    swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);\n  }\n  function enableGestures() {\n    if (gesturesEnabled) return;\n    gesturesEnabled = true;\n    toggleGestures('on');\n  }\n  function disableGestures() {\n    if (!gesturesEnabled) return;\n    gesturesEnabled = false;\n    toggleGestures('off');\n  }\n\n  // Attach/Detach Events\n  function enable() {\n    const zoom = swiper.zoom;\n    if (zoom.enabled) return;\n    zoom.enabled = true;\n    const support = swiper.support;\n    const { passiveListener, activeListenerWithCapture } = getListeners();\n    const slideSelector = getSlideSelector();\n\n    // Scale image\n    if (support.gestures) {\n      swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);\n      swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);\n    } else if (swiper.touchEvents.start === 'touchstart') {\n      swiper.$wrapperEl.on(\n        swiper.touchEvents.start,\n        slideSelector,\n        onGestureStart,\n        passiveListener,\n      );\n      swiper.$wrapperEl.on(\n        swiper.touchEvents.move,\n        slideSelector,\n        onGestureChange,\n        activeListenerWithCapture,\n      );\n      swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);\n      if (swiper.touchEvents.cancel) {\n        swiper.$wrapperEl.on(\n          swiper.touchEvents.cancel,\n          slideSelector,\n          onGestureEnd,\n          passiveListener,\n        );\n      }\n    }\n\n    // Move image\n    swiper.$wrapperEl.on(\n      swiper.touchEvents.move,\n      `.${swiper.params.zoom.containerClass}`,\n      onTouchMove,\n      activeListenerWithCapture,\n    );\n  }\n  function disable() {\n    const zoom = swiper.zoom;\n    if (!zoom.enabled) return;\n    const support = swiper.support;\n    zoom.enabled = false;\n\n    const { passiveListener, activeListenerWithCapture } = getListeners();\n    const slideSelector = getSlideSelector();\n\n    // Scale image\n    if (support.gestures) {\n      swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);\n      swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);\n    } else if (swiper.touchEvents.start === 'touchstart') {\n      swiper.$wrapperEl.off(\n        swiper.touchEvents.start,\n        slideSelector,\n        onGestureStart,\n        passiveListener,\n      );\n      swiper.$wrapperEl.off(\n        swiper.touchEvents.move,\n        slideSelector,\n        onGestureChange,\n        activeListenerWithCapture,\n      );\n      swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);\n      if (swiper.touchEvents.cancel) {\n        swiper.$wrapperEl.off(\n          swiper.touchEvents.cancel,\n          slideSelector,\n          onGestureEnd,\n          passiveListener,\n        );\n      }\n    }\n\n    // Move image\n    swiper.$wrapperEl.off(\n      swiper.touchEvents.move,\n      `.${swiper.params.zoom.containerClass}`,\n      onTouchMove,\n      activeListenerWithCapture,\n    );\n  }\n\n  on('init', () => {\n    if (swiper.params.zoom.enabled) {\n      enable();\n    }\n  });\n  on('destroy', () => {\n    disable();\n  });\n  on('touchStart', (_s, e) => {\n    if (!swiper.zoom.enabled) return;\n    onTouchStart(e);\n  });\n  on('touchEnd', (_s, e) => {\n    if (!swiper.zoom.enabled) return;\n    onTouchEnd(e);\n  });\n  on('doubleTap', (_s, e) => {\n    if (\n      !swiper.animating &&\n      swiper.params.zoom.enabled &&\n      swiper.zoom.enabled &&\n      swiper.params.zoom.toggle\n    ) {\n      zoomToggle(e);\n    }\n  });\n  on('transitionEnd', () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n      onTransitionEnd();\n    }\n  });\n  on('slideChange', () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n      onTransitionEnd();\n    }\n  });\n\n  Object.assign(swiper.zoom, {\n    enable,\n    disable,\n    in: zoomIn,\n    out: zoomOut,\n    toggle: zoomToggle,\n  });\n}\n","import { getWindow } from 'ssr-window';\nimport $ from '../../shared/dom.js';\n\nexport default function Lazy({ swiper, extendParams, on, emit }) {\n  extendParams({\n    lazy: {\n      checkInView: false,\n      enabled: false,\n      loadPrevNext: false,\n      loadPrevNextAmount: 1,\n      loadOnTransitionStart: false,\n      scrollingElement: '',\n\n      elementClass: 'swiper-lazy',\n      loadingClass: 'swiper-lazy-loading',\n      loadedClass: 'swiper-lazy-loaded',\n      preloaderClass: 'swiper-lazy-preloader',\n    },\n  });\n\n  swiper.lazy = {};\n\n  let scrollHandlerAttached = false;\n  let initialImageLoaded = false;\n\n  function loadInSlide(index, loadInDuplicate = true) {\n    const params = swiper.params.lazy;\n    if (typeof index === 'undefined') return;\n    if (swiper.slides.length === 0) return;\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n    const $slideEl = isVirtual\n      ? swiper.$wrapperEl.children(\n          `.${swiper.params.slideClass}[data-swiper-slide-index=\"${index}\"]`,\n        )\n      : swiper.slides.eq(index);\n\n    const $images = $slideEl.find(\n      `.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`,\n    );\n    if (\n      $slideEl.hasClass(params.elementClass) &&\n      !$slideEl.hasClass(params.loadedClass) &&\n      !$slideEl.hasClass(params.loadingClass)\n    ) {\n      $images.push($slideEl[0]);\n    }\n    if ($images.length === 0) return;\n\n    $images.each((imageEl) => {\n      const $imageEl = $(imageEl);\n      $imageEl.addClass(params.loadingClass);\n\n      const background = $imageEl.attr('data-background');\n      const src = $imageEl.attr('data-src');\n      const srcset = $imageEl.attr('data-srcset');\n      const sizes = $imageEl.attr('data-sizes');\n      const $pictureEl = $imageEl.parent('picture');\n\n      swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {\n        if (\n          typeof swiper === 'undefined' ||\n          swiper === null ||\n          !swiper ||\n          (swiper && !swiper.params) ||\n          swiper.destroyed\n        )\n          return;\n        if (background) {\n          $imageEl.css('background-image', `url(\"${background}\")`);\n          $imageEl.removeAttr('data-background');\n        } else {\n          if (srcset) {\n            $imageEl.attr('srcset', srcset);\n            $imageEl.removeAttr('data-srcset');\n          }\n          if (sizes) {\n            $imageEl.attr('sizes', sizes);\n            $imageEl.removeAttr('data-sizes');\n          }\n          if ($pictureEl.length) {\n            $pictureEl.children('source').each((sourceEl) => {\n              const $source = $(sourceEl);\n\n              if ($source.attr('data-srcset')) {\n                $source.attr('srcset', $source.attr('data-srcset'));\n                $source.removeAttr('data-srcset');\n              }\n            });\n          }\n          if (src) {\n            $imageEl.attr('src', src);\n            $imageEl.removeAttr('data-src');\n          }\n        }\n\n        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);\n        $slideEl.find(`.${params.preloaderClass}`).remove();\n        if (swiper.params.loop && loadInDuplicate) {\n          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');\n          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {\n            const originalSlide = swiper.$wrapperEl.children(\n              `[data-swiper-slide-index=\"${slideOriginalIndex}\"]:not(.${swiper.params.slideDuplicateClass})`,\n            );\n            loadInSlide(originalSlide.index(), false);\n          } else {\n            const duplicatedSlide = swiper.$wrapperEl.children(\n              `.${swiper.params.slideDuplicateClass}[data-swiper-slide-index=\"${slideOriginalIndex}\"]`,\n            );\n            loadInSlide(duplicatedSlide.index(), false);\n          }\n        }\n        emit('lazyImageReady', $slideEl[0], $imageEl[0]);\n        if (swiper.params.autoHeight) {\n          swiper.updateAutoHeight();\n        }\n      });\n\n      emit('lazyImageLoad', $slideEl[0], $imageEl[0]);\n    });\n  }\n\n  function load() {\n    const { $wrapperEl, params: swiperParams, slides, activeIndex } = swiper;\n    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;\n    const params = swiperParams.lazy;\n\n    let slidesPerView = swiperParams.slidesPerView;\n    if (slidesPerView === 'auto') {\n      slidesPerView = 0;\n    }\n\n    function slideExist(index) {\n      if (isVirtual) {\n        if (\n          $wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index=\"${index}\"]`)\n            .length\n        ) {\n          return true;\n        }\n      } else if (slides[index]) return true;\n      return false;\n    }\n\n    function slideIndex(slideEl) {\n      if (isVirtual) {\n        return $(slideEl).attr('data-swiper-slide-index');\n      }\n      return $(slideEl).index();\n    }\n\n    if (!initialImageLoaded) initialImageLoaded = true;\n    if (swiper.params.watchSlidesProgress) {\n      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((slideEl) => {\n        const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();\n        loadInSlide(index);\n      });\n    } else if (slidesPerView > 1) {\n      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {\n        if (slideExist(i)) loadInSlide(i);\n      }\n    } else {\n      loadInSlide(activeIndex);\n    }\n    if (params.loadPrevNext) {\n      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {\n        const amount = params.loadPrevNextAmount;\n        const spv = Math.ceil(slidesPerView);\n        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);\n        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);\n        // Next Slides\n        for (let i = activeIndex + spv; i < maxIndex; i += 1) {\n          if (slideExist(i)) loadInSlide(i);\n        }\n        // Prev Slides\n        for (let i = minIndex; i < activeIndex; i += 1) {\n          if (slideExist(i)) loadInSlide(i);\n        }\n      } else {\n        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);\n        if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));\n\n        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);\n        if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));\n      }\n    }\n  }\n  function checkInViewOnLoad() {\n    const window = getWindow();\n    if (!swiper || swiper.destroyed) return;\n    const $scrollElement = swiper.params.lazy.scrollingElement\n      ? $(swiper.params.lazy.scrollingElement)\n      : $(window);\n    const isWindow = $scrollElement[0] === window;\n    const scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;\n    const scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;\n    const swiperOffset = swiper.$el.offset();\n    const { rtlTranslate: rtl } = swiper;\n\n    let inView = false;\n\n    if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;\n    const swiperCoord = [\n      [swiperOffset.left, swiperOffset.top],\n      [swiperOffset.left + swiper.width, swiperOffset.top],\n      [swiperOffset.left, swiperOffset.top + swiper.height],\n      [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],\n    ];\n    for (let i = 0; i < swiperCoord.length; i += 1) {\n      const point = swiperCoord[i];\n      if (\n        point[0] >= 0 &&\n        point[0] <= scrollElementWidth &&\n        point[1] >= 0 &&\n        point[1] <= scrollElementHeight\n      ) {\n        if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n        inView = true;\n      }\n    }\n\n    const passiveListener =\n      swiper.touchEvents.start === 'touchstart' &&\n      swiper.support.passiveListener &&\n      swiper.params.passiveListeners\n        ? { passive: true, capture: false }\n        : false;\n\n    if (inView) {\n      load();\n      $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);\n    } else if (!scrollHandlerAttached) {\n      scrollHandlerAttached = true;\n      $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);\n    }\n  }\n\n  on('beforeInit', () => {\n    if (swiper.params.lazy.enabled && swiper.params.preloadImages) {\n      swiper.params.preloadImages = false;\n    }\n  });\n  on('init', () => {\n    if (swiper.params.lazy.enabled) {\n      if (swiper.params.lazy.checkInView) {\n        checkInViewOnLoad();\n      } else {\n        load();\n      }\n    }\n  });\n  on('scroll', () => {\n    if (\n      swiper.params.freeMode &&\n      swiper.params.freeMode.enabled &&\n      !swiper.params.freeMode.sticky\n    ) {\n      load();\n    }\n  });\n  on('scrollbarDragMove resize _freeModeNoMomentumRelease', () => {\n    if (swiper.params.lazy.enabled) {\n      if (swiper.params.lazy.checkInView) {\n        checkInViewOnLoad();\n      } else {\n        load();\n      }\n    }\n  });\n  on('transitionStart', () => {\n    if (swiper.params.lazy.enabled) {\n      if (\n        swiper.params.lazy.loadOnTransitionStart ||\n        (!swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded)\n      ) {\n        if (swiper.params.lazy.checkInView) {\n          checkInViewOnLoad();\n        } else {\n          load();\n        }\n      }\n    }\n  });\n  on('transitionEnd', () => {\n    if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {\n      if (swiper.params.lazy.checkInView) {\n        checkInViewOnLoad();\n      } else {\n        load();\n      }\n    }\n  });\n  on('slideChange', () => {\n    const { lazy, cssMode, watchSlidesProgress, touchReleaseOnEdges, resistanceRatio } =\n      swiper.params;\n    if (\n      lazy.enabled &&\n      (cssMode || (watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0)))\n    ) {\n      load();\n    }\n  });\n\n  on('destroy', () => {\n    if (!swiper.$el) return;\n    swiper.$el\n      .find(`.${swiper.params.lazy.loadingClass}`)\n      .removeClass(swiper.params.lazy.loadingClass);\n  });\n\n  Object.assign(swiper.lazy, {\n    load,\n    loadInSlide,\n  });\n}\n","/* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\nimport { nextTick } from '../../shared/utils.js';\n\nexport default function Controller({ swiper, extendParams, on }) {\n  extendParams({\n    controller: {\n      control: undefined,\n      inverse: false,\n      by: 'slide', // or 'container'\n    },\n  });\n\n  swiper.controller = {\n    control: undefined,\n  };\n\n  function LinearSpline(x, y) {\n    const binarySearch = (function search() {\n      let maxIndex;\n      let minIndex;\n      let guess;\n      return (array, val) => {\n        minIndex = -1;\n        maxIndex = array.length;\n        while (maxIndex - minIndex > 1) {\n          guess = (maxIndex + minIndex) >> 1;\n          if (array[guess] <= val) {\n            minIndex = guess;\n          } else {\n            maxIndex = guess;\n          }\n        }\n        return maxIndex;\n      };\n    })();\n    this.x = x;\n    this.y = y;\n    this.lastIndex = x.length - 1;\n    // Given an x value (x2), return the expected y2 value:\n    // (x1,y1) is the known point before given value,\n    // (x3,y3) is the known point after given value.\n    let i1;\n    let i3;\n\n    this.interpolate = function interpolate(x2) {\n      if (!x2) return 0;\n\n      // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n      i3 = binarySearch(this.x, x2);\n      i1 = i3 - 1;\n\n      // We have our indexes i1 & i3, so we can calculate already:\n      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n      return (\n        ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1]\n      );\n    };\n    return this;\n  }\n  // xxx: for now i will just save one spline function to to\n  function getInterpolateFunction(c) {\n    if (!swiper.controller.spline) {\n      swiper.controller.spline = swiper.params.loop\n        ? new LinearSpline(swiper.slidesGrid, c.slidesGrid)\n        : new LinearSpline(swiper.snapGrid, c.snapGrid);\n    }\n  }\n  function setTranslate(_t, byController) {\n    const controlled = swiper.controller.control;\n    let multiplier;\n    let controlledTranslate;\n    const Swiper = swiper.constructor;\n    function setControlledTranslate(c) {\n      // this will create an Interpolate function based on the snapGrids\n      // x is the Grid of the scrolled scroller and y will be the controlled scroller\n      // it makes sense to create this only once and recall it for the interpolation\n      // the function does a lot of value caching for performance\n      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n      if (swiper.params.controller.by === 'slide') {\n        getInterpolateFunction(c);\n        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n        // but it did not work out\n        controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n      }\n\n      if (!controlledTranslate || swiper.params.controller.by === 'container') {\n        multiplier =\n          (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n      }\n\n      if (swiper.params.controller.inverse) {\n        controlledTranslate = c.maxTranslate() - controlledTranslate;\n      }\n      c.updateProgress(controlledTranslate);\n      c.setTranslate(controlledTranslate, swiper);\n      c.updateActiveIndex();\n      c.updateSlidesClasses();\n    }\n    if (Array.isArray(controlled)) {\n      for (let i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTranslate(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTranslate(controlled);\n    }\n  }\n  function setTransition(duration, byController) {\n    const Swiper = swiper.constructor;\n    const controlled = swiper.controller.control;\n    let i;\n    function setControlledTransition(c) {\n      c.setTransition(duration, swiper);\n      if (duration !== 0) {\n        c.transitionStart();\n        if (c.params.autoHeight) {\n          nextTick(() => {\n            c.updateAutoHeight();\n          });\n        }\n        c.$wrapperEl.transitionEnd(() => {\n          if (!controlled) return;\n          if (c.params.loop && swiper.params.controller.by === 'slide') {\n            c.loopFix();\n          }\n          c.transitionEnd();\n        });\n      }\n    }\n    if (Array.isArray(controlled)) {\n      for (i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTransition(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTransition(controlled);\n    }\n  }\n\n  function removeSpline() {\n    if (!swiper.controller.control) return;\n    if (swiper.controller.spline) {\n      swiper.controller.spline = undefined;\n      delete swiper.controller.spline;\n    }\n  }\n  on('beforeInit', () => {\n    swiper.controller.control = swiper.params.controller.control;\n  });\n  on('update', () => {\n    removeSpline();\n  });\n  on('resize', () => {\n    removeSpline();\n  });\n  on('observerUpdate', () => {\n    removeSpline();\n  });\n  on('setTranslate', (_s, translate, byController) => {\n    if (!swiper.controller.control) return;\n    swiper.controller.setTranslate(translate, byController);\n  });\n  on('setTransition', (_s, duration, byController) => {\n    if (!swiper.controller.control) return;\n    swiper.controller.setTransition(duration, byController);\n  });\n\n  Object.assign(swiper.controller, {\n    setTranslate,\n    setTransition,\n  });\n}\n","import classesToSelector from '../../shared/classes-to-selector.js';\nimport $ from '../../shared/dom.js';\n\nexport default function A11y({ swiper, extendParams, on }) {\n  extendParams({\n    a11y: {\n      enabled: true,\n      notificationClass: 'swiper-notification',\n      prevSlideMessage: 'Previous slide',\n      nextSlideMessage: 'Next slide',\n      firstSlideMessage: 'This is the first slide',\n      lastSlideMessage: 'This is the last slide',\n      paginationBulletMessage: 'Go to slide {{index}}',\n      slideLabelMessage: '{{index}} / {{slidesLength}}',\n      containerMessage: null,\n      containerRoleDescriptionMessage: null,\n      itemRoleDescriptionMessage: null,\n      slideRole: 'group',\n      id: null,\n    },\n  });\n\n  swiper.a11y = {\n    clicked: false,\n  };\n\n  let liveRegion = null;\n\n  function notify(message) {\n    const notification = liveRegion;\n    if (notification.length === 0) return;\n    notification.html('');\n    notification.html(message);\n  }\n\n  function getRandomNumber(size = 16) {\n    const randomChar = () => Math.round(16 * Math.random()).toString(16);\n    return 'x'.repeat(size).replace(/x/g, randomChar);\n  }\n  function makeElFocusable($el) {\n    $el.attr('tabIndex', '0');\n  }\n  function makeElNotFocusable($el) {\n    $el.attr('tabIndex', '-1');\n  }\n  function addElRole($el, role) {\n    $el.attr('role', role);\n  }\n  function addElRoleDescription($el, description) {\n    $el.attr('aria-roledescription', description);\n  }\n  function addElControls($el, controls) {\n    $el.attr('aria-controls', controls);\n  }\n  function addElLabel($el, label) {\n    $el.attr('aria-label', label);\n  }\n  function addElId($el, id) {\n    $el.attr('id', id);\n  }\n  function addElLive($el, live) {\n    $el.attr('aria-live', live);\n  }\n  function disableEl($el) {\n    $el.attr('aria-disabled', true);\n  }\n  function enableEl($el) {\n    $el.attr('aria-disabled', false);\n  }\n\n  function onEnterOrSpaceKey(e) {\n    if (e.keyCode !== 13 && e.keyCode !== 32) return;\n    const params = swiper.params.a11y;\n    const $targetEl = $(e.target);\n    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {\n      if (!(swiper.isEnd && !swiper.params.loop)) {\n        swiper.slideNext();\n      }\n      if (swiper.isEnd) {\n        notify(params.lastSlideMessage);\n      } else {\n        notify(params.nextSlideMessage);\n      }\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {\n      if (!(swiper.isBeginning && !swiper.params.loop)) {\n        swiper.slidePrev();\n      }\n      if (swiper.isBeginning) {\n        notify(params.firstSlideMessage);\n      } else {\n        notify(params.prevSlideMessage);\n      }\n    }\n\n    if (\n      swiper.pagination &&\n      $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))\n    ) {\n      $targetEl[0].click();\n    }\n  }\n\n  function updateNavigation() {\n    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n    const { $nextEl, $prevEl } = swiper.navigation;\n\n    if ($prevEl && $prevEl.length > 0) {\n      if (swiper.isBeginning) {\n        disableEl($prevEl);\n        makeElNotFocusable($prevEl);\n      } else {\n        enableEl($prevEl);\n        makeElFocusable($prevEl);\n      }\n    }\n    if ($nextEl && $nextEl.length > 0) {\n      if (swiper.isEnd) {\n        disableEl($nextEl);\n        makeElNotFocusable($nextEl);\n      } else {\n        enableEl($nextEl);\n        makeElFocusable($nextEl);\n      }\n    }\n  }\n\n  function hasPagination() {\n    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n  }\n\n  function hasClickablePagination() {\n    return hasPagination() && swiper.params.pagination.clickable;\n  }\n\n  function updatePagination() {\n    const params = swiper.params.a11y;\n    if (!hasPagination()) return;\n    swiper.pagination.bullets.each((bulletEl) => {\n      const $bulletEl = $(bulletEl);\n      if (swiper.params.pagination.clickable) {\n        makeElFocusable($bulletEl);\n        if (!swiper.params.pagination.renderBullet) {\n          addElRole($bulletEl, 'button');\n          addElLabel(\n            $bulletEl,\n            params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, $bulletEl.index() + 1),\n          );\n        }\n      }\n      if ($bulletEl.is(`.${swiper.params.pagination.bulletActiveClass}`)) {\n        $bulletEl.attr('aria-current', 'true');\n      } else {\n        $bulletEl.removeAttr('aria-current');\n      }\n    });\n  }\n\n  const initNavEl = ($el, wrapperId, message) => {\n    makeElFocusable($el);\n    if ($el[0].tagName !== 'BUTTON') {\n      addElRole($el, 'button');\n      $el.on('keydown', onEnterOrSpaceKey);\n    }\n    addElLabel($el, message);\n    addElControls($el, wrapperId);\n  };\n  const handlePointerDown = () => {\n    swiper.a11y.clicked = true;\n  };\n  const handlePointerUp = () => {\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => {\n        swiper.a11y.clicked = false;\n      });\n    });\n  };\n\n  const handleFocus = (e) => {\n    if (swiper.a11y.clicked) return;\n    const slideEl = e.target.closest(`.${swiper.params.slideClass}`);\n    if (!slideEl || !swiper.slides.includes(slideEl)) return;\n    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n    const isVisible =\n      swiper.params.watchSlidesProgress &&\n      swiper.visibleSlides &&\n      swiper.visibleSlides.includes(slideEl);\n    if (isActive || isVisible) return;\n    if (swiper.isHorizontal()) {\n      swiper.el.scrollLeft = 0;\n    } else {\n      swiper.el.scrollTop = 0;\n    }\n    swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n  };\n\n  const initSlides = () => {\n    const params = swiper.params.a11y;\n    if (params.itemRoleDescriptionMessage) {\n      addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);\n    }\n    if (params.slideRole) {\n      addElRole($(swiper.slides), params.slideRole);\n    }\n\n    const slidesLength = swiper.params.loop\n      ? swiper.slides.filter((el) => !el.classList.contains(swiper.params.slideDuplicateClass))\n          .length\n      : swiper.slides.length;\n    if (params.slideLabelMessage) {\n      swiper.slides.each((slideEl, index) => {\n        const $slideEl = $(slideEl);\n        const slideIndex = swiper.params.loop\n          ? parseInt($slideEl.attr('data-swiper-slide-index'), 10)\n          : index;\n        const ariaLabelMessage = params.slideLabelMessage\n          .replace(/\\{\\{index\\}\\}/, slideIndex + 1)\n          .replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n        addElLabel($slideEl, ariaLabelMessage);\n      });\n    }\n  };\n\n  const init = () => {\n    const params = swiper.params.a11y;\n\n    swiper.$el.append(liveRegion);\n\n    // Container\n    const $containerEl = swiper.$el;\n    if (params.containerRoleDescriptionMessage) {\n      addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);\n    }\n    if (params.containerMessage) {\n      addElLabel($containerEl, params.containerMessage);\n    }\n\n    // Wrapper\n    const $wrapperEl = swiper.$wrapperEl;\n    const wrapperId = params.id || $wrapperEl.attr('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n    addElId($wrapperEl, wrapperId);\n    addElLive($wrapperEl, live);\n\n    // Slide\n    initSlides();\n\n    // Navigation\n    let $nextEl;\n    let $prevEl;\n    if (swiper.navigation && swiper.navigation.$nextEl) {\n      $nextEl = swiper.navigation.$nextEl;\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl) {\n      $prevEl = swiper.navigation.$prevEl;\n    }\n\n    if ($nextEl && $nextEl.length) {\n      initNavEl($nextEl, wrapperId, params.nextSlideMessage);\n    }\n    if ($prevEl && $prevEl.length) {\n      initNavEl($prevEl, wrapperId, params.prevSlideMessage);\n    }\n\n    // Pagination\n    if (hasClickablePagination()) {\n      swiper.pagination.$el.on(\n        'keydown',\n        classesToSelector(swiper.params.pagination.bulletClass),\n        onEnterOrSpaceKey,\n      );\n    }\n\n    // Tab focus\n    swiper.$el.on('focus', handleFocus, true);\n    swiper.$el.on('pointerdown', handlePointerDown, true);\n    swiper.$el.on('pointerup', handlePointerUp, true);\n  };\n  function destroy() {\n    if (liveRegion && liveRegion.length > 0) liveRegion.remove();\n\n    let $nextEl;\n    let $prevEl;\n    if (swiper.navigation && swiper.navigation.$nextEl) {\n      $nextEl = swiper.navigation.$nextEl;\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl) {\n      $prevEl = swiper.navigation.$prevEl;\n    }\n    if ($nextEl) {\n      $nextEl.off('keydown', onEnterOrSpaceKey);\n    }\n    if ($prevEl) {\n      $prevEl.off('keydown', onEnterOrSpaceKey);\n    }\n\n    // Pagination\n    if (hasClickablePagination()) {\n      swiper.pagination.$el.off(\n        'keydown',\n        classesToSelector(swiper.params.pagination.bulletClass),\n        onEnterOrSpaceKey,\n      );\n    }\n\n    // Tab focus\n    swiper.$el.off('focus', handleFocus, true);\n    swiper.$el.off('pointerdown', handlePointerDown, true);\n    swiper.$el.off('pointerup', handlePointerUp, true);\n  }\n\n  on('beforeInit', () => {\n    liveRegion = $(\n      `<span class=\"${swiper.params.a11y.notificationClass}\" aria-live=\"assertive\" aria-atomic=\"true\"></span>`,\n    );\n  });\n\n  on('afterInit', () => {\n    if (!swiper.params.a11y.enabled) return;\n    init();\n  });\n  on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n    if (!swiper.params.a11y.enabled) return;\n    initSlides();\n  });\n  on('fromEdge toEdge afterInit lock unlock', () => {\n    if (!swiper.params.a11y.enabled) return;\n    updateNavigation();\n  });\n  on('paginationUpdate', () => {\n    if (!swiper.params.a11y.enabled) return;\n    updatePagination();\n  });\n  on('destroy', () => {\n    if (!swiper.params.a11y.enabled) return;\n    destroy();\n  });\n}\n","import { getWindow } from 'ssr-window';\n\nexport default function History({ swiper, extendParams, on }) {\n  extendParams({\n    history: {\n      enabled: false,\n      root: '',\n      replaceState: false,\n      key: 'slides',\n      keepQuery: false,\n    },\n  });\n\n  let initialized = false;\n  let paths = {};\n\n  const slugify = (text) => {\n    return text\n      .toString()\n      .replace(/\\s+/g, '-')\n      .replace(/[^\\w-]+/g, '')\n      .replace(/--+/g, '-')\n      .replace(/^-+/, '')\n      .replace(/-+$/, '');\n  };\n\n  const getPathValues = (urlOverride) => {\n    const window = getWindow();\n    let location;\n    if (urlOverride) {\n      location = new URL(urlOverride);\n    } else {\n      location = window.location;\n    }\n    const pathArray = location.pathname\n      .slice(1)\n      .split('/')\n      .filter((part) => part !== '');\n    const total = pathArray.length;\n    const key = pathArray[total - 2];\n    const value = pathArray[total - 1];\n    return { key, value };\n  };\n  const setHistory = (key, index) => {\n    const window = getWindow();\n    if (!initialized || !swiper.params.history.enabled) return;\n    let location;\n    if (swiper.params.url) {\n      location = new URL(swiper.params.url);\n    } else {\n      location = window.location;\n    }\n    const slide = swiper.slides.eq(index);\n    let value = slugify(slide.attr('data-history'));\n    if (swiper.params.history.root.length > 0) {\n      let root = swiper.params.history.root;\n      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n      value = `${root}/${key}/${value}`;\n    } else if (!location.pathname.includes(key)) {\n      value = `${key}/${value}`;\n    }\n    if (swiper.params.history.keepQuery) {\n      value += location.search;\n    }\n    const currentState = window.history.state;\n    if (currentState && currentState.value === value) {\n      return;\n    }\n    if (swiper.params.history.replaceState) {\n      window.history.replaceState({ value }, null, value);\n    } else {\n      window.history.pushState({ value }, null, value);\n    }\n  };\n\n  const scrollToSlide = (speed, value, runCallbacks) => {\n    if (value) {\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide = swiper.slides.eq(i);\n        const slideHistory = slugify(slide.attr('data-history'));\n        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n          const index = slide.index();\n          swiper.slideTo(index, speed, runCallbacks);\n        }\n      }\n    } else {\n      swiper.slideTo(0, speed, runCallbacks);\n    }\n  };\n\n  const setHistoryPopState = () => {\n    paths = getPathValues(swiper.params.url);\n    scrollToSlide(swiper.params.speed, paths.value, false);\n  };\n\n  const init = () => {\n    const window = getWindow();\n    if (!swiper.params.history) return;\n    if (!window.history || !window.history.pushState) {\n      swiper.params.history.enabled = false;\n      swiper.params.hashNavigation.enabled = true;\n      return;\n    }\n    initialized = true;\n    paths = getPathValues(swiper.params.url);\n    if (!paths.key && !paths.value) return;\n    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n    if (!swiper.params.history.replaceState) {\n      window.addEventListener('popstate', setHistoryPopState);\n    }\n  };\n  const destroy = () => {\n    const window = getWindow();\n    if (!swiper.params.history.replaceState) {\n      window.removeEventListener('popstate', setHistoryPopState);\n    }\n  };\n\n  on('init', () => {\n    if (swiper.params.history.enabled) {\n      init();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.params.history.enabled) {\n      destroy();\n    }\n  });\n  on('transitionEnd _freeModeNoMomentumRelease', () => {\n    if (initialized) {\n      setHistory(swiper.params.history.key, swiper.activeIndex);\n    }\n  });\n  on('slideChange', () => {\n    if (initialized && swiper.params.cssMode) {\n      setHistory(swiper.params.history.key, swiper.activeIndex);\n    }\n  });\n}\n","import { getWindow, getDocument } from 'ssr-window';\nimport $ from '../../shared/dom.js';\n\nexport default function HashNavigation({ swiper, extendParams, emit, on }) {\n  let initialized = false;\n  const document = getDocument();\n  const window = getWindow();\n  extendParams({\n    hashNavigation: {\n      enabled: false,\n      replaceState: false,\n      watchState: false,\n    },\n  });\n  const onHashChange = () => {\n    emit('hashChange');\n    const newHash = document.location.hash.replace('#', '');\n    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');\n    if (newHash !== activeSlideHash) {\n      const newIndex = swiper.$wrapperEl\n        .children(`.${swiper.params.slideClass}[data-hash=\"${newHash}\"]`)\n        .index();\n      if (typeof newIndex === 'undefined') return;\n      swiper.slideTo(newIndex);\n    }\n  };\n  const setHash = () => {\n    if (!initialized || !swiper.params.hashNavigation.enabled) return;\n    if (\n      swiper.params.hashNavigation.replaceState &&\n      window.history &&\n      window.history.replaceState\n    ) {\n      window.history.replaceState(\n        null,\n        null,\n        `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '',\n      );\n      emit('hashSet');\n    } else {\n      const slide = swiper.slides.eq(swiper.activeIndex);\n      const hash = slide.attr('data-hash') || slide.attr('data-history');\n      document.location.hash = hash || '';\n      emit('hashSet');\n    }\n  };\n  const init = () => {\n    if (\n      !swiper.params.hashNavigation.enabled ||\n      (swiper.params.history && swiper.params.history.enabled)\n    )\n      return;\n    initialized = true;\n    const hash = document.location.hash.replace('#', '');\n    if (hash) {\n      const speed = 0;\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide = swiper.slides.eq(i);\n        const slideHash = slide.attr('data-hash') || slide.attr('data-history');\n        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n          const index = slide.index();\n          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);\n        }\n      }\n    }\n    if (swiper.params.hashNavigation.watchState) {\n      $(window).on('hashchange', onHashChange);\n    }\n  };\n  const destroy = () => {\n    if (swiper.params.hashNavigation.watchState) {\n      $(window).off('hashchange', onHashChange);\n    }\n  };\n\n  on('init', () => {\n    if (swiper.params.hashNavigation.enabled) {\n      init();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.params.hashNavigation.enabled) {\n      destroy();\n    }\n  });\n  on('transitionEnd _freeModeNoMomentumRelease', () => {\n    if (initialized) {\n      setHash();\n    }\n  });\n  on('slideChange', () => {\n    if (initialized && swiper.params.cssMode) {\n      setHash();\n    }\n  });\n}\n","/* eslint no-underscore-dangle: \"off\" */\n/* eslint no-use-before-define: \"off\" */\nimport { getDocument } from 'ssr-window';\nimport { nextTick } from '../../shared/utils.js';\n\nexport default function Autoplay({ swiper, extendParams, on, emit }) {\n  let timeout;\n\n  swiper.autoplay = {\n    running: false,\n    paused: false,\n  };\n\n  extendParams({\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: true,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n      pauseOnMouseEnter: false,\n    },\n  });\n\n  function run() {\n    if (!swiper.size) {\n      swiper.autoplay.running = false;\n      swiper.autoplay.paused = false;\n      return;\n    }\n    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);\n    let delay = swiper.params.autoplay.delay;\n    if ($activeSlideEl.attr('data-swiper-autoplay')) {\n      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;\n    }\n    clearTimeout(timeout);\n    timeout = nextTick(() => {\n      let autoplayResult;\n      if (swiper.params.autoplay.reverseDirection) {\n        if (swiper.params.loop) {\n          swiper.loopFix();\n          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.isBeginning) {\n          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          autoplayResult = swiper.slideTo(\n            swiper.slides.length - 1,\n            swiper.params.speed,\n            true,\n            true,\n          );\n          emit('autoplay');\n        } else {\n          stop();\n        }\n      } else if (swiper.params.loop) {\n        swiper.loopFix();\n        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);\n        emit('autoplay');\n      } else if (!swiper.isEnd) {\n        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);\n        emit('autoplay');\n      } else if (!swiper.params.autoplay.stopOnLastSlide) {\n        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);\n        emit('autoplay');\n      } else {\n        stop();\n      }\n      if (swiper.params.cssMode && swiper.autoplay.running) run();\n      else if (autoplayResult === false) {\n        run();\n      }\n    }, delay);\n  }\n  function start() {\n    if (typeof timeout !== 'undefined') return false;\n    if (swiper.autoplay.running) return false;\n    swiper.autoplay.running = true;\n    emit('autoplayStart');\n    run();\n    return true;\n  }\n  function stop() {\n    if (!swiper.autoplay.running) return false;\n    if (typeof timeout === 'undefined') return false;\n\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = undefined;\n    }\n    swiper.autoplay.running = false;\n    emit('autoplayStop');\n    return true;\n  }\n  function pause(speed) {\n    if (!swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) return;\n    if (timeout) clearTimeout(timeout);\n    swiper.autoplay.paused = true;\n    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {\n      swiper.autoplay.paused = false;\n      run();\n    } else {\n      ['transitionend', 'webkitTransitionEnd'].forEach((event) => {\n        swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);\n      });\n    }\n  }\n  function onVisibilityChange() {\n    const document = getDocument();\n    if (document.visibilityState === 'hidden' && swiper.autoplay.running) {\n      pause();\n    }\n    if (document.visibilityState === 'visible' && swiper.autoplay.paused) {\n      run();\n      swiper.autoplay.paused = false;\n    }\n  }\n  function onTransitionEnd(e) {\n    if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;\n    if (e.target !== swiper.$wrapperEl[0]) return;\n    ['transitionend', 'webkitTransitionEnd'].forEach((event) => {\n      swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);\n    });\n    swiper.autoplay.paused = false;\n    if (!swiper.autoplay.running) {\n      stop();\n    } else {\n      run();\n    }\n  }\n  function onMouseEnter() {\n    if (swiper.params.autoplay.disableOnInteraction) {\n      stop();\n    } else {\n      emit('autoplayPause');\n      pause();\n    }\n\n    ['transitionend', 'webkitTransitionEnd'].forEach((event) => {\n      swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);\n    });\n  }\n  function onMouseLeave() {\n    if (swiper.params.autoplay.disableOnInteraction) {\n      return;\n    }\n    swiper.autoplay.paused = false;\n    emit('autoplayResume');\n    run();\n  }\n  function attachMouseEvents() {\n    if (swiper.params.autoplay.pauseOnMouseEnter) {\n      swiper.$el.on('mouseenter', onMouseEnter);\n      swiper.$el.on('mouseleave', onMouseLeave);\n    }\n  }\n  function detachMouseEvents() {\n    swiper.$el.off('mouseenter', onMouseEnter);\n    swiper.$el.off('mouseleave', onMouseLeave);\n  }\n\n  on('init', () => {\n    if (swiper.params.autoplay.enabled) {\n      start();\n      const document = getDocument();\n      document.addEventListener('visibilitychange', onVisibilityChange);\n      attachMouseEvents();\n    }\n  });\n  on('beforeTransitionStart', (_s, speed, internal) => {\n    if (swiper.autoplay.running) {\n      if (internal || !swiper.params.autoplay.disableOnInteraction) {\n        swiper.autoplay.pause(speed);\n      } else {\n        stop();\n      }\n    }\n  });\n  on('sliderFirstMove', () => {\n    if (swiper.autoplay.running) {\n      if (swiper.params.autoplay.disableOnInteraction) {\n        stop();\n      } else {\n        pause();\n      }\n    }\n  });\n  on('touchEnd', () => {\n    if (\n      swiper.params.cssMode &&\n      swiper.autoplay.paused &&\n      !swiper.params.autoplay.disableOnInteraction\n    ) {\n      run();\n    }\n  });\n  on('destroy', () => {\n    detachMouseEvents();\n    if (swiper.autoplay.running) {\n      stop();\n    }\n    const document = getDocument();\n    document.removeEventListener('visibilitychange', onVisibilityChange);\n  });\n\n  Object.assign(swiper.autoplay, {\n    pause,\n    run,\n    start,\n    stop,\n  });\n}\n","import { isObject } from '../../shared/utils.js';\nimport $ from '../../shared/dom.js';\n\nexport default function Thumb({ swiper, extendParams, on }) {\n  extendParams({\n    thumbs: {\n      swiper: null,\n      multipleActiveThumbs: true,\n      autoScrollOffset: 0,\n      slideThumbActiveClass: 'swiper-slide-thumb-active',\n      thumbsContainerClass: 'swiper-thumbs',\n    },\n  });\n\n  let initialized = false;\n  let swiperCreated = false;\n\n  swiper.thumbs = {\n    swiper: null,\n  };\n\n  function onThumbClick() {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\n    const clickedIndex = thumbsSwiper.clickedIndex;\n    const clickedSlide = thumbsSwiper.clickedSlide;\n    if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass))\n      return;\n    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n    let slideToIndex;\n    if (thumbsSwiper.params.loop) {\n      slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n    } else {\n      slideToIndex = clickedIndex;\n    }\n    if (swiper.params.loop) {\n      let currentIndex = swiper.activeIndex;\n      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {\n        swiper.loopFix();\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n        currentIndex = swiper.activeIndex;\n      }\n      const prevIndex = swiper.slides\n        .eq(currentIndex)\n        .prevAll(`[data-swiper-slide-index=\"${slideToIndex}\"]`)\n        .eq(0)\n        .index();\n      const nextIndex = swiper.slides\n        .eq(currentIndex)\n        .nextAll(`[data-swiper-slide-index=\"${slideToIndex}\"]`)\n        .eq(0)\n        .index();\n      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;\n      else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;\n      else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;\n      else slideToIndex = prevIndex;\n    }\n    swiper.slideTo(slideToIndex);\n  }\n\n  function init() {\n    const { thumbs: thumbsParams } = swiper.params;\n    if (initialized) return false;\n    initialized = true;\n    const SwiperClass = swiper.constructor;\n    if (thumbsParams.swiper instanceof SwiperClass) {\n      swiper.thumbs.swiper = thumbsParams.swiper;\n      Object.assign(swiper.thumbs.swiper.originalParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n      Object.assign(swiper.thumbs.swiper.params, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n    } else if (isObject(thumbsParams.swiper)) {\n      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n      Object.assign(thumbsSwiperParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n      swiperCreated = true;\n    }\n    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);\n    swiper.thumbs.swiper.on('tap', onThumbClick);\n    return true;\n  }\n\n  function update(initial) {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\n    const slidesPerView =\n      thumbsSwiper.params.slidesPerView === 'auto'\n        ? thumbsSwiper.slidesPerViewDynamic()\n        : thumbsSwiper.params.slidesPerView;\n\n    // Activate thumbs\n    let thumbsToActivate = 1;\n    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n\n    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n      thumbsToActivate = swiper.params.slidesPerView;\n    }\n\n    if (!swiper.params.thumbs.multipleActiveThumbs) {\n      thumbsToActivate = 1;\n    }\n\n    thumbsToActivate = Math.floor(thumbsToActivate);\n\n    thumbsSwiper.slides.removeClass(thumbActiveClass);\n    if (\n      thumbsSwiper.params.loop ||\n      (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)\n    ) {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        thumbsSwiper.$wrapperEl\n          .children(`[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`)\n          .addClass(thumbActiveClass);\n      }\n    } else {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);\n      }\n    }\n\n    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n      let currentThumbsIndex = thumbsSwiper.activeIndex;\n      let newThumbsIndex;\n      let direction;\n      if (thumbsSwiper.params.loop) {\n        if (\n          thumbsSwiper.slides\n            .eq(currentThumbsIndex)\n            .hasClass(thumbsSwiper.params.slideDuplicateClass)\n        ) {\n          thumbsSwiper.loopFix();\n          // eslint-disable-next-line\n          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;\n          currentThumbsIndex = thumbsSwiper.activeIndex;\n        }\n        // Find actual thumbs index to slide to\n        const prevThumbsIndex = thumbsSwiper.slides\n          .eq(currentThumbsIndex)\n          .prevAll(`[data-swiper-slide-index=\"${swiper.realIndex}\"]`)\n          .eq(0)\n          .index();\n        const nextThumbsIndex = thumbsSwiper.slides\n          .eq(currentThumbsIndex)\n          .nextAll(`[data-swiper-slide-index=\"${swiper.realIndex}\"]`)\n          .eq(0)\n          .index();\n        if (typeof prevThumbsIndex === 'undefined') {\n          newThumbsIndex = nextThumbsIndex;\n        } else if (typeof nextThumbsIndex === 'undefined') {\n          newThumbsIndex = prevThumbsIndex;\n        } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {\n          newThumbsIndex =\n            thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;\n        } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {\n          newThumbsIndex = nextThumbsIndex;\n        } else {\n          newThumbsIndex = prevThumbsIndex;\n        }\n        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n      } else {\n        newThumbsIndex = swiper.realIndex;\n        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n      }\n      if (useOffset) {\n        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n      }\n\n      if (\n        thumbsSwiper.visibleSlidesIndexes &&\n        thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0\n      ) {\n        if (thumbsSwiper.params.centeredSlides) {\n          if (newThumbsIndex > currentThumbsIndex) {\n            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n          } else {\n            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n          }\n        } else if (\n          newThumbsIndex > currentThumbsIndex &&\n          thumbsSwiper.params.slidesPerGroup === 1\n        ) {\n          // newThumbsIndex = newThumbsIndex - slidesPerView + 1;\n        }\n        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n      }\n    }\n  }\n\n  on('beforeInit', () => {\n    const { thumbs } = swiper.params;\n    if (!thumbs || !thumbs.swiper) return;\n    init();\n    update(true);\n  });\n  on('slideChange update resize observerUpdate', () => {\n    update();\n  });\n  on('setTransition', (_s, duration) => {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    thumbsSwiper.setTransition(duration);\n  });\n  on('beforeDestroy', () => {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    if (swiperCreated) {\n      thumbsSwiper.destroy();\n    }\n  });\n\n  Object.assign(swiper.thumbs, {\n    init,\n    update,\n  });\n}\n","import { now } from '../../shared/utils.js';\n\nexport default function freeMode({ swiper, extendParams, emit, once }) {\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02,\n    },\n  });\n\n  function onTouchStart() {\n    const translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({ currentPos: swiper.rtl ? swiper.translate : -swiper.translate });\n  }\n\n  function onTouchMove() {\n    const { touchEventsData: data, touches } = swiper;\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime,\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now(),\n    });\n  }\n\n  function onTouchEnd({ currentPos }) {\n    const { params, $wrapperEl, rtlTranslate: rtl, snapGrid, touchEventsData: data } = swiper;\n    // Time diff\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (\n          Math.abs(snapGrid[nextSlide] - newPosition) <\n            Math.abs(snapGrid[nextSlide - 1] - newPosition) ||\n          swiper.swipeDirection === 'next'\n        ) {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(() => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(() => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd,\n    },\n  });\n}\n","export default function Grid({ swiper, extendParams }) {\n  extendParams({\n    grid: {\n      rows: 1,\n      fill: 'column',\n    },\n  });\n\n  let slidesNumberEvenToRows;\n  let slidesPerRow;\n  let numFullColumns;\n\n  const initSlides = (slidesLength) => {\n    const { slidesPerView } = swiper.params;\n    const { rows, fill } = swiper.params.grid;\n    slidesPerRow = slidesNumberEvenToRows / rows;\n    numFullColumns = Math.floor(slidesLength / rows);\n    if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n      slidesNumberEvenToRows = slidesLength;\n    } else {\n      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n    }\n    if (slidesPerView !== 'auto' && fill === 'row') {\n      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n    }\n  };\n\n  const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {\n    const { slidesPerGroup, spaceBetween } = swiper.params;\n    const { rows, fill } = swiper.params.grid;\n    // Set slides order\n    let newSlideOrderIndex;\n    let column;\n    let row;\n    if (fill === 'row' && slidesPerGroup > 1) {\n      const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n      const columnsInGroup =\n        groupIndex === 0\n          ? slidesPerGroup\n          : Math.min(\n              Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows),\n              slidesPerGroup,\n            );\n      row = Math.floor(slideIndexInGroup / columnsInGroup);\n      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n\n      newSlideOrderIndex = column + (row * slidesNumberEvenToRows) / rows;\n      slide.css({\n        '-webkit-order': newSlideOrderIndex,\n        order: newSlideOrderIndex,\n      });\n    } else if (fill === 'column') {\n      column = Math.floor(i / rows);\n      row = i - column * rows;\n      if (column > numFullColumns || (column === numFullColumns && row === rows - 1)) {\n        row += 1;\n        if (row >= rows) {\n          row = 0;\n          column += 1;\n        }\n      }\n    } else {\n      row = Math.floor(i / slidesPerRow);\n      column = i - row * slidesPerRow;\n    }\n    slide.css(\n      getDirectionLabel('margin-top'),\n      row !== 0 ? spaceBetween && `${spaceBetween}px` : '',\n    );\n  };\n\n  const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n    const { spaceBetween, centeredSlides, roundLengths } = swiper.params;\n    const { rows } = swiper.params.grid;\n    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n    swiper.$wrapperEl.css({\n      [getDirectionLabel('width')]: `${swiper.virtualSize + spaceBetween}px`,\n    });\n    if (centeredSlides) {\n      snapGrid.splice(0, snapGrid.length);\n      const newSlidesGrid = [];\n      for (let i = 0; i < snapGrid.length; i += 1) {\n        let slidesGridItem = snapGrid[i];\n        if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n      }\n      snapGrid.push(...newSlidesGrid);\n    }\n  };\n\n  swiper.grid = {\n    initSlides,\n    updateSlide,\n    updateWrapperSize,\n  };\n}\n","import appendSlide from './methods/appendSlide.js';\nimport prependSlide from './methods/prependSlide.js';\nimport addSlide from './methods/addSlide.js';\nimport removeSlide from './methods/removeSlide.js';\nimport removeAllSlides from './methods/removeAllSlides.js';\n\nexport default function Manipulation({ swiper }) {\n  Object.assign(swiper, {\n    appendSlide: appendSlide.bind(swiper),\n    prependSlide: prependSlide.bind(swiper),\n    addSlide: addSlide.bind(swiper),\n    removeSlide: removeSlide.bind(swiper),\n    removeAllSlides: removeAllSlides.bind(swiper),\n  });\n}\n","import effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\n\nexport default function EffectFade({ swiper, extendParams, on }) {\n  extendParams({\n    fadeEffect: {\n      crossFade: false,\n      transformEl: null,\n    },\n  });\n\n  const setTranslate = () => {\n    const { slides } = swiper;\n    const params = swiper.params.fadeEffect;\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = swiper.slides.eq(i);\n      const offset = $slideEl[0].swiperSlideOffset;\n      let tx = -offset;\n      if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n      }\n      const slideOpacity = swiper.params.fadeEffect.crossFade\n        ? Math.max(1 - Math.abs($slideEl[0].progress), 0)\n        : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);\n\n      const $targetEl = effectTarget(params, $slideEl);\n      $targetEl\n        .css({\n          opacity: slideOpacity,\n        })\n        .transform(`translate3d(${tx}px, ${ty}px, 0px)`);\n    }\n  };\n  const setTransition = (duration) => {\n    const { transformEl } = swiper.params.fadeEffect;\n    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n    $transitionElements.transition(duration);\n    effectVirtualTransitionEnd({ swiper, duration, transformEl, allSlides: true });\n  };\n\n  effectInit({\n    effect: 'fade',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode,\n    }),\n  });\n}\n","import $ from '../../shared/dom.js';\nimport effectInit from '../../shared/effect-init.js';\n\nexport default function EffectCube({ swiper, extendParams, on }) {\n  extendParams({\n    cubeEffect: {\n      slideShadows: true,\n      shadow: true,\n      shadowOffset: 20,\n      shadowScale: 0.94,\n    },\n  });\n\n  const createSlideShadows = ($slideEl, progress, isHorizontal) => {\n    let shadowBefore = isHorizontal\n      ? $slideEl.find('.swiper-slide-shadow-left')\n      : $slideEl.find('.swiper-slide-shadow-top');\n    let shadowAfter = isHorizontal\n      ? $slideEl.find('.swiper-slide-shadow-right')\n      : $slideEl.find('.swiper-slide-shadow-bottom');\n    if (shadowBefore.length === 0) {\n      shadowBefore = $(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}\"></div>`);\n      $slideEl.append(shadowBefore);\n    }\n    if (shadowAfter.length === 0) {\n      shadowAfter = $(\n        `<div class=\"swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}\"></div>`,\n      );\n      $slideEl.append(shadowAfter);\n    }\n    if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);\n    if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);\n  };\n\n  const recreateShadows = () => {\n    // create new ones\n    const isHorizontal = swiper.isHorizontal();\n    swiper.slides.each((slideEl) => {\n      const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      createSlideShadows($(slideEl), progress, isHorizontal);\n    });\n  };\n\n  const setTranslate = () => {\n    const {\n      $el,\n      $wrapperEl,\n      slides,\n      width: swiperWidth,\n      height: swiperHeight,\n      rtlTranslate: rtl,\n      size: swiperSize,\n      browser,\n    } = swiper;\n    const params = swiper.params.cubeEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let wrapperRotate = 0;\n    let $cubeShadowEl;\n    if (params.shadow) {\n      if (isHorizontal) {\n        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');\n        if ($cubeShadowEl.length === 0) {\n          $cubeShadowEl = $('<div class=\"swiper-cube-shadow\"></div>');\n          $wrapperEl.append($cubeShadowEl);\n        }\n        $cubeShadowEl.css({ height: `${swiperWidth}px` });\n      } else {\n        $cubeShadowEl = $el.find('.swiper-cube-shadow');\n        if ($cubeShadowEl.length === 0) {\n          $cubeShadowEl = $('<div class=\"swiper-cube-shadow\"></div>');\n          $el.append($cubeShadowEl);\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = slides.eq(i);\n      let slideIndex = i;\n      if (isVirtual) {\n        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);\n      }\n      let slideAngle = slideIndex * 90;\n      let round = Math.floor(slideAngle / 360);\n      if (rtl) {\n        slideAngle = -slideAngle;\n        round = Math.floor(-slideAngle / 360);\n      }\n      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n      let tx = 0;\n      let ty = 0;\n      let tz = 0;\n      if (slideIndex % 4 === 0) {\n        tx = -round * 4 * swiperSize;\n        tz = 0;\n      } else if ((slideIndex - 1) % 4 === 0) {\n        tx = 0;\n        tz = -round * 4 * swiperSize;\n      } else if ((slideIndex - 2) % 4 === 0) {\n        tx = swiperSize + round * 4 * swiperSize;\n        tz = swiperSize;\n      } else if ((slideIndex - 3) % 4 === 0) {\n        tx = -swiperSize;\n        tz = 3 * swiperSize + swiperSize * 4 * round;\n      }\n      if (rtl) {\n        tx = -tx;\n      }\n\n      if (!isHorizontal) {\n        ty = tx;\n        tx = 0;\n      }\n\n      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${\n        isHorizontal ? slideAngle : 0\n      }deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n      if (progress <= 1 && progress > -1) {\n        wrapperRotate = slideIndex * 90 + progress * 90;\n        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n      }\n      $slideEl.transform(transform);\n      if (params.slideShadows) {\n        createSlideShadows($slideEl, progress, isHorizontal);\n      }\n    }\n    $wrapperEl.css({\n      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,\n      'transform-origin': `50% 50% -${swiperSize / 2}px`,\n    });\n\n    if (params.shadow) {\n      if (isHorizontal) {\n        $cubeShadowEl.transform(\n          `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${\n            -swiperWidth / 2\n          }px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`,\n        );\n      } else {\n        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n        const multiplier =\n          1.5 -\n          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2 +\n            Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2);\n        const scale1 = params.shadowScale;\n        const scale2 = params.shadowScale / multiplier;\n        const offset = params.shadowOffset;\n        $cubeShadowEl.transform(\n          `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${\n            -swiperHeight / 2 / scale2\n          }px) rotateX(-90deg)`,\n        );\n      }\n    }\n    const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;\n    $wrapperEl.transform(\n      `translate3d(0px,0,${zFactor}px) rotateX(${\n        swiper.isHorizontal() ? 0 : wrapperRotate\n      }deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`,\n    );\n    $wrapperEl[0].style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n  };\n  const setTransition = (duration) => {\n    const { $el, slides } = swiper;\n    slides\n      .transition(duration)\n      .find(\n        '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n      )\n      .transition(duration);\n    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n      $el.find('.swiper-cube-shadow').transition(duration);\n    }\n  };\n\n  effectInit({\n    effect: 'cube',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    recreateShadows,\n    getEffectParams: () => swiper.params.cubeEffect,\n    perspective: () => true,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      resistanceRatio: 0,\n      spaceBetween: 0,\n      centeredSlides: false,\n      virtualTranslate: true,\n    }),\n  });\n}\n","import $ from '../../shared/dom.js';\nimport createShadow from '../../shared/create-shadow.js';\nimport effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\n\nexport default function EffectFlip({ swiper, extendParams, on }) {\n  extendParams({\n    flipEffect: {\n      slideShadows: true,\n      limitRotation: true,\n      transformEl: null,\n    },\n  });\n\n  const createSlideShadows = ($slideEl, progress, params) => {\n    let shadowBefore = swiper.isHorizontal()\n      ? $slideEl.find('.swiper-slide-shadow-left')\n      : $slideEl.find('.swiper-slide-shadow-top');\n    let shadowAfter = swiper.isHorizontal()\n      ? $slideEl.find('.swiper-slide-shadow-right')\n      : $slideEl.find('.swiper-slide-shadow-bottom');\n    if (shadowBefore.length === 0) {\n      shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');\n    }\n    if (shadowAfter.length === 0) {\n      shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n    }\n    if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);\n    if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);\n  };\n\n  const recreateShadows = () => {\n    // Set shadows\n    const params = swiper.params.flipEffect;\n    swiper.slides.each((slideEl) => {\n      const $slideEl = $(slideEl);\n      let progress = $slideEl[0].progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      }\n      createSlideShadows($slideEl, progress, params);\n    });\n  };\n\n  const setTranslate = () => {\n    const { slides, rtlTranslate: rtl } = swiper;\n    const params = swiper.params.flipEffect;\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = slides.eq(i);\n      let progress = $slideEl[0].progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n      }\n      const offset = $slideEl[0].swiperSlideOffset;\n      const rotate = -180 * progress;\n      let rotateY = rotate;\n      let rotateX = 0;\n      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n        rotateX = -rotateY;\n        rotateY = 0;\n      } else if (rtl) {\n        rotateY = -rotateY;\n      }\n\n      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n\n      if (params.slideShadows) {\n        createSlideShadows($slideEl, progress, params);\n      }\n      const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n      const $targetEl = effectTarget(params, $slideEl);\n      $targetEl.transform(transform);\n    }\n  };\n\n  const setTransition = (duration) => {\n    const { transformEl } = swiper.params.flipEffect;\n    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n    $transitionElements\n      .transition(duration)\n      .find(\n        '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n      )\n      .transition(duration);\n    effectVirtualTransitionEnd({ swiper, duration, transformEl });\n  };\n\n  effectInit({\n    effect: 'flip',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    recreateShadows,\n    getEffectParams: () => swiper.params.flipEffect,\n    perspective: () => true,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode,\n    }),\n  });\n}\n","import createShadow from '../../shared/create-shadow.js';\nimport effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\n\nexport default function EffectCoverflow({ swiper, extendParams, on }) {\n  extendParams({\n    coverflowEffect: {\n      rotate: 50,\n      stretch: 0,\n      depth: 100,\n      scale: 1,\n      modifier: 1,\n      slideShadows: true,\n      transformEl: null,\n    },\n  });\n\n  const setTranslate = () => {\n    const { width: swiperWidth, height: swiperHeight, slides, slidesSizesGrid } = swiper;\n    const params = swiper.params.coverflowEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const transform = swiper.translate;\n    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n    const rotate = isHorizontal ? params.rotate : -params.rotate;\n    const translate = params.depth;\n    // Each slide offset from center\n    for (let i = 0, length = slides.length; i < length; i += 1) {\n      const $slideEl = slides.eq(i);\n      const slideSize = slidesSizesGrid[i];\n      const slideOffset = $slideEl[0].swiperSlideOffset;\n      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n      const offsetMultiplier =\n        typeof params.modifier === 'function'\n          ? params.modifier(centerOffset)\n          : centerOffset * params.modifier;\n\n      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n      // var rotateZ = 0\n      let translateZ = -translate * Math.abs(offsetMultiplier);\n\n      let stretch = params.stretch;\n      // Allow percentage to make a relative stretch for responsive sliders\n      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n        stretch = (parseFloat(params.stretch) / 100) * slideSize;\n      }\n      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n\n      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n      // Fix for ultra small values\n      if (Math.abs(translateX) < 0.001) translateX = 0;\n      if (Math.abs(translateY) < 0.001) translateY = 0;\n      if (Math.abs(translateZ) < 0.001) translateZ = 0;\n      if (Math.abs(rotateY) < 0.001) rotateY = 0;\n      if (Math.abs(rotateX) < 0.001) rotateX = 0;\n      if (Math.abs(scale) < 0.001) scale = 0;\n\n      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n      const $targetEl = effectTarget(params, $slideEl);\n      $targetEl.transform(slideTransform);\n\n      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n\n      if (params.slideShadows) {\n        // Set shadows\n        let $shadowBeforeEl = isHorizontal\n          ? $slideEl.find('.swiper-slide-shadow-left')\n          : $slideEl.find('.swiper-slide-shadow-top');\n        let $shadowAfterEl = isHorizontal\n          ? $slideEl.find('.swiper-slide-shadow-right')\n          : $slideEl.find('.swiper-slide-shadow-bottom');\n        if ($shadowBeforeEl.length === 0) {\n          $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? 'left' : 'top');\n        }\n        if ($shadowAfterEl.length === 0) {\n          $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? 'right' : 'bottom');\n        }\n        if ($shadowBeforeEl.length)\n          $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n        if ($shadowAfterEl.length)\n          $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n      }\n    }\n  };\n  const setTransition = (duration) => {\n    const { transformEl } = swiper.params.coverflowEffect;\n    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n    $transitionElements\n      .transition(duration)\n      .find(\n        '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n      )\n      .transition(duration);\n  };\n\n  effectInit({\n    effect: 'coverflow',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => true,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n    }),\n  });\n}\n","import createShadow from '../../shared/create-shadow.js';\nimport effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\n\nexport default function EffectCreative({ swiper, extendParams, on }) {\n  extendParams({\n    creativeEffect: {\n      transformEl: null,\n      limitProgress: 1,\n      shadowPerProgress: false,\n      progressMultiplier: 1,\n      perspective: true,\n      prev: {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        opacity: 1,\n        scale: 1,\n      },\n      next: {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        opacity: 1,\n        scale: 1,\n      },\n    },\n  });\n\n  const getTranslateValue = (value) => {\n    if (typeof value === 'string') return value;\n    return `${value}px`;\n  };\n\n  const setTranslate = () => {\n    const { slides, $wrapperEl, slidesSizesGrid } = swiper;\n    const params = swiper.params.creativeEffect;\n    const { progressMultiplier: multiplier } = params;\n\n    const isCenteredSlides = swiper.params.centeredSlides;\n\n    if (isCenteredSlides) {\n      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n      $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);\n    }\n\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = slides.eq(i);\n      const slideProgress = $slideEl[0].progress;\n      const progress = Math.min(\n        Math.max($slideEl[0].progress, -params.limitProgress),\n        params.limitProgress,\n      );\n      let originalProgress = progress;\n\n      if (!isCenteredSlides) {\n        originalProgress = Math.min(\n          Math.max($slideEl[0].originalProgress, -params.limitProgress),\n          params.limitProgress,\n        );\n      }\n\n      const offset = $slideEl[0].swiperSlideOffset;\n      const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n      const r = [0, 0, 0];\n      let custom = false;\n      if (!swiper.isHorizontal()) {\n        t[1] = t[0];\n        t[0] = 0;\n      }\n      let data = {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        scale: 1,\n        opacity: 1,\n      };\n      if (progress < 0) {\n        data = params.next;\n        custom = true;\n      } else if (progress > 0) {\n        data = params.prev;\n        custom = true;\n      }\n      // set translate\n      t.forEach((value, index) => {\n        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(\n          progress * multiplier,\n        )}))`;\n      });\n      // set rotates\n      r.forEach((value, index) => {\n        r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n      });\n\n      $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n\n      const translateString = t.join(', ');\n      const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n      const scaleString =\n        originalProgress < 0\n          ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})`\n          : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n      const opacityString =\n        originalProgress < 0\n          ? 1 + (1 - data.opacity) * originalProgress * multiplier\n          : 1 - (1 - data.opacity) * originalProgress * multiplier;\n      const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n\n      // Set shadows\n      if ((custom && data.shadow) || !custom) {\n        let $shadowEl = $slideEl.children('.swiper-slide-shadow');\n        if ($shadowEl.length === 0 && data.shadow) {\n          $shadowEl = createShadow(params, $slideEl);\n        }\n        if ($shadowEl.length) {\n          const shadowOpacity = params.shadowPerProgress\n            ? progress * (1 / params.limitProgress)\n            : progress;\n          $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n        }\n      }\n\n      const $targetEl = effectTarget(params, $slideEl);\n      $targetEl.transform(transform).css({ opacity: opacityString });\n      if (data.origin) {\n        $targetEl.css('transform-origin', data.origin);\n      }\n    }\n  };\n\n  const setTransition = (duration) => {\n    const { transformEl } = swiper.params.creativeEffect;\n    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n    $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);\n\n    effectVirtualTransitionEnd({ swiper, duration, transformEl, allSlides: true });\n  };\n\n  effectInit({\n    effect: 'creative',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => swiper.params.creativeEffect.perspective,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n      virtualTranslate: !swiper.params.cssMode,\n    }),\n  });\n}\n","import createShadow from '../../shared/create-shadow.js';\nimport effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\n\nexport default function EffectCards({ swiper, extendParams, on }) {\n  extendParams({\n    cardsEffect: {\n      slideShadows: true,\n      transformEl: null,\n      rotate: true,\n      perSlideRotate: 2,\n      perSlideOffset: 8,\n    },\n  });\n\n  const setTranslate = () => {\n    const { slides, activeIndex } = swiper;\n    const params = swiper.params.cardsEffect;\n    const { startTranslate, isTouched } = swiper.touchEventsData;\n    const currentTranslate = swiper.translate;\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = slides.eq(i);\n      const slideProgress = $slideEl[0].progress;\n      const progress = Math.min(Math.max(slideProgress, -4), 4);\n      let offset = $slideEl[0].swiperSlideOffset;\n      if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n        swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);\n      }\n      if (swiper.params.centeredSlides && swiper.params.cssMode) {\n        offset -= slides[0].swiperSlideOffset;\n      }\n      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n      let tY = 0;\n      const tZ = -100 * Math.abs(progress);\n      let scale = 1;\n      let rotate = -params.perSlideRotate * progress;\n\n      let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n\n      const slideIndex =\n        swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n\n      const isSwipeToNext =\n        (slideIndex === activeIndex || slideIndex === activeIndex - 1) &&\n        progress > 0 &&\n        progress < 1 &&\n        (isTouched || swiper.params.cssMode) &&\n        currentTranslate < startTranslate;\n      const isSwipeToPrev =\n        (slideIndex === activeIndex || slideIndex === activeIndex + 1) &&\n        progress < 0 &&\n        progress > -1 &&\n        (isTouched || swiper.params.cssMode) &&\n        currentTranslate > startTranslate;\n\n      if (isSwipeToNext || isSwipeToPrev) {\n        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n        rotate += -28 * progress * subProgress;\n        scale += -0.5 * subProgress;\n        tXAdd += 96 * subProgress;\n        tY = `${-25 * subProgress * Math.abs(progress)}%`;\n      }\n\n      if (progress < 0) {\n        // next\n        tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;\n      } else if (progress > 0) {\n        // prev\n        tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;\n      } else {\n        tX = `${tX}px`;\n      }\n      if (!swiper.isHorizontal()) {\n        const prevY = tY;\n        tY = tX;\n        tX = prevY;\n      }\n\n      const scaleString =\n        progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n\n      const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rotate : 0}deg)\n        scale(${scaleString})\n      `;\n\n      if (params.slideShadows) {\n        // Set shadows\n        let $shadowEl = $slideEl.find('.swiper-slide-shadow');\n        if ($shadowEl.length === 0) {\n          $shadowEl = createShadow(params, $slideEl);\n        }\n        if ($shadowEl.length)\n          $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n      }\n\n      $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n      const $targetEl = effectTarget(params, $slideEl);\n      $targetEl.transform(transform);\n    }\n  };\n\n  const setTransition = (duration) => {\n    const { transformEl } = swiper.params.cardsEffect;\n    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n    $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);\n\n    effectVirtualTransitionEnd({ swiper, duration, transformEl });\n  };\n\n  effectInit({\n    effect: 'cards',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => true,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n      virtualTranslate: !swiper.params.cssMode,\n    }),\n  });\n}\n"]},"metadata":{},"sourceType":"module"}